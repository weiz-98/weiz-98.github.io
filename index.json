
[{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/abstract-factory/","section":"Tags","summary":"","title":"Abstract Factory","type":"tags"},{"content":"下面用 Abstract Factory（抽象工廠） 在 Golang 的實作，從概念 → 結構 → 什麼時候用 → 經典範例（跨平台 UI 元件族）→ 實務版（雲端儲存產品族）→ 測試與演進，完整說明。\n抽象工廠是什麼？ # 定義（GoF） 提供一個介面，用來建立「一族互相關聯或相依的產品（related products）」，而不需指定具體類別。\n核心目標\n一次性產出成套產品（例如同一平台風格的 Button、Checkbox、Dialog）。 保持相容性與一致性：同一工廠生出的產品彼此可搭配使用。 未來替換「一整族」產品時，高階邏輯無須修改（OCP）。 與 Factory Method 不同：Factory Method 著重「單一產品的可替換」，抽象工廠則著重「多個關聯產品的成套替換」。\nGo 語言實作觀念 # Go 沒有類別繼承，典型寫法是：\n用 interface 定義「產品族」中每個產品的能力。 用 介面 定義「工廠」能產生哪些產品。 以多個 Concrete Factory（具體工廠）實作：同時回傳同平台/同品牌/同供應商的一組產品。 何時使用抽象工廠？ # 你需要同時替換多個關聯產品，且它們必須保持「平台/品牌一致」。 例：UI 元件（Windows/Mac/Linux），DB 物件（Tx/Conn/Stmt）一組、雲供應商一組（Bucket/Uploader/Signer）。 你的高階流程應該不認識具體型別，只透過工廠拿到正確族群的產品。 你想把「選擇哪一族產品」放到設定檔、旗標、環境變數，甚至外掛擴充。 經典教學範例：跨平台 UI 元件族 # 我們定義兩個產品：Button、Checkbox。 並定義一個抽象工廠：WidgetFactory，同時生出 Button 與 Checkbox。\n1) 產品介面 # package ui type Button interface { Render() string OnClick() string } type Checkbox interface { Render() string IsChecked() bool Toggle() } 2) 抽象工廠介面 # package ui type WidgetFactory interface { NewButton() Button NewCheckbox() Checkbox } 3) 具體產品（Windows 系列） # package win import \u0026#34;fmt\u0026#34; type WinButton struct{} func (WinButton) Render() string { return \u0026#34;[WIN] Button\u0026#34; } func (WinButton) OnClick() string { return \u0026#34;WinButton clicked\u0026#34; } type WinCheckbox struct{ checked bool } func (c *WinCheckbox) Render() string { if c.checked { return \u0026#34;[WIN] Checkbox: [x]\u0026#34; } return \u0026#34;[WIN] Checkbox: [ ]\u0026#34; } func (c *WinCheckbox) IsChecked() bool { return c.checked } func (c *WinCheckbox) Toggle() { c.checked = !c.checked } 4) 具體產品（Mac 系列） # package mac type MacButton struct{} func (MacButton) Render() string { return \u0026#34;[MAC] Button\u0026#34; } func (MacButton) OnClick() string { return \u0026#34;MacButton clicked\u0026#34; } type MacCheckbox struct{ checked bool } func (c *MacCheckbox) Render() string { if c.checked { return \u0026#34;[MAC] Checkbox: [x]\u0026#34; } return \u0026#34;[MAC] Checkbox: [ ]\u0026#34; } func (c *MacCheckbox) IsChecked() bool { return c.checked } func (c *MacCheckbox) Toggle() { c.checked = !c.checked } 5) 具體工廠（Windows / Mac） # package win import \u0026#34;example.com/ui\u0026#34; type WinFactory struct{} func (WinFactory) NewButton() ui.Button { return WinButton{} } func (WinFactory) NewCheckbox() ui.Checkbox { return \u0026amp;WinCheckbox{} } package mac import \u0026#34;example.com/ui\u0026#34; type MacFactory struct{} func (MacFactory) NewButton() ui.Button { return MacButton{} } func (MacFactory) NewCheckbox() ui.Checkbox { return \u0026amp;MacCheckbox{} } 6) 高階流程：只依賴抽象工廠與產品介面 # package app import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/ui\u0026#34; ) type App struct { factory ui.WidgetFactory } func NewApp(f ui.WidgetFactory) *App { return \u0026amp;App{factory: f} } // 高階流程不關心是哪個平台，保持一致使用同一工廠產出的「一族產品」 func (a *App) Draw() string { btn := a.factory.NewButton() cb := a.factory.NewCheckbox() s := \u0026#34;\u0026#34; s += btn.Render() + \u0026#34; | \u0026#34; + btn.OnClick() + \u0026#34;\\n\u0026#34; s += cb.Render() + \u0026#34;\\n\u0026#34; cb.Toggle() s += cb.Render() + \u0026#34;\\n\u0026#34; return s } 7) 使用（選擇工廠 = 選擇一整族） # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/app\u0026#34; \u0026#34;example.com/mac\u0026#34; \u0026#34;example.com/win\u0026#34; ) func main() { // 切到 Windows 族 a1 := app.NewApp(win.WinFactory{}) fmt.Println(a1.Draw()) // 切到 Mac 族 a2 := app.NewApp(mac.MacFactory{}) fmt.Println(a2.Draw()) } 重點：\nApp 的高階流程完全不需要知道 WinButton 或 MacCheckbox 是什麼。 想換平台 → 換工廠即可。一處注入，全面一致。 實務版：雲端儲存產品族（S3 / GCS / Azure） # 產品族包含：Bucket、Uploader、Signer。它們彼此相依、同供應商版本才會合拍。\n1) 抽象介面 # package storage import \u0026#34;io\u0026#34; type Bucket interface { Name() string Exists() (bool, error) } type Uploader interface { Upload(object string, r io.Reader) (url string, err error) } type Signer interface { SignedURL(object string) (string, error) } type Factory interface { NewBucket(name string) Bucket NewUploader(bucket Bucket) Uploader NewSigner(bucket Bucket) Signer } 2) 具體工廠（以 S3 舉例） # package s3 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;example.com/storage\u0026#34; ) type s3Bucket struct{ name string } func (b s3Bucket) Name() string { return b.name } func (b s3Bucket) Exists() (bool, error) { return true, nil } // demo 略 type s3Uploader struct{ bucket storage.Bucket } func (u s3Uploader) Upload(obj string, r io.Reader) (string, error) { // 呼叫 AWS SDK 實作（此處簡化） return fmt.Sprintf(\u0026#34;https://s3.amazonaws.com/%s/%s\u0026#34;, u.bucket.Name(), obj), nil } type s3Signer struct{ bucket storage.Bucket } func (s s3Signer) SignedURL(obj string) (string, error) { return fmt.Sprintf(\u0026#34;s3-signed://%s/%s\u0026#34;, s.bucket.Name(), obj), nil } type S3Factory struct{} func (S3Factory) NewBucket(name string) storage.Bucket { return s3Bucket{name} } func (S3Factory) NewUploader(b storage.Bucket) storage.Uploader { return s3Uploader{b} } func (S3Factory) NewSigner(b storage.Bucket) storage.Signer { return s3Signer{b} } 同理可實作 gcs.GCSFactory、azure.AzureFactory，保證回傳的 Bucket/Uploader/Signer 能互相搭配。\n3) 高階業務流程 # package svc import ( \u0026#34;bytes\u0026#34; \u0026#34;example.com/storage\u0026#34; ) type FileService struct { f storage.Factory } func NewFileService(f storage.Factory) *FileService { return \u0026amp;FileService{f: f} } func (s *FileService) SaveReport(bucketName, object string, content []byte) (publicURL string, signed string, err error) { b := s.f.NewBucket(bucketName) ok, err := b.Exists() if err != nil || !ok { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, err } up := s.f.NewUploader(b) url, err := up.Upload(object, bytes.NewReader(content)) if err != nil { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, err } signer := s.f.NewSigner(b) signedURL, err := signer.SignedURL(object) return url, signedURL, err } 優點：\n切換供應商 → 換 Factory 即可，一次替換所有相關產品（Bucket/Uploader/Signer）。 模組邊界清楚，可測試性高：用假的 Factory/Bucket/Uploader/Signer 即可替代 I/O。 注入、動態選型、與測試 # A) 依賴注入（建議） # // 組裝期：根據設定決定工廠 func BuildFileService(provider string) *svc.FileService { var f storage.Factory switch provider { case \u0026#34;s3\u0026#34;: f = s3.S3Factory{} case \u0026#34;gcs\u0026#34;: f = gcs.GCSFactory{} default: panic(\u0026#34;unknown provider\u0026#34;) } return svc.NewFileService(f) } B) Registry（登記式工廠，外掛友善） # type Registry struct { mu sync.RWMutex m map[string]storage.Factory } func (r *Registry) Register(name string, f storage.Factory) { r.mu.Lock(); defer r.mu.Unlock() if r.m == nil { r.m = make(map[string]storage.Factory) } r.m[name] = f } func (r *Registry) Get(name string) (storage.Factory, bool) { r.mu.RLock(); defer r.mu.RUnlock() f, ok := r.m[name]; return f, ok } 注意併發：在 init() 階段註冊或加鎖；或只在主執行緒組裝。\nC) 單元測試：以「假工廠 + 假產品」注入 # type fakeBucket struct{ name string } func (f fakeBucket) Name() string { return f.name } func (f fakeBucket) Exists() (bool, error) { return true, nil } type fakeUploader struct{ url string } func (f fakeUploader) Upload(string, io.Reader) (string, error) { return f.url, nil } type fakeSigner struct{ u string } func (f fakeSigner) SignedURL(string) (string, error) { return f.u, nil } type fakeFactory struct{} func (fakeFactory) NewBucket(n string) storage.Bucket { return fakeBucket{n} } func (fakeFactory) NewUploader(b storage.Bucket) storage.Uploader { return fakeUploader{\u0026#34;http://fake/\u0026#34;+b.Name()} } func (fakeFactory) NewSigner(b storage.Bucket) storage.Signer { return fakeSigner{\u0026#34;signed://\u0026#34;+b.Name()} } // 測試中：svc := NewFileService(fakeFactory{}) 與 Factory Method / 簡單工廠比較 # 模式 著力點 適用情境 擴充成本 簡單工廠（非 GoF） 一個函式 New(t) 決定回傳哪個單一產品 只有少量變體，建立點集中 新增變體常需改 switch（違 OCP） 工廠方法 高階流程裡的「建立某一產品」可被覆寫/注入 單一產品的替換（例如不同 Exporter） 新增產品：新增 ConcreteCreator 抽象工廠 一族關聯產品同時替換 平台/品牌/供應商成套替換（UI、雲服務） 新增一族：新增一個 ConcreteFactory（舊流程不變） 常見陷阱與建議（Go 實務） # 產品介面定義過胖：拆成小介面（ISP），避免測試與替換困難。 工廠返回零值/不完整產品：若產品之間有相依，工廠內要一次組好（或回傳錯誤）。 混用不同族產品：高階流程只能拿同一工廠產出的產品，避免跨族不相容。 過度工程化：若只是單一產品的替換，不必用抽象工廠；用 Factory Method/函式注入即可。 可觀測性：對外掛式工廠加入健康檢查（Validate()）或版本標記，方便除錯。 精簡可複製範例（最小可用） # // 抽象層 type Button interface{ Render() string } type Checkbox interface{ Render() string } type WidgetFactory interface{ NewButton() Button NewCheckbox() Checkbox } // 具體工廠：Dark 主題 type darkButton struct{} func (darkButton) Render() string { return \u0026#34;dark-button\u0026#34; } type darkCheckbox struct{} func (darkCheckbox) Render() string { return \u0026#34;dark-checkbox\u0026#34; } type DarkFactory struct{} func (DarkFactory) NewButton() Button { return darkButton{} } func (DarkFactory) NewCheckbox() Checkbox { return darkCheckbox{} } // 具體工廠：Light 主題 type lightButton struct{} func (lightButton) Render() string { return \u0026#34;light-button\u0026#34; } type lightCheckbox struct{} func (lightCheckbox) Render() string { return \u0026#34;light-checkbox\u0026#34; } type LightFactory struct{} func (LightFactory) NewButton() Button { return lightButton{} } func (LightFactory) NewCheckbox() Checkbox { return lightCheckbox{} } // 高階流程 type Page struct{ f WidgetFactory } func NewPage(f WidgetFactory) *Page { return \u0026amp;Page{f: f} } func (p *Page) Draw() []string { return []string{ p.f.NewButton().Render(), p.f.NewCheckbox().Render(), } } 總結 # 抽象工廠：用「一個工廠介面」一次性生出成套的關聯產品，讓高階流程保持平台/供應商一致性，並能在不改動高階流程的前提下，替換整個產品族。 在 Go：以 interface + 具體工廠實作最自然；結合依賴注入或 Registry 可更彈性；測試時注入 fake factory 即可孤立 I/O。 選型心法：單產品替換 → Factory Method；成套替換 → Abstract Factory；變體很少且集中 → 簡單工廠就好。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/abstract-factory-with-go/","section":"All my post","summary":"Abstract factory with Go","title":"Abstract factory with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/adapter/","section":"Tags","summary":"","title":"Adapter","type":"tags"},{"content":"下面用 Adapter（轉接器／適配器） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 易錯點/最佳實務」的完整說明，並附上多個可直接複製的程式範例（含：物件轉接、函式型轉接、第三方套件轉接、資料流介面轉接、錯誤轉換與測試）。\nAdapter 是什麼？何時用？ # 定義（GoF） 將一個類別（或物件）的介面轉換成客戶端所期望的另一個介面，使原本因介面不相容而無法一起工作的類別（或物件）可以協同運作。\n何時用\n要把既有（Legacy）或第三方元件接到你系統，但介面不合。 想逐步遷移舊介面到新介面（舊程式碼仍可執行）。 想將不同供應商的 SDK 統一在同一 Target 介面之下。 在 Go 裡沒有類別繼承，Adapter 幾乎都以**組合（composition）與包裝（wrapper）完成；另有常見的函式轉型（function adapter）**技巧。\n角色與 Go 寫法對照 # Target（目標介面）：客戶端想要的介面（interface）。 Adaptee（被轉接者）：現有（不相容）的型別或套件。 Adapter（轉接器）：實作 Target，內部組合 Adaptee，轉換呼叫/資料格式/錯誤。 範例 1：物件轉接（Object Adapter，最常見） # 情境：你的系統用 PaymentProcessor 介面；公司買了舊系統 LegacyPay，方法/參數都不同。用 Adapter 把 LegacyPay 接進來。\npackage adapter1 import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // === Target：新系統想要的介面 === type PaymentProcessor interface { Pay(cents int, currency string, note string) (txID string, err error) } // === Adaptee：舊系統/第三方 === type LegacyPay struct{} func (LegacyPay) MakePayment(amount float64, meta map[string]string) (string, error) { if amount \u0026lt;= 0 { return \u0026#34;\u0026#34;, errors.New(\u0026#34;invalid amount\u0026#34;) } // ... 舊系統的流程（略） return \u0026#34;LEG-\u0026#34;+fmt.Sprint(int(amount*1000)), nil } // === Adapter：包一層把參數與錯誤轉換成 Target 期望 === type LegacyPayAdapter struct { lp LegacyPay } func NewLegacyPayAdapter(lp LegacyPay) *LegacyPayAdapter { return \u0026amp;LegacyPayAdapter{lp: lp} } // 實作 Target func (a *LegacyPayAdapter) Pay(cents int, currency string, note string) (string, error) { if cents \u0026lt;= 0 { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;amount must be \u0026gt; 0\u0026#34;) } amount := float64(cents) / 100.0 meta := map[string]string{\u0026#34;currency\u0026#34;: currency, \u0026#34;note\u0026#34;: note} tx, err := a.lp.MakePayment(amount, meta) if err != nil { // 錯誤轉換（必要時加上 sentry tags、wrap 原錯） return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;legacy payment failed: %w\u0026#34;, err) } return tx, nil } // === Client === func Checkout(proc PaymentProcessor) error { _, err := proc.Pay(1299, \u0026#34;USD\u0026#34;, \u0026#34;book\u0026#34;) return err } 使用：\nlp := adapter1.LegacyPay{} proc := adapter1.NewLegacyPayAdapter(lp) _ = adapter1.Checkout(proc) 重點\n參數轉換（int cents → float / meta map）。 錯誤轉換（wrap 原錯，維持可觀測性）。 Target 完全不需要知道 LegacyPay 的存在。 範例 2：函式型轉接（Function Adapter） # Go 常見模式：以函式型別實作介面，快速把「函式」轉成「介面」實作（http.HandlerFunc 就是經典例子）。\npackage adapter2 import ( \u0026#34;net/http\u0026#34; ) // Target：我們要的是 http.Handler // 標準庫提供了函式型轉接器：type HandlerFunc func(ResponseWriter, *Request) // 它實作了 ServeHTTP，所以可當作 http.Handler 使用。 func Example(mux *http.ServeMux) { // 直接把匿名函式轉成 Handler（function adapter） mux.Handle(\u0026#34;/ping\u0026#34;, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;pong\u0026#34;)) })) } 自訂一個函式型轉接器：\n// Target type Validator interface { Validate(s string) bool } // Function Adapter：函式型別 type ValidateFunc func(string) bool // 實作介面 func (f ValidateFunc) Validate(s string) bool { return f(s) } // 使用 isEmail := ValidateFunc(func(s string) bool { return len(s) \u0026gt;= 3 \u0026amp;\u0026amp; s[len(s)-1] == \u0026#39;m\u0026#39; // 示意 }) var v Validator = isEmail _ = v.Validate(\u0026#34;a@b.com\u0026#34;) 優點：簡潔、零樣板。 限制：通常只適合介面單一方法或方法簽章可合理封裝的情況。\n範例 3：第三方 SDK 的轉接（實務常見） # 情境：你的系統期望 Notifier，而公司選的雲服務 SDK 是另一種介面。用 Adapter 做統一抽象，將來要換供應商只換 Adapter 即可。\npackage adapter3 import \u0026#34;fmt\u0026#34; // Target type Notifier interface { Send(to string, msg string) error } // Adaptee：第三方 SDK（假想） type CloudXClient struct{} func (CloudXClient) Push(payload map[string]string) error { if payload[\u0026#34;to\u0026#34;] == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;missing to\u0026#34;) } // 呼叫遠端 API（略） return nil } // Adapter type CloudXNotifier struct{ c CloudXClient } func NewCloudXNotifier(c CloudXClient) *CloudXNotifier { return \u0026amp;CloudXNotifier{c: c} } func (n *CloudXNotifier) Send(to, msg string) error { payload := map[string]string{\u0026#34;to\u0026#34;: to, \u0026#34;text\u0026#34;: msg} if err := n.c.Push(payload); err != nil { return fmt.Errorf(\u0026#34;cloudx push failed: %w\u0026#34;, err) } return nil } 替換供應商時，只要再寫一個 CloudYNotifier，其餘程式碼零變更（依賴倒置）。\n範例 4：資料流介面轉接（io.Reader ↔ []byte 等） # 把各種資料來源轉成 io.Reader 或 io.Writer 是日常 Adapter。下面把「一次性 byte 切片」轉成 io.Reader：\npackage adapter4 import ( \u0026#34;bytes\u0026#34; \u0026#34;io\u0026#34; ) type ByteSource interface { Bytes() []byte } // Adaptee type Blob struct{ data []byte } func (b Blob) Bytes() []byte { return b.data } // Target：io.Reader type blobReader struct{ b ByteSource } func NewReaderFromByteSource(b ByteSource) io.Reader { return bytes.NewReader(b.Bytes()) // 直接用標準庫的 adapter（最佳） } // 反向：把 Reader 全讀進 []byte（注意：可能很大！） func ReadAllToBytes(r io.Reader) ([]byte, error) { return io.ReadAll(r) } 備註：能用標準庫提供的 adapter就用（如 bytes.NewReader、strings.NewReader、io.NopCloser、http.HandlerFunc…）。自己寫的 adapter 只在缺少轉接時才補。\n範例 5：錯誤等級與語義轉換（Error Adapter） # Adapter 不只轉方法簽章，也常做回傳值／錯誤的語義轉換（把異質的錯誤規格統一）。\npackage adapter5 import \u0026#34;errors\u0026#34; // Target 統一錯誤 var ( ErrNotFound = errors.New(\u0026#34;not found\u0026#34;) ErrConflict = errors.New(\u0026#34;conflict\u0026#34;) ErrTemporary = errors.New(\u0026#34;temporary\u0026#34;) ) // Adaptee 的錯誤（第三方） var ( ErrNoRow = errors.New(\u0026#34;no row\u0026#34;) ErrDupKey = errors.New(\u0026#34;dup key\u0026#34;) ErrTimeout = errors.New(\u0026#34;timeout\u0026#34;) ) func adaptError(err error) error { switch { case errors.Is(err, ErrNoRow): return ErrNotFound case errors.Is(err, ErrDupKey): return ErrConflict case errors.Is(err, ErrTimeout): return ErrTemporary default: return err } } 測試策略（重點） # 行為等價：替入 Adapter 後，Client 對 Target 的預期不變。 邊界條件：空輸入、極端輸入、錯誤傳遞（是否 wrap/轉換正確）。 資源管理：若 Adaptee 需要 Close/Release，Adapter 須負責（或明確交由上層）。 並發安全：Adapter 內若有共享狀態，必須加鎖或使其無共享（多數 Adapter 應為無狀態或只讀）。 簡例：\nfunc TestLegacyPayAdapter(t *testing.T) { a := NewLegacyPayAdapter(LegacyPay{}) if _, err := a.Pay(0, \u0026#34;USD\u0026#34;, \u0026#34;x\u0026#34;); err == nil { t.Fatal(\u0026#34;expect error for zero amount\u0026#34;) } tx, err := a.Pay(100, \u0026#34;USD\u0026#34;, \u0026#34;ok\u0026#34;) if err != nil || tx == \u0026#34;\u0026#34; { t.Fatalf(\u0026#34;unexpected: tx=%q err=%v\u0026#34;, tx, err) } } 與 Facade / Decorator / Bridge 的差異 # 模式 目的 關係 Adapter 轉介面符合客戶端期望 針對「不相容介面」之間的對接 Facade 提供簡化外觀、隱藏子系統複雜度 目標相同，但通常不改介面語義，只縮減/編排 Decorator 在不改介面前提下附加行為 介面相同，行為更多 Bridge 將抽象與實作分離，獨立演進 設計抽象層與實作層，非「轉介面」 常見陷阱與最佳實務 # 別洩漏 Adaptee 細節：Target/Client 不該 import Adaptee 的型別。 維持錯誤語義：清楚規範錯誤的映射表；必要時 errors.Is/As 保留鍊路。 資源生命週期：誰負責關閉？在 Adapter 設計上說清楚。 效能與拷貝：轉換資料（JSON/Buffer）時避免不必要的複製；能用串流就不用全載入。 並發安全：若 Adapter 內有可變狀態，用 sync.Mutex 或改為「每呼叫新建臨時物件」。 優先用標準庫既有 Adapter：如 http.HandlerFunc、io.NopCloser、bytes.NewReader、fmt.Stringer 等。 迷你整合示例（把多家通知 SDK 統一在 Notifier 介面） # package notify import \u0026#34;fmt\u0026#34; // Target type Notifier interface { Send(to, msg string) error } // Adaptee A（Email） type SMTPClient struct{} func (SMTPClient) SendMail(to, body string) error { return nil } // 略 type EmailAdapter struct{ c SMTPClient } func (a EmailAdapter) Send(to, msg string) error { return a.c.SendMail(to, msg) } // Adaptee B（Slack） type SlackClient struct{} func (SlackClient) Post(channel, text string) error { return nil } type SlackAdapter struct{ c SlackClient; channel string } func (a SlackAdapter) Send(to, msg string) error { // to 可忽略或映射成不同 channel return a.c.Post(a.channel, fmt.Sprintf(\u0026#34;[%s] %s\u0026#34;, to, msg)) } // 使用端只依賴 Target func Broadcast(n Notifier, users []string, text string) error { for _, u := range users { if err := n.Send(u, text); err != nil { return err } } return nil } 總結 # Adapter 在 Go 的核心是「用組合包裝 Adaptee，對外實作 Target」，必要時做參數/資料/錯誤轉換。 形態多元：物件轉接最常見，函式型轉接超好用，資料流轉接日常高頻。 實務上要特別注意：錯誤語義、資源生命週期、效能與並發安全。 搭配良好抽象（Target 介面）後，未來替換供應商/SDK成本極低，且可逐步移轉 Legacy。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/adapter-with-go/","section":"All my post","summary":"Adapter with Go","title":"Adapter with Go","type":"docs"},{"content":" 一些工作雜記.. ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/","section":"All my post","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  一些工作雜記..\n\u003c/div\u003e\n\n\u003chr\u003e","title":"All my post","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/bridge/","section":"Tags","summary":"","title":"Bridge","type":"tags"},{"content":"下面用 Bridge（橋接模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 易錯點/最佳實務」的完整說明，並附上多個可直接複製的程式範例（遙控器/裝置、圖形/渲染器、服務/儲存驅動三種經典雙維度拆分）。\nBridge 是什麼？為何需要？ # 定義（GoF） 將抽象（Abstraction）與其實作（Implementor）分離，使兩者可以獨立變化。也就是把一個「在兩個維度上會成長」的型別拆成兩個維度，各自演進、互相橋接。\n何時用（判斷題）\n你的型別同時沿著兩個維度擴張：\n例：遙控器型別（基本/進階） × 裝置型別（TV/Radio/Projector）。 例：圖形型別（Circle/Rectangle） × 渲染方式（Vector/Raster）。 例：服務 API（KeyValue/Queue） × 儲存驅動（Memory/Redis/SQL）。 你不想每多一個變體就產生笛卡兒爆炸（BasicTVRemote、BasicRadioRemote、AdvancedTVRemote…）。\n希望抽象層（對外 API）不必知道實作細節，且實作層能熱插拔。\n與 Adapter 的差別：Adapter 是「把不相容介面轉接」。Bridge 是「設計時就刻意分兩層」，讓兩邊各自演進。\n角色對照（Go 寫法） # Abstraction（抽象）：對外 API；組合一個 Implementor。 Refined Abstraction：抽象的變體（附加行為/不同策略）。 Implementor（實作介面）：抽象層真正呼叫的底層能力。 Concrete Implementor：實作的變體（不同平台/供應商/設備）。 在 Go 中用 interface + composition 即可；絕對不要走繼承。\n範例一：遙控器（抽象） × 裝置（實作） # 程式碼 # package main import ( \u0026#34;fmt\u0026#34; ) // ===== Implementor：裝置能力 ===== type Device interface { IsOn() bool On() Off() GetVolume() int SetVolume(v int) } type TV struct{ on bool; vol int } func (t *TV) IsOn() bool { return t.on } func (t *TV) On() { t.on = true } func (t *TV) Off() { t.on = false } func (t *TV) GetVolume() int { return t.vol } func (t *TV) SetVolume(v int) { if v \u0026lt; 0 { v = 0 }; if v \u0026gt; 100 { v = 100 }; t.vol = v } type Radio struct{ on bool; vol int } func (r *Radio) IsOn() bool { return r.on } func (r *Radio) On() { r.on = true } func (r *Radio) Off() { r.on = false } func (r *Radio) GetVolume() int { return r.vol } func (r *Radio) SetVolume(v int) { if v \u0026lt; 0 { v = 0 }; if v \u0026gt; 100 { v = 100 }; r.vol = v } // ===== Abstraction：遙控器，橋接一個 Device ===== type Remote struct{ d Device } func NewRemote(d Device) *Remote { return \u0026amp;Remote{d: d} } func (r *Remote) TogglePower() { if r.d.IsOn() { r.d.Off() } else { r.d.On() } } func (r *Remote) VolumeUp() { r.d.SetVolume(r.d.GetVolume() + 10) } func (r *Remote) VolumeDown() { r.d.SetVolume(r.d.GetVolume() - 10) } // ===== Refined Abstraction：進階遙控器 ===== type AdvancedRemote struct{ *Remote } func NewAdvancedRemote(d Device) *AdvancedRemote { return \u0026amp;AdvancedRemote{NewRemote(d)} } func (a *AdvancedRemote) Mute() { a.d.SetVolume(0) } // ===== Demo ===== func main() { tv := \u0026amp;TV{} r1 := NewRemote(tv) r1.TogglePower() r1.VolumeUp() fmt.Println(\u0026#34;TV on:\u0026#34;, tv.IsOn(), \u0026#34;vol:\u0026#34;, tv.GetVolume()) // TV on: true vol: 10 radio := \u0026amp;Radio{} r2 := NewAdvancedRemote(radio) r2.TogglePower() r2.VolumeUp(); r2.VolumeUp() r2.Mute() fmt.Println(\u0026#34;Radio on:\u0026#34;, radio.IsOn(), \u0026#34;vol:\u0026#34;, radio.GetVolume()) // Radio on: true vol: 0 } 看點\nRemote（抽象）只認識 Device（實作介面），不關心是 TV 還是 Radio。 要增新裝置 → 只要實作 Device；要增新遙控器功能 → 繼續在抽象側擴充。 兩個維度彼此獨立成長。 範例二：圖形（抽象） × 渲染器（實作） # 程式碼 # package graphics import \u0026#34;fmt\u0026#34; // Implementor：渲染器 type Renderer interface { DrawCircle(x, y, r int) DrawRect(x, y, w, h int) } type VectorRenderer struct{} func (VectorRenderer) DrawCircle(x, y, r int) { fmt.Printf(\u0026#34;[Vector] circle (%d,%d) r=%d\\n\u0026#34;, x, y, r) } func (VectorRenderer) DrawRect(x, y, w, h int){ fmt.Printf(\u0026#34;[Vector] rect (%d,%d) %dx%d\\n\u0026#34;, x, y, w, h) } type RasterRenderer struct{} func (RasterRenderer) DrawCircle(x, y, r int) { fmt.Printf(\u0026#34;[Raster] circle (%d,%d) r=%d (pixels)\\n\u0026#34;, x, y, r) } func (RasterRenderer) DrawRect(x, y, w, h int){ fmt.Printf(\u0026#34;[Raster] rect (%d,%d) %dx%d (pixels)\\n\u0026#34;, x, y, w, h) } // Abstraction：Shape type Shape interface { Draw() } type Circle struct { R Renderer X, Y, Radius int } func (c Circle) Draw() { c.R.DrawCircle(c.X, c.Y, c.Radius) } type Rect struct { R Renderer X, Y, W, H int } func (r Rect) Draw() { r.R.DrawRect(r.X, r.Y, r.W, r.H) } // 使用： // v := graphics.VectorRenderer{} // r := graphics.RasterRenderer{} // graphics.Circle{R:v, X:0, Y:0, Radius:10}.Draw() // graphics.Rect{R:r, X:5, Y:5, W:20, H:10}.Draw() 看點\n新增圖形（Ellipse/Polygon）→ 扩充抽象側；新增渲染法（OpenGL/Metal/WebGL）→ 扩充實作側。 任意組合：任一Shape × 任一Renderer。 範例三：服務 API（抽象） × 儲存驅動（實作） # 程式碼 # package bridge_store import ( \u0026#34;errors\u0026#34; \u0026#34;sync\u0026#34; ) // Implementor：KeyValue 後端 type KVStore interface { Get(key string) (string, bool) Put(key, val string) error } type MemoryStore struct { mu sync.RWMutex m map[string]string } func NewMemoryStore() *MemoryStore { return \u0026amp;MemoryStore{m: map[string]string{}} } func (s *MemoryStore) Get(k string) (string, bool) { s.mu.RLock(); defer s.mu.RUnlock(); v, ok := s.m[k]; return v, ok } func (s *MemoryStore) Put(k, v string) error { s.mu.Lock(); defer s.mu.Unlock(); s.m[k] = v; return nil } // 你也可以再做一個 RedisStore / SQLStore，實作 KVStore。 // Abstraction：服務層（不綁定具體儲存） type ProfileService struct { store KVStore // 橋 } func NewProfileService(s KVStore) *ProfileService { return \u0026amp;ProfileService{store: s} } func (p *ProfileService) SetNickname(userID, nickname string) error { if userID == \u0026#34;\u0026#34; || nickname == \u0026#34;\u0026#34; { return errors.New(\u0026#34;bad input\u0026#34;) } return p.store.Put(\u0026#34;u:\u0026#34;+userID+\u0026#34;:nick\u0026#34;, nickname) } func (p *ProfileService) NicknameOf(userID string) (string, bool) { return p.store.Get(\u0026#34;u:\u0026#34;+userID+\u0026#34;:nick\u0026#34;) } 看點\n服務只依賴 KVStore 介面，可在本機用 MemoryStore 單元測試，在雲端用 RedisStore 上線。 典型「抽象 × 實作獨立變化」：新增更多服務 API（抽象側）或更多儲存驅動（實作側）。 與相近模式比較（超容易混淆） # 模式 何時用 關鍵差異 Bridge 你設計時就知道會有兩個維度需要獨立演進（抽象 × 實作）。 透過組合把兩側分離；避免類別爆炸。 Adapter 已存在兩個不相容介面要接在一起。 目的是轉介面，不是拆維度。 Strategy 只想替換「演算法/策略」。 抽象側通常不改，僅替換策略；橋接則是兩側都可演進。 Abstract Factory 一次生出「同族」實作物件。 常與 Bridge 串用：工廠決定實作族，Bridge 注入使用。 測試與實務要點 # 抽象與實作分測：\n實作側（例如 MemoryStore）寫單元測試，保證符合 KVStore 契約。 抽象側（例如 ProfileService）用假的/記憶體實作注入，測行為。 依賴注入：把 Implementor 介面注入到 Abstraction，別在抽象層內部 new 具體實作。\n效能與併發：Bridge 本身很薄，開銷極小；真正的併發/鎖要放在實作側。\n錯誤設計：抽象層多半只包裝/向上拋出錯誤，不要吞錯；必要時建立錯誤邊界（轉成領域錯誤）。\n搭配 Abstract Factory：在組裝期用工廠選擇實作族（例如 RendererFactory(\u0026quot;raster\u0026quot;)），再注入到抽象。\n常見陷阱 \u0026amp; 最佳實務 # 把 Bridge 寫成 Adapter：如果你在改現有不相容介面，那是 Adapter；若你在設計雙維度，才是 Bridge。 抽象層硬編碼實作：例如在 NewService() 內直接 new Redis → 破壞可替換性。請改用參數注入。 實作介面過胖：將 Implementor 拆成小介面（ISP），避免每個實作都必須實作不需要的方法。 測試難互換：定義清楚契約（thread-safety、錯誤語義、容量限制），撰寫假實作（in-memory fake）幫助測試。 類別爆炸：若只有單一維度需要變化 → 用 Strategy/Adapter/Factory 即可，不必上 Bridge。 迷你整合（可直接跑）：選渲染器 + 畫圖形 # package main import \u0026#34;fmt\u0026#34; type Renderer interface{ DrawCircle(x, y, r int) } type Vector struct{} func (Vector) DrawCircle(x, y, r int){ fmt.Printf(\u0026#34;Vector circle @(%d,%d) r=%d\\n\u0026#34;, x, y, r) } type Raster struct{} func (Raster) DrawCircle(x, y, r int){ fmt.Printf(\u0026#34;Raster circle @(%d,%d) r=%d [pixels]\\n\u0026#34;, x, y, r) } type Shape interface{ Draw() } type Circle struct{ R Renderer; X, Y, Radius int } func (c Circle) Draw(){ c.R.DrawCircle(c.X, c.Y, c.Radius) } func main() { c1 := Circle{R: Vector{}, X: 0, Y: 0, Radius: 10} c2 := Circle{R: Raster{}, X: 5, Y: 5, Radius: 20} c1.Draw() c2.Draw() } 總結 # Bridge 的核心：抽象 × 實作分離，兩側以介面橋接、彼此獨立演進，避免類別/型別爆炸。 Go 實作以 interface + composition 最自然；把實作注入抽象層，測試與維護都更容易。 搭配 Abstract Factory 做組裝、Strategy 做細部行為替換，能構成乾淨、可測、可擴充的系統架構。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/bridge-with-go/","section":"All my post","summary":"Bridge with Go","title":"Bridge with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/builder/","section":"Tags","summary":"","title":"Builder","type":"tags"},{"content":"下面用 Builder（建造者模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 易錯點/最佳實務」的完整說明，附上可直接複製的程式範例（含：經典 Director 版、慣用 Fluent Builder、Functional Options 對照、校驗與不可變設計、以及進階：複製/重用 Builder）。\nBuilder 是什麼？何時用？ # 定義（GoF） 將一個複雜物件的建構過程分步驟封裝起來，讓同樣的建構流程可以產出不同的表示（或不同配置），並能避免「望文生義的大型建構子（tele­scoping constructor）」與錯綜可選參數的混亂。\n什麼情境適合：\n物件欄位很多、部分必填、部分可選，還有相依條件（例如：設定 A 開了才能設 B/C）。 建構步驟需要順序或校驗（例如：先載入配置、再建立連線、再注入憑證）。 想要易讀的 Fluent API（鏈式呼叫），並在 Build() 時集中做合法性檢查與預設值填充。 經典角色（對照 Go 寫法） # Product（產品）：要被建好的複雜結構。 Builder（抽象/介面）：定義建構步驟。 Concrete Builder（具體建造者）：實作每一步並持有中間狀態。 Director（選用）：規範「建構次序」的高階流程（可重用）。 在 Go 中，常見兩條路：\nFluent Builder 結構體（最常用）：type XBuilder struct{ ... }，提供 With...() 鏈式方法與 Build() (X, error)。 Functional Options（Go 慣用替代）：NewX(Option...)，用函式組裝設定；語感像 Builder，但更貼近 Go 生態。 範例 1：Fluent Builder（最實用） # 場景：建構一個發送任務 Job，包含必填 Name 與多個可選參數（重試策略、截止時間、標籤、回呼 URL…），並在 Build() 做集中校驗。\npackage job import ( \u0026#34;errors\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;time\u0026#34; ) // 產品 type Job struct { Name string MaxRetry int Deadline time.Time Tags []string Callback *url.URL DebugMode bool } // Builder type Builder struct { name string maxRetry *int deadline *time.Time tags []string callback *url.URL debugMode bool } // 必填參數通常放在 NewBuilder 或專用 With func NewBuilder(name string) *Builder { return \u0026amp;Builder{name: name} } // 鏈式可選參數 func (b *Builder) WithMaxRetry(n int) *Builder { b.maxRetry = \u0026amp;n return b } func (b *Builder) WithDeadline(t time.Time) *Builder { b.deadline = \u0026amp;t return b } func (b *Builder) AddTags(tags ...string) *Builder { b.tags = append(b.tags, tags...) return b } func (b *Builder) WithCallback(raw string) *Builder { u, err := url.Parse(raw) if err == nil { b.callback = u } // 若想在 Build 才集中回報錯，可先存字串、延後解析 return b } func (b *Builder) EnableDebug() *Builder { b.debugMode = true return b } // Build：做預設值、校驗、不可變化（複製切片） func (b *Builder) Build() (*Job, error) { if b.name == \u0026#34;\u0026#34; { return nil, errors.New(\u0026#34;name is required\u0026#34;) } maxRetry := 3 // default if b.maxRetry != nil { if *b.maxRetry \u0026lt; 0 { return nil, errors.New(\u0026#34;maxRetry must be \u0026gt;= 0\u0026#34;) } maxRetry = *b.maxRetry } var deadline time.Time if b.deadline != nil { if b.deadline.Before(time.Now()) { return nil, errors.New(\u0026#34;deadline cannot be in the past\u0026#34;) } deadline = *b.deadline } var tags []string if len(b.tags) \u0026gt; 0 { tags = make([]string, len(b.tags)) copy(tags, b.tags) // 不可變：避免外部再改 builder 的切片影響 product } j := \u0026amp;Job{ Name: b.name, MaxRetry: maxRetry, Deadline: deadline, Tags: tags, Callback: b.callback, DebugMode: b.debugMode, } return j, nil } 使用方式：\nj, err := job.NewBuilder(\u0026#34;send-report\u0026#34;). WithMaxRetry(5). AddTags(\u0026#34;finance\u0026#34;, \u0026#34;monthly\u0026#34;). WithDeadline(time.Now().Add(24 * time.Hour)). WithCallback(\u0026#34;https://example.com/hook\u0026#34;). EnableDebug(). Build() if err != nil { /* handle */ } 重點：\nBuild() 一次做預設值填充、關聯條件與合法性檢查。 對切片/map 做拷貝，保證 Job 不可變（或至少不受外部再改 Builder 影響）。 範例 2：加入 Director（建構流程可重用） # 若不同場景需要固定流程（例如：標準批次任務 vs 即時任務），可用 Director 封裝：\ntype Director struct{} func (Director) StandardDaily(name string) *Builder { d := time.Now().UTC().Truncate(24 * time.Hour).Add(24 * time.Hour) // 明日 00:00 return NewBuilder(name). WithMaxRetry(3). WithDeadline(d). AddTags(\u0026#34;daily\u0026#34;) } func (Director) Realtime(name string) *Builder { return NewBuilder(name). WithMaxRetry(1). AddTags(\u0026#34;realtime\u0026#34;) } 使用：\nd := job.Director{} j1, _ := d.StandardDaily(\u0026#34;billing\u0026#34;).Build() j2, _ := d.Realtime(\u0026#34;push-now\u0026#34;).EnableDebug().Build() 範例 3：Functional Options（Go 常用替代方案） # 比較：Functional Options 語感像 Builder，但不需要顯性 Builder 型別；參數少時更簡潔。\npackage opts import ( \u0026#34;errors\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;time\u0026#34; ) type Client struct { BaseURL *url.URL Timeout time.Duration Retries int Headers map[string]string Debug bool } type Option func(*Client) error func WithTimeout(d time.Duration) Option { return func(c *Client) error { c.Timeout = d; return nil } } func WithRetries(n int) Option { return func(c *Client) error { if n \u0026lt; 0 { return errors.New(\u0026#34;retries \u0026lt; 0\u0026#34;) } c.Retries = n return nil } } func WithHeader(k, v string) Option { return func(c *Client) error { if c.Headers == nil { c.Headers = map[string]string{} } c.Headers[k] = v return nil } } func WithBaseURL(raw string) Option { return func(c *Client) error { u, err := url.Parse(raw) if err != nil { return err } c.BaseURL = u return nil } } func WithDebug() Option { return func(c *Client) error { c.Debug = true; return nil } } func NewClient(opts ...Option) (*Client, error) { c := \u0026amp;Client{ Timeout: 5 * time.Second, Retries: 2, } for _, opt := range opts { if err := opt(c); err != nil { return nil, err } } return c, nil } 使用：\nc, err := opts.NewClient( opts.WithBaseURL(\u0026#34;https://api.example.com\u0026#34;), opts.WithTimeout(10*time.Second), opts.WithHeader(\u0026#34;X-Trace\u0026#34;, \u0026#34;123\u0026#34;), opts.WithDebug(), ) 何時選 Functional Options？\n物件建構不需要分階段流程、只要設定可選參數與校驗。 想要一行 new完成，不留持久的 Builder 狀態。 Go 社群慣用、泛用性高。 何時選 Builder？\n建構過程具多步驟語義（先 A 再 B）、需要導引使用者用正確順序。 Director 可重用一套流程（模板）。 需要多次重用/微調同一個 Builder 以產生多個相似物件（見下）。 範例 4：Builder 重用、複製與「不可變化」策略 # 有時你想「以某個 Builder 當樣板，微調後產生多個物件」。\n// 在 job.Builder 上加一個 Copy()，複製其內部狀態（深拷貝切片） func (b *Builder) Copy() *Builder { nb := *b if b.tags != nil { nb.tags = make([]string, len(b.tags)) copy(nb.tags, b.tags) } // 其他需要深拷貝的欄位也要處理 return \u0026amp;nb } // 使用 base := job.NewBuilder(\u0026#34;daily-report\u0026#34;).WithMaxRetry(3).AddTags(\u0026#34;finance\u0026#34;) jA, _ := base.Copy().WithDeadline(time.Now().Add(12*time.Hour)).Build() jB, _ := base.Copy().WithDeadline(time.Now().Add(36*time.Hour)).AddTags(\u0026#34;urgent\u0026#34;).Build() 注意：\nBuilder 本身不是執行緒安全；不要多 goroutine 共享同一個 Builder 寫入。必要時每個 goroutine 使用 Copy() 取得一份。 校驗與錯誤處理的實務要點 # 把所有合法性檢查集中在 Build()（或 Functional Option 內各自回錯）。 有「相依條件」時（例如 deadline 必須晚於現在、或某模式下必須設置 callback），在 Build() 一次檢查，讓使用者只要看一個錯誤出口。 對可變容器（slice/map）做拷貝，避免外界修改引起資料競態或不可預期變動。 與其他創建型模式比較 # 模式 著力點 適用情境 Factory Method 把「建」與「用」解耦，替換單一產品類型 需要多型建立但建構流程不複雜 Abstract Factory 一次產出一族相關產品 平台/品牌一致的成套替換 Prototype 以複製現有原型得到新物件 初始化昂貴，模板 → 大量微調 Builder 分步驟建構、可讀性與校驗 參數眾多、具順序/相依條件 常見陷阱與最佳實務 # Builder 泄漏可變狀態：切片/map 指到同一底層 → 在 Build() 務必拷貝。 把錯誤分散在各 With...()：可讀性差；通常集中在 Build()（或 Functional Option 回錯）。 過度工程化：參數很少、沒順序要求 → 直接 struct 字面量或 Functional Options 即可。 執行緒安全：Builder 僅作為裝配器，不要在多 goroutine 間共享寫入。 預設值策略：在 Build() 統一補齊；把必填參數放在 NewBuilder(required...)；其餘 With...()。 迷你可跑範例（含測試思維） # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Report struct { Name string Period string Timezone string Emails []string RunAt time.Time } type ReportBuilder struct { name string period string timezone string emails []string runAt *time.Time } func NewReportBuilder(name string) *ReportBuilder { return \u0026amp;ReportBuilder{name: name} } func (b *ReportBuilder) Weekly() *ReportBuilder { b.period = \u0026#34;weekly\u0026#34;; return b } func (b *ReportBuilder) Daily() *ReportBuilder { b.period = \u0026#34;daily\u0026#34;; return b } func (b *ReportBuilder) TZ(tz string) *ReportBuilder { b.timezone = tz; return b } func (b *ReportBuilder) Notify(emails ...string) *ReportBuilder { b.emails = append(b.emails, emails...); return b } func (b *ReportBuilder) RunAt(t time.Time) *ReportBuilder { b.runAt = \u0026amp;t; return b } func (b *ReportBuilder) Build() (*Report, error) { if b.name == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;name required\u0026#34;) } if b.period == \u0026#34;\u0026#34; { b.period = \u0026#34;monthly\u0026#34; } tz := b.timezone if tz == \u0026#34;\u0026#34; { tz = \u0026#34;Asia/Taipei\u0026#34; } var emails []string if len(b.emails) \u0026gt; 0 { emails = make([]string, len(b.emails)) copy(emails, b.emails) } var run time.Time if b.runAt != nil { if b.runAt.Before(time.Now()) { return nil, fmt.Errorf(\u0026#34;runAt in the past\u0026#34;) } run = *b.runAt } return \u0026amp;Report{ Name: b.name, Period: b.period, Timezone: tz, Emails: emails, RunAt: run, }, nil } func main() { r, err := NewReportBuilder(\u0026#34;Finance\u0026#34;). Weekly(). TZ(\u0026#34;Asia/Taipei\u0026#34;). Notify(\u0026#34;ops@example.com\u0026#34;, \u0026#34;cfo@example.com\u0026#34;). RunAt(time.Now().Add(2*time.Hour)). Build() if err != nil { panic(err) } fmt.Printf(\u0026#34;%+v\\n\u0026#34;, r) } 測試要點：\n修改 Builder 內的 emails 之後不應影響已建好的 Report（檢查是否有拷貝）。 演練 Build() 的錯誤分支（缺必填、時間在過去等）。 總結 # Builder 讓複雜建構「可讀、可控、可驗證」，在 Go 以 Fluent Builder 與 Functional Options 最常見。 大原則：必填在建構期、可選用 With...()、Build() 統一校驗/補預設、避免可變容器外洩。 有「固定建構流程」就用 Director；要量產相近配置就提供 Builder.Copy()。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/builder-with-go/","section":"All my post","summary":"Builder with Go","title":"Builder with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/chain-of-responsibility/","section":"Tags","summary":"","title":"Chain of Responsibility","type":"tags"},{"content":"下面用 Chain of Responsibility（責任鏈） 在 Golang 做一份「觀念 → 結構 → Go 風格實作（兩種常見語義）→ HTTP 中介層化身 CoR → 測試/併發/效能 → 與相近模式比較 → 易錯點」的完整解說，附上可直接複製的程式範例。\nChain of Responsibility 是什麼？何時用？ # 定義（GoF） 將請求沿著處理者鏈傳遞，直到有某個處理者處理它為止；或所有處理者都放行/加工之後交給下一個。藉此把「誰來處理」的決策解耦於呼叫端。\n什麼情境適合\n前處理/驗證/權限/速率限制/審計/轉換等一連串步驟，順序可調、可加可減。 多個候選處理者中，「第一個有能力處理」的就結束（典型：錯誤解析、檔案開啟以副檔名選擇 reader）。 想要開放封閉：新增/調整規則而不動高階流程。 角色與 Go 寫法 # Handler（處理者）：對外暴露 Handle(*Request) error 或者 Handle(*Request) (handled bool, err error)。 ConcreteHandlers：各自完成一件事；**組合（composition）**持有 next 指標。 Client：只需把請求交給鏈首。 在 Go，CoR 常以 「middleware」 的函式鏈形式出現（例如 HTTP、中介層），或以物件模式的 next 指標串起來。\n兩種常見語義（選一種即可） # 攔截/放行（middleware 風格）：每個節點可提早終止（例如驗證失敗），否則放行給下一個。回傳 error 即可；成功時呼叫 next. 第一個能處理者（first-handler-wins）：回傳 handled bool；一旦為 true 就停止傳遞。 下面分別示範。\n範例 A（攔截/放行）：驗證 → 權限 → 速率限制 → 執行 # package chain import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // ==== 請求/回應資料 ==== type Request struct { Ctx context.Context User string Role string Body string } type Handler interface { Handle(*Request) error } // ==== 基礎鏈節 ==== type nextFunc func(*Request) error // 通用包裝：把一個函式變成 Handler（方便快速組鏈） type HandlerFunc func(*Request) error func (f HandlerFunc) Handle(r *Request) error { return f(r) } // 把兩個 Handler 串起來，回新 Handler func Chain(head Handler, tail Handler) Handler { if head == nil { return tail } return HandlerFunc(func(r *Request) error { if err := head.Handle(r); err != nil { return err // 提早終止 } if tail != nil { return tail.Handle(r) } return nil }) } // ==== 各節點實作 ==== // 1) 驗證：必須有 User func Validate() Handler { return HandlerFunc(func(r *Request) error { if r.User == \u0026#34;\u0026#34; { return errors.New(\u0026#34;invalid user\u0026#34;) } return nil // 放行 }) } // 2) 權限：只有 ADMIN 可以動作 func Authorize() Handler { return HandlerFunc(func(r *Request) error { if r.Role != \u0026#34;ADMIN\u0026#34; { return errors.New(\u0026#34;forbidden\u0026#34;) } return nil }) } // 3) 速率限制（簡化版：每次 sleep 示意） func RateLimit() Handler { return HandlerFunc(func(r *Request) error { select { case \u0026lt;-time.After(5 * time.Millisecond): return nil case \u0026lt;-r.Ctx.Done(): return r.Ctx.Err() } }) } // 4) 最終執行（業務） func DoBusiness() Handler { return HandlerFunc(func(r *Request) error { fmt.Println(\u0026#34;OK:\u0026#34;, r.User, \u0026#34;=\u0026gt;\u0026#34;, r.Body) return nil }) } // ==== 組裝 ==== // head := Chain(Validate(), Chain(Authorize(), Chain(RateLimit(), DoBusiness()))) 使用：\nreq := \u0026amp;chain.Request{ Ctx: context.Background(), User: \u0026#34;alice\u0026#34;, Role: \u0026#34;ADMIN\u0026#34;, Body: \u0026#34;delete:42\u0026#34;, } h := chain.Chain(chain.Validate(), chain.Chain(chain.Authorize(), chain.Chain(chain.RateLimit(), chain.DoBusiness()))) _ = h.Handle(req) 重點\n任一節點回 error 即終止；否則一路放行到末端。 任務切片化、順序可調、易於測試與擴充。 範例 B（第一個能處理者）：檔案 Loader 以副檔名挑選 # package loader import ( \u0026#34;errors\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; ) // Subject：回傳 handled=true 代表此節點已處理，鏈停止 type Handler interface { Load(path string) (handled bool, content string, err error) } type HandlerFunc func(string) (bool, string, error) func (f HandlerFunc) Load(p string) (bool, string, error) { return f(p) } func Chain(h1, h2 Handler) Handler { if h1 == nil { return h2 } return HandlerFunc(func(p string) (bool, string, error) { ok, c, err := h1.Load(p) if ok || err != nil { return ok, c, err // handled or failed -\u0026gt; stop } if h2 != nil { return h2.Load(p) } return false, \u0026#34;\u0026#34;, nil }) } // 節點：JSON loader func JSONLoader() Handler { return HandlerFunc(func(p string) (bool, string, error) { if strings.EqualFold(filepath.Ext(p), \u0026#34;.json\u0026#34;) { // 省略：真實讀檔/反序列化 return true, `{\u0026#34;ok\u0026#34;:true}`, nil } return false, \u0026#34;\u0026#34;, nil // 我不處理，交給下一個 }) } // 節點：YAML loader func YAMLLoader() Handler { return HandlerFunc(func(p string) (bool, string, error) { if ext := strings.ToLower(filepath.Ext(p)); ext == \u0026#34;.yaml\u0026#34; || ext == \u0026#34;.yml\u0026#34; { return true, \u0026#34;k: v\u0026#34;, nil } return false, \u0026#34;\u0026#34;, nil }) } // 節點：找不到 -\u0026gt; 錯誤 func NotFound() Handler { return HandlerFunc(func(string) (bool, string, error) { return true, \u0026#34;\u0026#34;, errors.New(\u0026#34;unsupported file type\u0026#34;) }) } 使用：\nh := loader.Chain(loader.JSONLoader(), loader.Chain(loader.YAMLLoader(), loader.NotFound())) ok, content, err := h.Load(\u0026#34;config.yaml\u0026#34;) // 命中 YAMLLoader；鏈停止 重點\n節點回 handled=true 代表「我處理了」，停止往下傳。 典型「第一個能處理的人得標」。 範例 C：HTTP Middleware 本質就是 CoR # Go 標準庫 http.Handler 的 middleware 鏈，與 範例 A 一樣是「攔截/放行」語義：\npackage webcor import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) type Middleware func(http.Handler) http.Handler func Logging() Middleware { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ start := time.Now() next.ServeHTTP(w, r) // 放行到下一個或最終 handler log.Printf(\u0026#34;%s %s %s\u0026#34;, r.Method, r.URL.Path, time.Since(start)) }) } } func Recover() Middleware { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ defer func(){ if rec := recover(); rec != nil { http.Error(w, \u0026#34;oops\u0026#34;, 500) } }() next.ServeHTTP(w, r) }) } } func Chain(h http.Handler, mws ...Middleware) http.Handler { for i := len(mws)-1; i \u0026gt;= 0; i-- { h = mws[i](h) } return h } 使用：\nmux := http.NewServeMux() mux.HandleFunc(\u0026#34;/ping\u0026#34;, func(w http.ResponseWriter, _ *http.Request){ w.Write([]byte(\u0026#34;pong\u0026#34;)) }) srv := webcor.Chain(mux, webcor.Logging(), webcor.Recover()) http.ListenAndServe(\u0026#34;:8080\u0026#34;, srv) 測試策略（關鍵） # 單元測試每個節點：以「假的下一節點」觀察是否放行/終止、是否正確改動請求。 順序敏感測試：調換節點順序驗證行為差異（例如先驗證再授權 vs 先授權再驗證）。 錯誤路徑：節點返回 error 是否中止；是否保留 %w 以供 errors.Is/As 判定。 高階整合測試：用少量節點組鏈，覆蓋主要 happy/edge paths。 併發與效能（Go 實戰） # Handler 通常是無狀態（stateless）；若有共享狀態（例如計數器/快取），要用 sync/atomic 或鎖保護。 不可變資料：若節點會修改 Request，考慮只改新欄位或複製需要的切片/map，避免與其他 goroutine 共享時產生競態。 鏈深度：每多一層就多一次呼叫與分派；在高 QPS 場景要控制層數，或將多個小邏輯合併。 建鏈成本：鏈通常在啟動時建好（不可變），請避免每請求重建。 與相近模式比較 # 模式 目的 與 CoR 差異 Decorator 在同介面上疊加行為 形似 middleware，但 Decorator 目的是「擴充」，CoR 強調「傳遞/終止」的流程控制 Interceptor / Middleware 請求-回應管線前後處理 其實是 CoR 的具體形態（多數屬於「攔截/放行」語義） Observer 廣播通知多個觀察者 非「串鏈」而是「一對多」；沒有「第一個處理者停止」 Strategy 可替換演算法 沒有「沿鏈傳遞」；只選一個策略來跑 常見陷阱與最佳實務 # 回傳契約不清楚：到底錯誤會不會停止？有沒有 handled 概念？→ 在介面上約定清楚。 節點之間耦合：節點偷看/修改其他節點的內部狀態 → 請透過明確欄位或 context 傳遞資料。 順序不明：鏈的建立散落在多處，難以看懂 → 提供建鏈函式或集中裝配。 副作用不可逆：在早期節點做了不可回滾副作用（寫 DB）而後續節點失敗 → 將副作用放在靠末端，或在失敗時補償。 共享可變切片/map：請拷貝或以不可變結構傳遞，避免資料競態。 迷你整合（可直接跑）：函式鏈 Builder（攔截/放行） # package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Request struct { Ctx context.Context Auth bool Msg string } type HandlerFunc func(*Request) error func Chain(handlers ...HandlerFunc) HandlerFunc { return func(r *Request) error { for _, h := range handlers { if err := h(r); err != nil { return err // 提早終止 } } return nil } } func Auth() HandlerFunc { return func(r *Request) error { if !r.Auth { return errors.New(\u0026#34;unauthorized\u0026#34;) } return nil } } func Validate() HandlerFunc { return func(r *Request) error { if r.Msg == \u0026#34;\u0026#34; { return errors.New(\u0026#34;empty msg\u0026#34;) } return nil } } func Business() HandlerFunc { return func(r *Request) error { fmt.Println(\u0026#34;do:\u0026#34;, r.Msg) return nil } } func main() { h := Chain(Auth(), Validate(), Business()) _ = h(\u0026amp;Request{Ctx: context.Background(), Auth: true, Msg: \u0026#34;hello\u0026#34;}) } 小結 # Chain of Responsibility 讓「處理步驟」與「誰處理」鬆耦合：你只需把請求丟給鏈首；新增/調整節點不動主流程。 在 Go：以物件 next 指標或函式 middleware 鏈都很自然；兩種語義（攔截/放行 vs 第一個能處理者）依需求擇一。 注意回傳契約、順序、共享狀態與錯誤語義；鏈在啟動時裝配，節點各司其職、可測可換。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/chain-of-responsibility-with-go/","section":"All my post","summary":"Chain of Responsibility with Go","title":"Chain of Responsibility with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/command/","section":"Tags","summary":"","title":"Command","type":"tags"},{"content":"下面用 Command（命令模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作（介面版／函式版）→ Undo/Redo 與巨集命令 → 併發與排程 → 測試與實務要點 → 與相近模式比較」的完整解說，附上可直接複製的程式範例。\nCommand 是什麼？何時用？ # 定義（GoF） 把一個「動作（請求）」封裝成物件，讓你能：\n將請求排隊、排程、序列化，甚至跨程序傳輸； 支援撤銷/重做（Undo/Redo）； 用**巨集命令（Macro）**編排多個動作； 使**呼叫端（Invoker）與實際接收者（Receiver）**解耦。 適用情境\n需要 Undo/Redo 或審計/日誌（每個操作可被記錄與恢復）。 需要排程/佇列/工作者池來執行動作。 UI 熱鍵、工作流程引擎、DevOps 任務、資料修補腳本、交易補償等。 角色與 Go 寫法 # Command：命令介面（Execute()，可選 Undo()）。 ConcreteCommand：封裝參數、持有 Receiver。 Receiver：真正執行工作者（資料庫、檔案系統、網路服務…）。 Invoker：觸發命令；可維護歷史紀錄、排程等。 在 Go 裡可用：\n介面型（傳統）：type Command interface { Execute() error; Undo() error } 函式型（Go 風格）：type Command func(context.Context) error，再用閉包封裝 Receiver 與參數。 範例 A：介面型 Command（含 Undo/Redo） # 1) Receiver：最終執行者 # package editor type Document struct { Content string } func (d *Document) Insert(pos int, s string) { if pos \u0026lt; 0 || pos \u0026gt; len(d.Content) { pos = len(d.Content) } d.Content = d.Content[:pos] + s + d.Content[pos:] } func (d *Document) Delete(pos, n int) string { if pos \u0026lt; 0 || pos \u0026gt;= len(d.Content) || n \u0026lt;= 0 { return \u0026#34;\u0026#34; } if pos+n \u0026gt; len(d.Content) { n = len(d.Content)-pos } removed := d.Content[pos:pos+n] d.Content = d.Content[:pos] + d.Content[pos+n:] return removed } 2) Command 介面 \u0026amp; 具體命令 # package editor type Command interface { Execute() error Undo() error } type InsertText struct { Doc *Document Pos int Txt string } func (c *InsertText) Execute() error { c.Doc.Insert(c.Pos, c.Txt) return nil } func (c *InsertText) Undo() error { // 移除剛剛插入的字串 c.Doc.Delete(c.Pos, len(c.Txt)) return nil } type DeleteText struct { Doc *Document Pos int Length int back string // 為 Undo 儲存被刪內容 } func (c *DeleteText) Execute() error { c.back = c.Doc.Delete(c.Pos, c.Length) return nil } func (c *DeleteText) Undo() error { c.Doc.Insert(c.Pos, c.back) return nil } 3) Invoker：執行與維護歷史（Undo/Redo） # package editor type History struct { undo []Command redo []Command } func (h *History) Do(cmd Command) error { if err := cmd.Execute(); err != nil { return err } h.undo = append(h.undo, cmd) h.redo = h.redo[:0] // 新分支，清掉 redo return nil } func (h *History) Undo() bool { if len(h.undo) == 0 { return false } cmd := h.undo[len(h.undo)-1] h.undo = h.undo[:len(h.undo)-1] _ = cmd.Undo() h.redo = append(h.redo, cmd) return true } func (h *History) Redo() bool { if len(h.redo) == 0 { return false } cmd := h.redo[len(h.redo)-1] h.redo = h.redo[:len(h.redo)-1] _ = cmd.Execute() h.undo = append(h.undo, cmd) return true } 使用\ndoc := \u0026amp;editor.Document{} hist := \u0026amp;editor.History{} _ = hist.Do(\u0026amp;editor.InsertText{Doc: doc, Pos: 0, Txt: \u0026#34;Hello\u0026#34;}) _ = hist.Do(\u0026amp;editor.InsertText{Doc: doc, Pos: 5, Txt: \u0026#34; World\u0026#34;}) // doc.Content == \u0026#34;Hello World\u0026#34; hist.Undo() // -\u0026gt; \u0026#34;Hello\u0026#34; hist.Redo() // -\u0026gt; \u0026#34;Hello World\u0026#34; 重點\n命令自帶狀態（例如 DeleteText.back）以支援 Undo。 Invoker 維護 undo/redo 堆疊，高階流程零耦合。 範例 B：巨集命令（Macro）與交易式執行 # 有時要把多個命令當成一件事：全部成功才算，否則回滾。\npackage editor type Macro struct { cmds []Command } func NewMacro(cmds ...Command) *Macro { return \u0026amp;Macro{cmds: cmds} } func (m *Macro) Execute() error { for i, c := range m.cmds { if err := c.Execute(); err != nil { // 回滾已成功的 for j := i-1; j \u0026gt;= 0; j-- { _ = m.cmds[j].Undo() } return err } } return nil } func (m *Macro) Undo() error { for i := len(m.cmds)-1; i \u0026gt;= 0; i-- { _ = m.cmds[i].Undo() } return nil } 使用：把「插入 + 刪除」當成原子操作。\nm := editor.NewMacro( \u0026amp;editor.InsertText{Doc: doc, Pos: 0, Txt: \u0026#34;A\u0026#34;}, \u0026amp;editor.DeleteText{Doc: doc, Pos: 10, Length: 2}, ) _ = hist.Do(m) 範例 C：函式型 Command（Go 風格）＋ 佇列與工作者 # 當不需要 Undo，只想把「動作」封裝、排隊、重試或超時，函式型更輕巧。\npackage jobs import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;time\u0026#34; ) type Command func(ctx context.Context) error // 簡易工作佇列 type Queue struct { ch chan Command } func NewQueue(buf int) *Queue { return \u0026amp;Queue{ch: make(chan Command, buf)} } func (q *Queue) Enqueue(c Command) { q.ch \u0026lt;- c } func (q *Queue) Close() { close(q.ch) } // 工作者（worker）執行命令 func (q *Queue) StartWorkers(n int) (stop func()) { ctx, cancel := context.WithCancel(context.Background()) for i := 0; i \u0026lt; n; i++ { go func() { for { select { case \u0026lt;-ctx.Done(): return case cmd, ok := \u0026lt;-q.ch: if !ok { return } _ = cmd(context.Background()) } } }() } return cancel } // 輔助：加上超時/重試的 wrapper（decorator 風味） func WithTimeout(d time.Duration, c Command) Command { return func(ctx context.Context) error { ctx2, cancel := context.WithTimeout(ctx, d); defer cancel() return c(ctx2) } } func WithRetry(n int, delay time.Duration, c Command) Command { return func(ctx context.Context) error { var err error for i := 0; i \u0026lt;= n; i++ { if err = c(ctx); err == nil { return nil } select { case \u0026lt;-time.After(delay): case \u0026lt;-ctx.Done(): return ctx.Err() } } return err } } 使用\nq := jobs.NewQueue(64) stop := q.StartWorkers(4) defer stop() sendEmail := func(to string) jobs.Command { return func(ctx context.Context) error { // 寄信（略） if to == \u0026#34;\u0026#34; { return errors.New(\u0026#34;empty to\u0026#34;) } return nil } } q.Enqueue(jobs.WithRetry(3, 200*time.Millisecond, sendEmail(\u0026#34;ops@x.com\u0026#34;))) q.Enqueue(jobs.WithTimeout(1*time.Second, sendEmail(\u0026#34;admin@x.com\u0026#34;))) 亮點\n用閉包封裝參數與接收者；搭配 wrapper 實現重試/超時/指標。 易於放入 channel 佇列，形成工作流。 測試策略與實務要點 # 命令可測：每個 Command 在無副作用版本（或用 fake receiver）下獨立測。 Undo 正確性：測「Execute 之後 Undo，狀態應回到原點」。巨集命令要測局部失敗回滾。 冪等性（idempotency）：在重試或重放時要安全（例如外部 API；可加去重鍵或條件更新）。 序列化：若要持久化或跨程序，可為命令定義名稱 + 引數，用 JSON 編碼，重建時用工廠。 觀測性：在 Invoker 或 Queue 層加度量、追蹤、審計日誌。 併發與排程注意 # Command 物件通常不可重複併發使用（除非你保證其內部無共享可變狀態）。 若需要排程（cron），命令可搭配時間觸發器；如果有依賴關係，可做 DAG（拓撲排序）執行或加「前置命令」。 錯誤邊界：命令失敗要清楚回報；必要時補償命令（Undo 只是同進程的恢復，跨系統可另設 compensating commands）。 與相近模式比較 # 模式 目的 差異 Command 將請求封裝為物件，支援排程、佇列、Undo/Redo、巨集 行為 + 參數 + Receiver 變成一個獨立實體 Strategy 可替換演算法 不關心「一次次動作」的排程/撤銷；無歷史 Chain of Responsibility 由一連串處理者決定處理/放行 不是把「一次動作」封裝；是把處理流程鏈起來 Memento 儲存/恢復狀態 常與 Command 一起做 Undo，但 Memento 只存快照 Mediator / Facade 協調多物件/簡化子系統 不是動作封裝；語義不同 常見陷阱與最佳實務 # 混入過多業務：Command 應專注一件事；複雜流程用 Macro 或工作流。 Undo 不可逆：若無法正確回滾，務必明確標註「不可撤銷」並避免混用於可撤銷隊列。 共享可變狀態：命令在多 goroutine 間重用會有競態；每次提交新實例或加鎖。 序列化困難：使用閉包時，如需持久化，改用顯式結構體 + 註冊型工廠。 過度抽象：簡單函式呼叫就好時，不必為了設計圖而硬套 Command。 迷你整合（可直接跑）：CLI 風格命令 + Undo # package main import ( \u0026#34;fmt\u0026#34; ) // ===== Domain ===== type Counter struct{ n int } func (c *Counter) Inc(d int) { c.n += d } func (c *Counter) Dec(d int) { c.n -= d } // ===== Command ===== type Command interface { Execute() error Undo() error } type IncCmd struct{ C *Counter; D int } func (c IncCmd) Execute() error { c.C.Inc(c.D); return nil } func (c IncCmd) Undo() error { c.C.Dec(c.D); return nil } type DecCmd struct{ C *Counter; D int } func (c DecCmd) Execute() error { c.C.Dec(c.D); return nil } func (c DecCmd) Undo() error { c.C.Inc(c.D); return nil } // ===== Invoker (History) ===== type History struct{ undo, redo []Command } func (h *History) Do(c Command){ _ = c.Execute(); h.undo = append(h.undo, c); h.redo = nil } func (h *History) Undo(){ if n:=len(h.undo); n\u0026gt;0 { c:=h.undo[n-1]; h.undo=h.undo[:n-1]; _=c.Undo(); h.redo=append(h.redo,c) } } func (h *History) Redo(){ if n:=len(h.redo); n\u0026gt;0 { c:=h.redo[n-1]; h.redo=h.redo[:n-1]; _=c.Execute(); h.undo=append(h.undo,c) } } func main() { c := \u0026amp;Counter{} h := \u0026amp;History{} h.Do(IncCmd{C:c,D:5}) h.Do(DecCmd{C:c,D:2}) fmt.Println(c.n) // 3 h.Undo() fmt.Println(c.n) // 5 h.Redo() fmt.Println(c.n) // 3 } 小結 # Command 把「行為 + 參數 + 接收者」打包成第一等公民：好排程、好記錄、可撤銷、可組合。 在 Go：介面型適合需要 Undo/Redo；函式型適合佇列與工作者池。 落地時注意：冪等性、序列化、錯誤與補償、併發安全，以及把命令粒度切得小而清晰。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/command-with-go/","section":"All my post","summary":"Command with Go","title":"Command with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/composite/","section":"Tags","summary":"","title":"Composite","type":"tags"},{"content":"下面用 Composite（合成／組合模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 容錯/併發/測試 → 易錯點」的完整說明，並附上可直接複製的程式範例（檔案系統樹、算術 AST 兩種典型情境）。\nComposite 是什麼？何時用？ # 定義（GoF） 將物件組織成樹狀結構以表現「部分–整體（part–whole）」層級；讓客戶端對單一物件（Leaf）與容器（Composite）具有一致操作介面。\n什麼情境適合\n任何樹狀資料：檔案系統、UI 元件、公司組織、目錄/分類、AST（語法樹）、規則樹。 希望相同 API能同時作用在「節點」與「子樹」（遞迴處理）。 兩種接口風格 # 透明式（Transparent）：在 Component 介面上也放 Add/Remove()。好用但葉節點需擲錯或忽略。 安全式（Safe）（Go 常用）：Component 只包含通用行為；Add/Remove() 只存在於 Composite。 下列示範採 安全式。\n範例一：檔案系統樹（Folder / File） # 目標：Node 介面提供 Name()、Size()、Print(indent)；Folder 可包含多個 Node（遞迴）；File 為葉節點。\npackage fs import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;sync\u0026#34; ) // === Component === type Node interface { Name() string Size() int64 Print(indent int) // for demo } // === Leaf === type File struct { name string size int64 } func NewFile(name string, size int64) *File { return \u0026amp;File{name: name, size: size} } func (f *File) Name() string { return f.name } func (f *File) Size() int64 { return f.size } func (f *File) Print(indent int) { fmt.Printf(\u0026#34;%s- %s (%dB)\\n\u0026#34;, strings.Repeat(\u0026#34; \u0026#34;, indent), f.name, f.size) } // === Composite === type Folder struct { name string children []Node mu sync.RWMutex // 可選：讓增刪查同時更安全 } func NewFolder(name string) *Folder { return \u0026amp;Folder{name: name} } func (d *Folder) Name() string { return d.name } func (d *Folder) Add(nodes ...Node) { d.mu.Lock() defer d.mu.Unlock() d.children = append(d.children, nodes...) } func (d *Folder) RemoveByName(name string) { d.mu.Lock() defer d.mu.Unlock() out := d.children[:0] for _, n := range d.children { if n.Name() != name { out = append(out, n) } } d.children = out } func (d *Folder) Children() []Node { // 回只讀快照，避免外部竄改 d.mu.RLock() defer d.mu.RUnlock() out := make([]Node, len(d.children)) copy(out, d.children) return out } func (d *Folder) Size() int64 { var sum int64 d.mu.RLock() cs := append([]Node(nil), d.children...) // 拿快照避免長鎖 d.mu.RUnlock() for _, c := range cs { sum += c.Size() } return sum } func (d *Folder) Print(indent int) { fmt.Printf(\u0026#34;%s+ %s/\\n\u0026#34;, strings.Repeat(\u0026#34; \u0026#34;, indent), d.name) for _, c := range d.Children() { c.Print(indent + 1) } } 使用\nroot := fs.NewFolder(\u0026#34;root\u0026#34;) img := fs.NewFolder(\u0026#34;images\u0026#34;) doc := fs.NewFolder(\u0026#34;docs\u0026#34;) img.Add(fs.NewFile(\u0026#34;logo.png\u0026#34;, 12_345), fs.NewFile(\u0026#34;hero.jpg\u0026#34;, 98_000)) doc.Add(fs.NewFile(\u0026#34;readme.md\u0026#34;, 2_048)) root.Add(img, doc, fs.NewFile(\u0026#34;LICENSE\u0026#34;, 1_024)) root.Print(0) // + root/ // + images/ // - logo.png (12345B) // - hero.jpg (98000B) // + docs/ // - readme.md (2048B) // - LICENSE (1024B) fmt.Println(\u0026#34;Total:\u0026#34;, root.Size()) // Total: 113417 重點\n客戶端只看 Node，對檔案與資料夾呼叫同一組方法。 Folder.Size() 以遞迴合成子節點大小。 提供 Children() 的防禦式拷貝，避免外部直接改 slice。 常見擴充 # 搜尋（DFS/BFS）、篩選（predicate），都寫成遞迴在 Node 上執行。 訪問者（Visitor）：如果行為越來越多，考慮以 Visitor 將「行為」與「結構」分離（Composite + Visitor 經典組合）。 不可變樹：在多執行緒讀多寫少的情境，可用持久化資料結構（新增回傳新節點），降低鎖使用。 範例二：算術表達式樹（AST） # Composite 的另一個經典：節點代表運算；葉節點代表常數或變數。\npackage ast import \u0026#34;fmt\u0026#34; // === Component === type Expr interface { Eval(env map[string]float64) (float64, error) String() string } // === Leaf === type Const float64 func (c Const) Eval(_ map[string]float64) (float64, error) { return float64(c), nil } func (c Const) String() string { return fmt.Sprintf(\u0026#34;%g\u0026#34;, c) } type Var string func (v Var) Eval(env map[string]float64) (float64, error) { val, ok := env[string(v)] if !ok { return 0, fmt.Errorf(\u0026#34;var %s undefined\u0026#34;, v) } return val, nil } func (v Var) String() string { return string(v) } // === Composite（兩元運算）=== type Add struct{ L, R Expr } func (a Add) Eval(env map[string]float64) (float64, error) { l, err := a.L.Eval(env); if err != nil { return 0, err } r, err := a.R.Eval(env); if err != nil { return 0, err } return l + r, nil } func (a Add) String() string { return fmt.Sprintf(\u0026#34;(%s + %s)\u0026#34;, a.L.String(), a.R.String()) } type Mul struct{ L, R Expr } func (m Mul) Eval(env map[string]float64) (float64, error) { l, err := m.L.Eval(env); if err != nil { return 0, err } r, err := m.R.Eval(env); if err != nil { return 0, err } return l * r, nil } func (m Mul) String() string { return fmt.Sprintf(\u0026#34;(%s * %s)\u0026#34;, m.L.String(), m.R.String()) } 使用\n// 表達式：(x + 3) * (y + 1) expr := ast.Mul{ L: ast.Add{L: ast.Var(\u0026#34;x\u0026#34;), R: ast.Const(3)}, R: ast.Add{L: ast.Var(\u0026#34;y\u0026#34;), R: ast.Const(1)}, } fmt.Println(expr.String()) // ((x + 3) * (y + 1)) v, _ := expr.Eval(map[string]float64{\u0026#34;x\u0026#34;: 2, \u0026#34;y\u0026#34;: 4}) fmt.Println(v) // (2+3)*(4+1) = 25 看點\nExpr 是統一介面；Const/Var 是葉；Add/Mul 是 Composite。 加新運算（Sub/Div/Neg）不影響既有客戶端：開放封閉。 併發與效能要點（Go 實戰） # 讀多寫少：Composite 常是大量讀；可用 快照 + 短鎖（上例 Size() 的做法）。\n不可變樹：新增/刪除時回傳新節點，讀路徑無鎖；代價是額外配置。\n大型樹遍歷：可用迭代器或channel 走訪避免遞迴爆棧：\nfunc Walk(n fs.Node) \u0026lt;-chan fs.Node { ch := make(chan fs.Node, 64) go func() { var dfs func(fs.Node) dfs = func(x fs.Node) { ch \u0026lt;- x if d, ok := x.(*fs.Folder); ok { for _, c := range d.Children() { dfs(c) } } } dfs(n) close(ch) }() return ch } 快取：如果 Size() 很昂貴且結構少變，可在 Folder 內加一層 atomic.Value 快取（變更時失效）。\n測試策略 # 等價性：Size() 對 File、Folder 都能正確工作。 遞迴邊界：空資料夾、深層樹。 修改不影響快照：Children() 回傳複本；外部修改不應影響內部。 並發：在 -race 下跑測試確保無資料競態。 與相近模式比較 # 模式 用途 與 Composite 的差異 Decorator 在不改介面下疊加行為 Composite 在做樹狀結構與遞迴匯總，Decorator 著重「包一層加行為」 Facade 對複雜系統提供簡單外觀 Facade 不是樹；它是門面 API Flyweight 共享細粒度物件以省記憶體 可與 Composite 串用，但目的不同 Visitor 把「操作」從樹結構抽離 常搭配 Composite 處理多種遍歷操作 易錯點與最佳實務 # 把修改 API 放在 Component（透明式）導致葉節點不得不實作無意義方法 → Go 建議用安全式。 外洩可變結構：直接回傳 []Node 供外部修改會破壞封裝 → 回複本或提供封裝操作（Add/Remove）。 遞迴無界：注意循環引用（理論上樹不該有環），必要時在 Add() 防衛。 深樹的堆疊：非常深的樹可改用顯式堆疊或迭代器。 尺寸/聚合語義：明確定義 Composite 的聚合規則（總和/最大/短路），避免曖昧。 小結 # Composite 讓你用同一組方法處理葉與子樹，天然適合所有「部分–整體」結構。 Go 的寫法以小介面 + 組合為主，常採安全式接口；注意不可變/併發/快照細節。 與 Visitor/Iterator 搭配可優雅處理大量操作與遍歷。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/composite-with-go/","section":"All my post","summary":"Composite with Go","title":"Composite with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/decorator/","section":"Tags","summary":"","title":"Decorator","type":"tags"},{"content":"下面用 Decorator（裝飾者模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 測試/效能/併發 → 與相近模式比較」的完整解說，並附上可直接複製的程式範例（服務中介層、io 流、HTTP Middleware、函式型 Decorator）。\nDecorator 是什麼？什麼時候用？ # 定義（GoF） 在不改動原有介面的前提下，動態地為物件加入額外行為。外觀仍是同一個介面，內部以「包一層又一層」的方式堆疊功能。\n適用情境\n想在不動核心實作的前提下，加上重試、快取、限流、紀錄、度量、追蹤等橫切關注點（cross-cutting concerns）。 希望可組合（composable）：今天要「重試+紀錄」，明天改成「限流+快取」。 相較於繼承，Go 偏好以組合與介面實現 Decorator。 基本結構（Go 寫法） # Component（介面）：對外 API。 ConcreteComponent：核心實作。 Decorator：實作同一個介面，內部持有一個 Component，在呼叫前後增添行為。 範例 1：服務層 Decorator（重試 / 紀錄 / 限流 可疊加） # 介面與核心實作 # package svc import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;time\u0026#34; ) type Notifier interface { Send(ctx context.Context, to, msg string) error } type EmailNotifier struct{} func (EmailNotifier) Send(ctx context.Context, to, msg string) error { // 真實寄信（此處簡化） if to == \u0026#34;\u0026#34; { return errors.New(\u0026#34;empty recipient\u0026#34;) } return nil } Decorators # package svc import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/time/rate\u0026#34; ) // --- Logging --- type logDecorator struct{ next Notifier } func WithLogging(n Notifier) Notifier { return \u0026amp;logDecorator{next: n} } func (d *logDecorator) Send(ctx context.Context, to, msg string) error { start := time.Now() err := d.next.Send(ctx, to, msg) log.Printf(\u0026#34;[notify] to=%s dur=%s err=%v\u0026#34;, to, time.Since(start), err) return err } // --- Retry (簡單固定間隔重試) --- type retryDecorator struct { next Notifier retry int delay time.Duration } func WithRetry(n Notifier, count int, delay time.Duration) Notifier { return \u0026amp;retryDecorator{next: n, retry: count, delay: delay} } func (d *retryDecorator) Send(ctx context.Context, to, msg string) error { var err error for i := 0; i \u0026lt;= d.retry; i++ { err = d.next.Send(ctx, to, msg) if err == nil { return nil } select { case \u0026lt;-time.After(d.delay): case \u0026lt;-ctx.Done(): return ctx.Err() } } return err } // --- Rate Limit --- type rateLimitDecorator struct { next Notifier lim *rate.Limiter } func WithRateLimit(n Notifier, perSec int) Notifier { return \u0026amp;rateLimitDecorator{ next: n, lim: rate.NewLimiter(rate.Limit(perSec), perSec), // 簡單令牌桶 } } func (d *rateLimitDecorator) Send(ctx context.Context, to, msg string) error { if err := d.lim.Wait(ctx); err != nil { return err } return d.next.Send(ctx, to, msg) } 組裝與使用（可自由疊加） # base := svc.EmailNotifier{} // 疊：RateLimit → Retry → Logging → 核心 n := svc.WithLogging( svc.WithRetry( svc.WithRateLimit(base, 5), // 每秒 5 次 2, 200*time.Millisecond, ), ) _ = n.Send(context.Background(), \u0026#34;ops@example.com\u0026#34;, \u0026#34;hello\u0026#34;) 重點\n三個 Decorator 都實作相同介面 Notifier，可任意組合順序。 開放封閉（OCP）：新增「快取/追蹤」只加新 Decorator 即可，核心零改動。 範例 2：io 流的 Decorator（標準庫常見） # 標準庫的 io 與 bufio、gzip、tar 等大量運用 Decorator。以下示範計數寫入器：\npackage iodec import \u0026#34;io\u0026#34; // 目標：在不改動下游 Writer 的情況，計數每次寫入的位元組數 type CountingWriter struct { W io.Writer Count int64 } func (c *CountingWriter) Write(p []byte) (int, error) { n, err := c.W.Write(p) c.Count += int64(n) return n, err } 使用\ncw := \u0026amp;iodec.CountingWriter{W: os.Stdout} fmt.Fprintln(cw, \u0026#34;hello\u0026#34;) // 經過計數器再寫到 stdout fmt.Println(\u0026#34;written:\u0026#34;, cw.Count) 類似地，你可以包一層 io.Reader 做節流、校驗、解密等；這正是 Decorator 的「串接式」威力。\n範例 3：HTTP Middleware（函式型 Decorator） # HTTP 中介層就是 Decorator 的函式型風格。以下以 http.Handler 為例：\npackage httpmw import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) type Middleware func(http.Handler) http.Handler func Logging() Middleware { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ start := time.Now() next.ServeHTTP(w, r) log.Printf(\u0026#34;%s %s %s\u0026#34;, r.Method, r.URL.Path, time.Since(start)) }) } } func Chain(h http.Handler, mws ...Middleware) http.Handler { for i := len(mws)-1; i \u0026gt;= 0; i-- { // 後宣告先包 h = mws[i](h) } return h } 使用\nmux := http.NewServeMux() mux.HandleFunc(\u0026#34;/ping\u0026#34;, func(w http.ResponseWriter, r *http.Request){ w.Write([]byte(\u0026#34;pong\u0026#34;)) }) wrapped := httpmw.Chain(mux, httpmw.Logging() /*, Recovery(), RateLimit() ... */) http.ListenAndServe(\u0026#34;:8080\u0026#34;, wrapped) 範例 4：函式型 Decorator（非 HTTP） # 對「單一方法介面」也能用函式型式快速裝飾：\ntype ValidateFunc func(string) bool func WithTrim(next ValidateFunc) ValidateFunc { return func(s string) bool { return next(strings.TrimSpace(s)) } } func WithMinLen(n int, next ValidateFunc) ValidateFunc { return func(s string) bool { return len(s) \u0026gt;= n \u0026amp;\u0026amp; next(s) } } isAlpha := func(s string) bool { return regexp.MustCompile(`^[A-Za-z]+$`).MatchString(s) } vf := WithTrim(WithMinLen(3, isAlpha)) _ = vf(\u0026#34; ABC \u0026#34;) // true 測試策略與併發/效能要點 # 測試\n對每個 Decorator 寫行為測試：在「假的下一層（stub）」上驗證前後條件與副作用。 驗證順序：例如「先限流再重試」與相反順序的差異。 對外觀的介面契約保持不變（輸入/輸出/錯誤語義）。 併發\nDecorator 多數是無狀態（stateless）或只讀狀態 → goroutine-safe。 若有可變狀態（統計計數器、LRU 快取），要加鎖或用 atomic；或改成每請求的局部變數。 效能\n每多一層 Decorator 就多一次函式呼叫與可能的 buffer/轉換；在高 QPS 場景要注意疊太深。 可將熱路徑 Decorator合併為單一層（分支判斷），或用產生器/組態只裝你需要的層。 與 Proxy / Adapter / Middleware 的差異 # 模式 目標 與 Decorator 的差異 Decorator 在不改介面下疊加行為，且可動態/多層組合 行為擴充且可堆疊 Proxy 控制對目標物件的存取（延遲載入、遠端代理、權限） 行為可能不只是附加，重點在替身/門禁 Adapter 轉換介面以相容 不是加行為，而是改簽章/資料形狀 Middleware 一種在請求/回應管線中的 Decorator 風格 實務等同 Decorator（尤其在 HTTP/gRPC） 常見陷阱與最佳實務 # 改壞介面：Decorator 必須實作同一介面；勿偷偷改回傳型別或錯誤語義。 狀態外洩/資料競態：有狀態的 Decorator 要明確併發保護。 順序敏感：重試放在限流前後、記錄在快取前後，結果不同；以組裝程式保障預期順序。 例外處理一致性：若 wrap 錯誤，請用 fmt.Errorf(\u0026quot;...: %w\u0026quot;, err) 保留 errors.Is/As 可判斷性。 過度裝飾：層數太多會難追蹤；給每層明確命名與職責，並在日誌中標記層級。 迷你整合：為「資料存取」加上快取與追蹤 # type Store interface { Get(ctx context.Context, key string) (string, error) } type memStore struct { m map[string]string } func (s memStore) Get(ctx context.Context, k string) (string, error) { v, ok := s.m[k]; if !ok { return \u0026#34;\u0026#34;, errors.New(\u0026#34;not found\u0026#34;) } return v, nil } // Cache Decorator type cacheDec struct { next Store mu sync.RWMutex c map[string]string } func WithCache(next Store) Store { return \u0026amp;cacheDec{next: next, c: map[string]string{}} } func (d *cacheDec) Get(ctx context.Context, k string) (string, error) { d.mu.RLock(); v, ok := d.c[k]; d.mu.RUnlock() if ok { return v, nil } v, err := d.next.Get(ctx, k); if err != nil { return \u0026#34;\u0026#34;, err } d.mu.Lock(); d.c[k] = v; d.mu.Unlock() return v, nil } // Trace Decorator（簡化） type traceDec struct{ next Store } func WithTrace(next Store) Store { return \u0026amp;traceDec{next: next} } func (d *traceDec) Get(ctx context.Context, k string) (string, error) { start := time.Now() v, err := d.next.Get(ctx, k) log.Printf(\u0026#34;GET key=%s dur=%s err=%v\u0026#34;, k, time.Since(start), err) return v, err } // 組裝 s := memStore{m: map[string]string{\u0026#34;a\u0026#34;:\u0026#34;1\u0026#34;}} ds := WithTrace(WithCache(s)) _, _ = ds.Get(context.Background(), \u0026#34;a\u0026#34;) // 第一次走底層，第二次走快取 總結 # Decorator 在 Go 的精髓：同介面、包一層、前後加邏輯、可疊加。 常見場景：服務橫切關注（重試/限流/快取/日誌/度量/追蹤）、io 串流、HTTP middleware。 實務上注意順序、併發安全、錯誤語義與效能；給每層清楚責任邊界，組裝時只裝需要的層。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/decorator-with-go/","section":"All my post","summary":"Decorator with Go","title":"Decorator with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/categories/design-pattern/","section":"Categories","summary":"","title":"Design Pattern","type":"categories"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/facade/","section":"Tags","summary":"","title":"Facade","type":"tags"},{"content":"下面用 Facade（門面模式） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 測試/錯誤處理 → 與相近模式比較」的完整解說，並附上可直接複製的程式範例（訂單結帳門面、輕量 DB 門面、檔案工具門面）。\nFacade 是什麼？何時用？ # 定義（GoF） 對一組複雜的子系統提供單一、簡化且統一的介面。 目的：讓使用者不必理解各模組之間的複雜關係（初始化順序、錯誤處理、回滾、重試…），只要呼叫門面（Facade）即可完成一個高階工作。\n適用情境\n你有多個子系統（支付、庫存、物流、通知…）且有固定流程需要協調。 需要隱藏實作細節，讓外部只看到穩定 API（便於替換供應商或重構內部）。 作為防腐層（Anti-corruption Layer）：擋住第三方 SDK 的多變細節，把語義整齊地呈現給你的領域層。 Facade 不改變子系統介面、不新增功能（那是 Decorator/Proxy 的事），它只負責編排、簡化與隔離。\n結構（Go 寫法） # Facade（門面）：對外提供簡明 API（例如 Checkout()）。 Subsystems（子系統）：原有服務（Payment、Inventory、Shipping…），可為介面+實作。 Client：呼叫 Facade，不直接碰子系統。 範例 1：訂單結帳 Facade（編排多子系統） # 情境：下單流程需依序鎖庫存 → 刷卡 → 建立出貨 → 發送通知；任何一步失敗都要做補償（解鎖庫存、退款…）。\npackage order // order/facade.go import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // ====== 子系統介面（可替換/模擬） ====== type Inventory interface { Reserve(ctx context.Context, sku string, qty int) (reserveID string, err error) Release(ctx context.Context, reserveID string) error Commit(ctx context.Context, reserveID string) error } type Payment interface { Authorize(ctx context.Context, amountCents int, cardToken string) (authID string, err error) Capture(ctx context.Context, authID string) (captureID string, err error) Void(ctx context.Context, authID string) error Refund(ctx context.Context, captureID string) error } type Shipping interface { CreateShipment(ctx context.Context, address string, sku string, qty int) (shipID string, err error) Cancel(ctx context.Context, shipID string) error } type Notifier interface { Send(ctx context.Context, to, msg string) error } // ====== Facade：對外只暴露簡單 API ====== type CheckoutFacade struct { Inv Inventory Pay Payment Ship Shipping Note Notifier } type CheckoutReq struct { SKU string Qty int Amount int // cents CardToken string Address string Email string } type CheckoutRes struct { OrderID string ShipmentID string } func (f *CheckoutFacade) Checkout(ctx context.Context, r CheckoutReq) (_ CheckoutRes, retErr error) { // 追蹤 ID（實務可用 context/otel） orderID := fmt.Sprintf(\u0026#34;ORD-%d\u0026#34;, time.Now().UnixNano()) // 1) Reserve stock reserveID, err := f.Inv.Reserve(ctx, r.SKU, r.Qty) if err != nil { return CheckoutRes{}, fmt.Errorf(\u0026#34;reserve: %w\u0026#34;, err) } defer func() { if retErr != nil { _ = f.Inv.Release(ctx, reserveID) // best effort } }() // 2) Authorize payment authID, err := f.Pay.Authorize(ctx, r.Amount, r.CardToken) if err != nil { return CheckoutRes{}, fmt.Errorf(\u0026#34;authorize: %w\u0026#34;, err) } defer func() { if retErr != nil { _ = f.Pay.Void(ctx, authID) // 若後續失敗 → 取消授權 } }() // 3) Create shipment shipID, err := f.Ship.CreateShipment(ctx, r.Address, r.SKU, r.Qty) if err != nil { return CheckoutRes{}, fmt.Errorf(\u0026#34;ship: %w\u0026#34;, err) } defer func() { if retErr != nil { _ = f.Ship.Cancel(ctx, shipID) } }() // 4) Commit stock \u0026amp; capture payment if err := f.Inv.Commit(ctx, reserveID); err != nil { return CheckoutRes{}, fmt.Errorf(\u0026#34;commit: %w\u0026#34;, err) } capID, err := f.Pay.Capture(ctx, authID) if err != nil { // 若扣款失敗 → 嘗試回滾（補償） _ = f.Ship.Cancel(ctx, shipID) _ = f.Inv.Release(ctx, reserveID) return CheckoutRes{}, fmt.Errorf(\u0026#34;capture: %w\u0026#34;, err) } // 5) Send notification（失敗可不致命，記錄告警） _ = f.Note.Send(ctx, r.Email, \u0026#34;Your order \u0026#34;+orderID+\u0026#34; is on the way!\u0026#34;) // 6) 回傳 _ = capID // 此範例未回傳，但實務可記錄支付資料 return CheckoutRes{OrderID: orderID, ShipmentID: shipID}, nil } 說明重點\n客戶端只呼叫 Checkout()；流程、順序、錯誤與補償由 Facade 承擔。 子系統以介面抽象，便於替換與測試（mock/fake）。 Facade 不發明新功能，只是把子系統編排成高階用例。 （選配）極簡假實作，便於本地跑範例/單元測試\n// order/fakes.go type fakeInv struct{} func (fakeInv) Reserve(ctx context.Context, sku string, qty int) (string, error) { if qty \u0026lt;= 0 { return \u0026#34;\u0026#34;, errors.New(\u0026#34;qty\u0026#34;) } return \u0026#34;RSV-1\u0026#34;, nil } func (fakeInv) Release(context.Context, string) error { return nil } func (fakeInv) Commit(context.Context, string) error { return nil } type fakePay struct{} func (fakePay) Authorize(context.Context, int, string) (string, error) { return \u0026#34;AUTH-1\u0026#34;, nil } func (fakePay) Capture(context.Context, string) (string, error) { return \u0026#34;CAP-1\u0026#34;, nil } func (fakePay) Void(context.Context, string) error { return nil } func (fakePay) Refund(context.Context, string) error { return nil } type fakeShip struct{} func (fakeShip) CreateShipment(context.Context, string, string, int) (string, error) { return \u0026#34;SHP-1\u0026#34;, nil } func (fakeShip) Cancel(context.Context, string) error { return nil } type fakeNote struct{} func (fakeNote) Send(context.Context, string, string) error { return nil } 使用\n// main.go facade := \u0026amp;order.CheckoutFacade{ Inv: order.fakeInv{}, Pay: order.fakePay{}, Ship: order.fakeShip{}, Note: order.fakeNote{}, } res, err := facade.Checkout(context.Background(), order.CheckoutReq{ SKU: \u0026#34;ABC-001\u0026#34;, Qty: 2, Amount: 12900, CardToken: \u0026#34;tok_xxx\u0026#34;, Address: \u0026#34;Taipei\u0026#34;, Email: \u0026#34;user@example.com\u0026#34;, }) fmt.Println(res, err) 範例 2：輕量 DB 門面（常見的「簡化外觀」） # 把 database/sql 常見樣板壓到門面，對外提供乾淨的 CRUD 操作。重點：不隱藏錯誤、不阻止上層用進階 SQL。\npackage dbfx import ( \u0026#34;context\u0026#34; \u0026#34;database/sql\u0026#34; ) type DBFacade struct{ DB *sql.DB } func (f DBFacade) GetUserName(ctx context.Context, id int64) (string, error) { var name string err := f.DB.QueryRowContext(ctx, `SELECT name FROM users WHERE id=?`, id).Scan(\u0026amp;name) return name, err } func (f DBFacade) UpsertUser(ctx context.Context, id int64, name string) error { _, err := f.DB.ExecContext(ctx, ` INSERT INTO users(id, name) VALUES(?, ?) ON CONFLICT(id) DO UPDATE SET name=excluded.name`, id, name) return err } 好處：呼叫端不用每次都寫 Row/Scan/錯誤處理；需要複雜查詢時，仍可直接使用 *sql.DB。\n範例 3：檔案工具門面（聚合多個標準庫步驟） # 把常用的「讀檔 + JSON 反序列化 + 結構校驗」變成一個呼叫：\npackage filekit import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func LoadJSON[T any](path string) (T, error) { var zero T b, err := os.ReadFile(path) // Facade over os+io if err != nil { return zero, err } var v T if err := json.Unmarshal(b, \u0026amp;v); err != nil { return zero, fmt.Errorf(\u0026#34;json: %w\u0026#34;, err) } return v, nil } 說明：這種「工具性 Facade」很常見，能統一錯誤訊息與檢查點。\n測試策略與實務要點 # 子系統用假實作/Mock：讓 Facade 測試聚焦在流程與補償是否正確。 失敗路徑測試：刻意讓支付或物流失敗，檢查是否呼叫 Void/Release/Cancel。 交易邊界：需要原子性時，把 Facade 放在應用層，由它負責交易/補償（資料庫用 TX、外部系統用 Saga/補償）。 可觀測性：在 Facade 入口/出口做日誌、tracing span，統一記錄跨子系統的關鍵欄位（orderID、authID…）。 不要過度神化：Facade 不是「萬能 service」。避免把所有邏輯都塞進去；維持其「協調者」角色。 與相近模式比較（超容易混） # 模式 目標 差異 Facade 對複雜子系統提供簡化外觀與編排流程 不改子系統介面；聚焦「協調」與「封裝複雜性」 Adapter 轉換介面以相容 Adapter 解決「簽章不合」；Facade 解決「太複雜、步驟繁」 Decorator 同介面上疊加行為（如重試/記錄） Facade 對外是一個更高階的 API Mediator 管理多物件間的複雜互動 Mediator 更偏「事件/溝通中樞」；Facade 更偏「服務用例編排」 Proxy 控制存取（遠端、快取、權限） Facade 非「替身」，它是「門口」 常見陷阱與最佳實務 # Facade 變成上帝物件：保持 API 聚焦在明確用例（例如「Checkout」、「Signup」）；避免橫跨太多領域。 吞錯誤/模糊語義：Facade 應傳遞或包裝錯誤（%w），不要吃掉細節。 隱藏過多功能：Facade 是簡化入口，不是要屏蔽所有子系統能力；給進階使用者保留逃生門（直接用子系統介面）。 硬綁實作：子系統請先抽象成介面，讓 Facade 容易替換供應商與做測試。 跨界交易：多系統的一致性要明確：用 Saga（補償流程）、或把外部操作拆成可回滾步驟。 迷你可跑示例（彙整） # package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; // 假設已放入同一專案的 order 套件 ) func main() { facade := \u0026amp;order.CheckoutFacade{ Inv: order.fakeInv{}, Pay: order.fakePay{}, Ship: order.fakeShip{}, Note: order.fakeNote{}, } ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() res, err := facade.Checkout(ctx, order.CheckoutReq{ SKU: \u0026#34;ABC-001\u0026#34;, Qty: 2, Amount: 12900, CardToken: \u0026#34;tok_xxx\u0026#34;, Address: \u0026#34;Taipei\u0026#34;, Email: \u0026#34;user@example.com\u0026#34;, }) fmt.Printf(\u0026#34;res=%+v err=%v\\n\u0026#34;, res, err) } 小結 # Facade = 簡化 + 編排 + 隔離：對外暴露簡單 API，對內協調複雜子系統與補償、錯誤處理與可觀測性。 在 Go：以介面抽象子系統，Facade 專注流程與語義；寫好失敗路徑與補償。 與 Adapter/Decorator/Proxy 不同：Facade 不改介面、不疊加行為；它只是讓客戶更好用。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/facade-with-go/","section":"All my post","summary":"Facade with Go","title":"Facade with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/factory-method/","section":"Tags","summary":"","title":"Factory Method","type":"tags"},{"content":"下面用「Factory Method（工廠方法）」在 Golang 的實作，從概念到不同風格的程式範例，逐步講清楚：什麼時候用、如何用、和簡單工廠／抽象工廠怎麼區分，以及在 Go 語言常見、實用的寫法。\n什麼是 Factory Method？ # 定義（GoF）： 將物件的建立責任延遲到子類別（或由子型別決定），讓同一組高階邏輯可以在不修改既有程式的前提下，替換「要建立哪一個具體產品」。\n關鍵目的：\n把「用產品」與「建產品」解耦。 讓高階流程可重用、可測試、可擴充（開放封閉原則）。 典型結構與角色（以 Go 的方式描述） # Product（產品介面）：對外使用的能力定義（Go 以 interface 表示）。 ConcreteProduct：產品的具體實作。 Creator（建立者）：握有高階流程的方法，流程中呼叫工廠方法來取得 Product。 ConcreteCreator：決定實際回傳哪個 ConcreteProduct 的類型（在 Go 中常以「組合 + 覆寫方法」或「注入工廠函式」來達成）。 在傳統 OOP（如 Java/C++）會用繼承 + 覆寫來定義工廠方法；在 Go 中更常見的是：\n用介面 + 組合（可搭配 Template Method 心智模型）。 或將工廠方法做成函式注入（dependency injection 風格）。 何時該用？ # 同一套流程需支援多種變體（例如不同儲存後端、不同匯出格式、不同訊息通道）。 你想要單元測試時，方便替換掉實際 I/O 依賴。 預期未來會增加新產品，且希望「加功能不改舊程式」。 範例主題：報表匯出器（PDF / CSV） # 我們有一個產出報表的高階流程：GenerateReport()。 不同情境要匯出成 PDF 或 CSV。 高階流程本身不想知道「怎麼建立 PDF/CSV 物件」，只要會用 Exporter 這個介面即可。\n版本 A：傳統工廠方法 +（模板方法心智模型） # package report import ( \u0026#34;encoding/csv\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) // 1) Product 介面 type Exporter interface { Export(records [][]string) error } // 2) Concrete Products type PDFExporter struct { path string } func NewPDFExporter(path string) *PDFExporter { return \u0026amp;PDFExporter{path: path} } func (p *PDFExporter) Export(records [][]string) error { // Demo：寫文字檔假裝 PDF（實務會呼叫 PDF 套件） f, err := os.Create(p.path) if err != nil { return err } defer f.Close() for _, row := range records { fmt.Fprintln(f, \u0026#34;[PDF] \u0026#34;+fmt.Sprint(row)) } return nil } type CSVExporter struct { path string } func NewCSVExporter(path string) *CSVExporter { return \u0026amp;CSVExporter{path: path} } func (c *CSVExporter) Export(records [][]string) error { f, err := os.Create(c.path) if err != nil { return err } defer f.Close() w := csv.NewWriter(f) defer w.Flush() return w.WriteAll(records) } // 3) Creator：高階流程（握有模板 / 流程） type ReportService interface { GenerateReport() error } // base 型別：提供通用邏輯，並呼叫「工廠方法」取回 Exporter type baseReportService struct{} func (b *baseReportService) gatherData() [][]string { return [][]string{ {\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;amount\u0026#34;}, {\u0026#34;1\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;100\u0026#34;}, {\u0026#34;2\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;80\u0026#34;}, } } // 工廠方法（留給具體 Creator 實作） func (b *baseReportService) createExporter() Exporter { panic(\u0026#34;must implement by concrete service\u0026#34;) } // 模板方法：固定流程，當中會用到工廠方法 func (b *baseReportService) GenerateReportImpl() error { data := b.gatherData() exp := b.createExporter() return exp.Export(data) } // 4) Concrete Creators：決定回傳哪個 Exporter type PDFReportService struct { baseReportService path string } func NewPDFReportService(path string) *PDFReportService { return \u0026amp;PDFReportService{path: path} } func (s *PDFReportService) createExporter() Exporter { return NewPDFExporter(s.path) } func (s *PDFReportService) GenerateReport() error { return s.GenerateReportImpl() } type CSVReportService struct { baseReportService path string } func NewCSVReportService(path string) *CSVReportService { return \u0026amp;CSVReportService{path: path} } func (s *CSVReportService) createExporter() Exporter { return NewCSVExporter(s.path) } func (s *CSVReportService) GenerateReport() error { return s.GenerateReportImpl() } 使用方式：\npackage main import \u0026#34;example.com/report\u0026#34; func main() { s1 := report.NewPDFReportService(\u0026#34;out.pdf\u0026#34;) _ = s1.GenerateReport() s2 := report.NewCSVReportService(\u0026#34;out.csv\u0026#34;) _ = s2.GenerateReport() } 重點：\n高階流程 GenerateReportImpl() 不變。 要支援新格式 → 只需新增新的 ConcreteCreator 與 ConcreteProduct，舊流程無須修改。 版本 B：函式注入風格（Go 寫起來更自然） # 很多 Go 專案更傾向透過注入工廠函式，而不是建立一堆型別階層。 好處：更低樣板、更好測試。\npackage report2 // Product type Exporter interface { Export([][]string) error } // 工廠方法以「函式」注入 type ExporterFactory func(path string) Exporter type Service struct { newExporter ExporterFactory path string } func NewService(factory ExporterFactory, path string) *Service { return \u0026amp;Service{newExporter: factory, path: path} } func (s *Service) gatherData() [][]string { return [][]string{ {\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;amount\u0026#34;}, {\u0026#34;1\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;100\u0026#34;}, } } func (s *Service) GenerateReport() error { data := s.gatherData() exp := s.newExporter(s.path) // 工廠方法 return exp.Export(data) } 搭配具體產品：\npackage report2 import ( \u0026#34;encoding/csv\u0026#34; \u0026#34;os\u0026#34; ) type CSVExporter struct{ path string } func NewCSVExporter(path string) Exporter { return \u0026amp;CSVExporter{path: path} } func (c *CSVExporter) Export(records [][]string) error { f, err := os.Create(c.path) if err != nil { return err } defer f.Close() w := csv.NewWriter(f) defer w.Flush() return w.WriteAll(records) } 使用與測試替身：\npackage main import \u0026#34;example.com/report2\u0026#34; func main() { svc := report2.NewService(report2.NewCSVExporter, \u0026#34;out.csv\u0026#34;) _ = svc.GenerateReport() } // 單元測試：用假的 Exporter 取代 I/O type fakeExporter struct { called bool data [][]string } func (f *fakeExporter) Export(d [][]string) error { f.called = true f.data = d return nil } func fakeFactory(_ string) report2.Exporter { return \u0026amp;fakeExporter{} } // 測試中注入 fakeFactory，驗證流程與輸入是否正確 版本 C：登記式（Registry）工廠方法（動態選型） # 當產品型別很多、來源可外掛時可用 registry map。\n注意：若有併發註冊/讀取要加鎖；或在 init() 階段一次註冊完畢。\npackage registry import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type Exporter interface{ Export([][]string) error } type Factory func(path string) Exporter var ( mu sync.RWMutex registry = map[string]Factory{} ) func Register(name string, f Factory) { mu.Lock() defer mu.Unlock() registry[name] = f } func New(name, path string) (Exporter, error) { mu.RLock() f, ok := registry[name] mu.RUnlock() if !ok { return nil, fmt.Errorf(\u0026#34;unknown exporter: %s\u0026#34;, name) } return f(path), nil } 使用：\nexp, err := registry.New(\u0026#34;csv\u0026#34;, \u0026#34;out.csv\u0026#34;) if err != nil { /* handle */ } _ = exp.Export(data) 這讓你能從設定檔、環境變數、使用者輸入來切換產品類型。\n版本 D：搭配 Go 1.18+ 泛型（型別安全工廠） # 當你要建立的不是同一介面、而是同一類型族群（共有共同 constraint）時，可用泛型確保型別安全（較少見於純 Factory Method，但在工具庫常用）。\ntype Builder[T any] func() T type GenFactory[T any] struct { mu sync.RWMutex m map[string]Builder[T] } func NewGenFactory[T any]() *GenFactory[T] { return \u0026amp;GenFactory[T]{m: make(map[string]Builder[T])} } func (f *GenFactory[T]) Register(name string, b Builder[T]) { f.mu.Lock(); defer f.mu.Unlock() f.m[name] = b } func (f *GenFactory[T]) New(name string) (T, bool) { f.mu.RLock(); b, ok := f.m[name]; f.mu.RUnlock() if !ok { var zero T return zero, false } return b(), true } 與其他「工廠系」模式比較 # 模式 核心想做的事 Extend 新產品要改哪裡 常見在 Go 實作 簡單工廠（不是 GoF） 用一個大 switch 決定回傳哪個產品 通常改那個 switch（違反 OCP） 一個 New(type) 函式 工廠方法（本題） 高階流程呼叫「可被覆寫或注入」的建立點 新增 ConcreteCreator / 注入不同 factory，舊流程不變 介面+組合或函式注入 抽象工廠 產一族相關產品（成套搭配） 新增整套工廠實作 回傳多個產品介面（如 NewButton(), NewCheckbox()） 優點 / 缺點 # 優點\n開放封閉：加新產品不改舊流程。 可測試性：以假工廠或假產品取代 I/O。 解耦：使用者只依賴 Product 介面。 缺點\n類型數量上升（A 版結構較多）。 過度工程化：若變體很少，簡單工廠或直接 new 會更簡潔。 常見陷阱與建議（Go 實戰） # 過度模擬 OOP 繼承：Go 沒有繼承，請用介面 + 組合或函式注入。 全域可變 registry：若有併發或熱插拔需求，記得加鎖，或在 main 啟動期註冊完成。 工廠造成隱性依賴：請把工廠當成依賴注入，由上層組裝（組態可控、可測）。 錯誤處理：工廠方法常是 I/O 起點，務必回傳錯誤（不要 panic），方便上層決策。 與簡單工廠的取捨：若變體不會常變、且只在一處建立，簡單工廠更直接。預期會擴充、會測試替身 → 工廠方法更好。 極簡範例（函式注入版，最常用） # type Notifier interface { Send(msg string) error } type NotifierFactory func() Notifier type Service struct { makeNotifier NotifierFactory } func NewService(f NotifierFactory) *Service { return \u0026amp;Service{makeNotifier: f} } func (s *Service) DoWork() error { n := s.makeNotifier() // Factory Method return n.Send(\u0026#34;finished!\u0026#34;) // 使用 Product } 上層以 NewService(NewEmailNotifier) 或 NewService(NewSMSNotifier) 組裝。 測試：NewService(func() Notifier { return \u0026amp;fake{} }) 即可。 小結 # Factory Method 在 Go 世界的精神是：把建立物件的點抽出成可替換的「方法／函式」，讓流程穩定、產品可插拔。\n實作上你可以選：\nA 版：近似傳統寫法（有「模板流程 + 覆寫工廠方法」的感覺）。 B 版：函式注入（Go 最實用、最簡潔）。 C 版：登記式 registry（動態選型、外掛友善）。 D 版：泛型工廠（型別安全、在工具庫更常見）。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/factory-method-with-go/","section":"All my post","summary":"Factory method with Go","title":"Factory method with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/flyweight/","section":"Tags","summary":"","title":"Flyweight","type":"tags"},{"content":"下面用 Flyweight（享元／輕量級） 在 Golang 做一份「觀念 → 結構 → Go 風格實作 → 效能與併發 → 易錯點」的完整解說，並附上可直接複製的程式範例（字型字形 Glyph、地圖地形 Tile、字串 Intern）。\nFlyweight 是什麼？何時用？ # 定義（GoF） 透過共享物件的不可變內在狀態（Intrinsic State），把變動的外在狀態（Extrinsic State）由呼叫端提供，藉此在海量細粒度物件情境下節省記憶體與初始化成本。\n什麼時候使用\n你要建立非常多相似物件（數萬～數百萬），而且它們有可共享且不可變的部分（例如：字型字形、紋理、配色、行為表）。 建立成本或記憶體很大（紋理/模型/字形/模板），重複載入浪費。 身份/座標/當下狀態等「每一個實例不同」的資訊可以由外部傳入而不是存在物件裡。 與 物件池（sync.Pool）不同：Flyweight 是長期共享不可變；物件池是短期重複使用可變。\n核心概念（超重要） # Intrinsic（內在狀態）：可共享且不可變，例如「字形的向量路徑、字型度量、紋理貼圖」。 Extrinsic（外在狀態）：每次使用時不同，由呼叫端提供，例如「座標、顏色、縮放、目前血量」。 Factory：根據鍵（key）緩存並回傳共享實例；相同鍵回同一個指標。 範例一：文字渲染的 Glyph 享元（經典） # 「字形」是共享的（內在狀態），「位置/大小/顏色」是外在狀態。\npackage glyph import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // ===== Flyweight（共享） ===== type Glyph struct { char rune // 內在：字元 path []byte // 內在：向量路徑/點陣（示意，通常很大） metric Metric // 內在：度量 } type Metric struct { Advance int Ascend int Descend int } // 使用時由外部提供外在狀態：x,y,size,color 等 func (g *Glyph) Draw(x, y, size int, color uint32) { // 這裡只示意輸出；實務會呼叫 GPU/2D API fmt.Printf(\u0026#34;draw \u0026#39;%c\u0026#39; @(%d,%d) size=%d color=%06x adv=%d\\n\u0026#34;, g.char, x, y, size, color, g.metric.Advance) } // ===== Flyweight Factory ===== type GlyphFactory struct { mu sync.RWMutex cache map[rune]*Glyph loader func(rune) (*Glyph, error) // 真實載入器（可讀檔/解析字型） } func NewFactory(loader func(rune) (*Glyph, error)) *GlyphFactory { return \u0026amp;GlyphFactory{cache: make(map[rune]*Glyph), loader: loader} } func (f *GlyphFactory) Get(r rune) (*Glyph, error) { f.mu.RLock() if g, ok := f.cache[r]; ok { f.mu.RUnlock() return g, nil } f.mu.RUnlock() // 慢路徑：載入一次，然後放進 cache f.mu.Lock() defer f.mu.Unlock() if g, ok := f.cache[r]; ok { // double-check return g, nil } g, err := f.loader(r) if err != nil { return nil, err } f.cache[r] = g return g, nil } // ===== Demo Loader（示意，假裝昂貴） ===== func mockLoad(r rune) (*Glyph, error) { // 假裝這裡做了昂貴的解析 return \u0026amp;Glyph{ char: r, path: []byte{1, 2, 3}, // 省略 metric: Metric{Advance: 10, Ascend: 8, Descend: 2}, }, nil } 使用\nf := glyph.NewFactory(glyph.mockLoad) text := []rune(\u0026#34;HELLO WORLD\u0026#34;) x := 10 for _, r := range text { g, _ := f.Get(r) // 相同字元共享同一實例 g.Draw(x, 50, 16, 0x333333) // 外在：座標/尺寸/顏色 x += g.metric.Advance } 重點\nGlyph 不保存座標/顏色（外在）；呼叫 Draw 時由外部傳入。 Factory 以 map[rune]*Glyph 緩存，避免重複載入/配置。 範例二：地圖地形 Tile（共享地形，外在位置） # 有 10^6 個方格，但實際地形種類只有幾十個。共享地形資料（名稱、紋理、行為），外在狀態是格子的座標。\npackage tile import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // 內在：種類資料（共享，不可變） type Terrain struct { Name string Speed float32 // 移動速度倍率 Pass bool // 可否通行 TextureID int // 紋理參照（假想） } // Flyweight Factory type TerrainRepo struct { mu sync.RWMutex m map[string]*Terrain } func NewTerrainRepo() *TerrainRepo { return \u0026amp;TerrainRepo{m: map[string]*Terrain{}} } func (r *TerrainRepo) Register(t *Terrain) { // 啟動期註冊 r.mu.Lock(); defer r.mu.Unlock() r.m[t.Name] = t } func (r *TerrainRepo) Get(name string) *Terrain { r.mu.RLock(); defer r.mu.RUnlock() return r.m[name] } // 外在狀態：每格位置 type Cell struct { X, Y int // 外在：座標 T *Terrain // 指向共享 Terrain } func (c Cell) Draw() { fmt.Printf(\u0026#34;(%d,%d) %s tex=%d\\n\u0026#34;, c.X, c.Y, c.T.Name, c.T.TextureID) } 組裝\nrepo := tile.NewTerrainRepo() repo.Register(\u0026amp;tile.Terrain{Name:\u0026#34;grass\u0026#34;, Speed:1.0, Pass:true, TextureID:1}) repo.Register(\u0026amp;tile.Terrain{Name:\u0026#34;water\u0026#34;, Speed:0.5, Pass:false, TextureID:2}) // 建立 1000x1000 地圖，每格僅存指標（8 bytes）到共享 Terrain grid := make([]tile.Cell, 0, 1_000_000) for y := 0; y \u0026lt; 1000; y++ { for x := 0; x \u0026lt; 1000; x++ { name := \u0026#34;grass\u0026#34; if x%10 == 0 { name = \u0026#34;water\u0026#34; } grid = append(grid, tile.Cell{X:x, Y:y, T: repo.Get(name)}) } } grid[0].Draw() 重點\n若把地形資料重複存到每格，記憶體會爆；用指標共享可大幅下降用量。 Cell 僅保存外在狀態（座標）+ 指向共享內在（*Terrain）。 範例三：字串 Intern（去重共享常見字串） # 在解析大量 JSON/CSV 時，重複的字串非常多。用 Intern 把相同內容的字串轉為同一個底層實體，減少重複配置與 GC 壓力（僅適合熱門小字串）。\npackage intern import ( \u0026#34;sync\u0026#34; ) type Interner struct { mu sync.RWMutex m map[string]string // key 與 value 同內容；value 是那個共享實例 } func New() *Interner { return \u0026amp;Interner{m: map[string]string{}} } // Return a shared string with the same content. func (in *Interner) Intern(s string) string { in.mu.RLock() if v, ok := in.m[s]; ok { in.mu.RUnlock() return v } in.mu.RUnlock() in.mu.Lock() // 再查一次避免重複放入 if v, ok := in.m[s]; ok { in.mu.Unlock() return v } in.m[s] = s // 將此內容的字串本身作為共享實體 in.mu.Unlock() return s } 使用（示意）\nit := intern.New() a := it.Intern(\u0026#34;status\u0026#34;) // 之後多次得到的是同一底層字串 b := it.Intern(\u0026#34;status\u0026#34;) _ = (\u0026amp;a == \u0026amp;b) // false（變數位址），但底層資料在實務上會共用同一實體 注意：Go 的字串是不可變的，Intern 化適合熱門小字串；不要對大型、一次性字串做 Intern（無益反害）。\n與其他技巧比較 # 技術 目的 何時用 Flyweight 共享不可變內在狀態，由外部提供外在狀態 大量細粒度物件、重複度高 Cache（快取） 快速重用「計算/載入結果」 可與 Flyweight 合作；Flyweight 更關注實體共享 sync.Pool 降低暫時性配置與 GC 物件可變且可重置，短期借還，不是長期共享 Prototype 透過複製現有物件建立新實例 不一定節省記憶體（仍是多份），偏重建構成本 Singleton 全域唯一 不是「很多個共享同內在」，而是就一個 效能與併發要點（Go 實戰） # 不可變性：享元內在狀態需只讀。若必須改，等於破壞共享假設。 Factory 併發：用 sync.RWMutex 或 sync.Map；高競爭熱點可採 雙重查核（如上）。 鍵設計：鍵必須唯一描述內在狀態（如字元、顏色、貼圖 ID、哈希）。 熱啟動 vs 懶載入：熱門鍵可在啟動先註冊（避免第一個請求卡載入）；其餘懶載。 GC 與壽命：共享實例常為長壽；確保不會無界成長（可輔以 LRU/TTL，如果「享元種類」也很多）。 測量：以 -bench / -memprofile 比較「共享 vs 非共享」的配置數與總位元組。 常見陷阱與最佳實務 # 把外在狀態放進享元 → 失去共享；請在呼叫時傳入外在狀態。 可變共享 → data race / 汙染其他使用者。享元應當不可變。 鍵設計不當 → 同一內在狀態得到多份實例（浪費）；或撞鍵導致語義錯誤。 過度設計：物件量不大或共享比例低時，Flyweight 的複雜度不划算。 與快取界線模糊：Flyweight 著重實體唯一性與不可變共享；Cache 偏結果重用。分清楚職責。 迷你整合示例：Glyph + 工廠 + 單元測試重點 # // 測試：同字元應回同指標；外在狀態不影響共享 f := glyph.NewFactory(glyph.mockLoad) g1, _ := f.Get(\u0026#39;A\u0026#39;) g2, _ := f.Get(\u0026#39;A\u0026#39;) if g1 != g2 { t.Fatal(\u0026#34;not same flyweight instance for \u0026#39;A\u0026#39;\u0026#34;) } // 外在狀態變化：不影響共享 g1.Draw(10,10,12,0x000000) g2.Draw(100,20,24,0xff0000) 小結 # Flyweight 的精髓：把不變的大東西共享（內在），把每次不同的小東西外部化（外在）。 在 Go：用 map + 鎖（或 sync.Map） 建 Factory；確保享元不可變；在呼叫時傳入外在狀態。 適合「海量、重複度高」的場景：字形、圖塊、樣板、配色、規則表、字串 key 等。 先量測，再導入；導入後持續以 pprof/metrics 觀察記憶體改善幅度與長期壽命。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/flyweight-with-go/","section":"All my post","summary":"Flyweight with Go","title":"Flyweight with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/interpreter/","section":"Tags","summary":"","title":"Interpreter","type":"tags"},{"content":" Interpreter 模式（直譯器）—Golang 實作與實戰說明 # 下面用繁體中文深入介紹 Interpreter 行為型模式，並提供可直接執行的 Go 範例（布林規則語言與簡單算術表達式），包含設計思路、AST 建構、擴充方式、效能與何時使用/避免。\n1. 核心概念 # 目的：為一個**特定領域語言（DSL）**定義文法，並用一套資料結構（通常是抽象語法樹 AST）搭配直譯器逐步求值。 關鍵點：\n以物件或節點代表文法中的各種語法構造（終結/非終結符）。 每個節點都實作 Interpret(context) 或 Eval(env) 之類的方法，在共享環境（Context / Environment）中計算結果。 對「可分解且固定」的文法很實用；隨著產業需求擴充規則時，只要新增節點類型即可。 2. 典型結構（Go 介面） # // Expression 是所有節點的共同介面 type Expression interface { Eval(env map[string]any) (any, error) String() string } env/context：直譯時需要的外部資訊（如變數表）。 回傳 any 是為了讓同一套骨架可處理不同型別（bool/int/float），也可用泛型或分開的布林/數值介面。 3. 範例一：布林規則 DSL（AND/OR/NOT/變數） # 3.1 文法（簡化） # Expr := OrExpr OrExpr := AndExpr { \u0026#34;OR\u0026#34; AndExpr } AndExpr:= NotExpr { \u0026#34;AND\u0026#34; NotExpr } NotExpr:= [\u0026#34;NOT\u0026#34;] Primary Primary:= TRUE | FALSE | IDENT | \u0026#34;(\u0026#34; Expr \u0026#34;)\u0026#34; 3.2 實作重點 # 用遞迴下降（recursive descent）parser：好寫、直觀。 AST 節點：BoolLiteral, VarRef, Not, And, Or env：map[string]bool，提供變數值。 3.3 完整可執行程式 # package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;unicode\u0026#34; ) // ====== Lexer ====== type tokenType int const ( tEOF tokenType = iota tIdent tTrue tFalse tAnd tOr tNot tLParen tRParen ) type token struct { typ tokenType lit string } type lexer struct { input []rune pos int } func newLexer(s string) *lexer { return \u0026amp;lexer{input: []rune(s)} } func (l *lexer) next() rune { if l.pos \u0026gt;= len(l.input) { return 0 } ch := l.input[l.pos] l.pos++ return ch } func (l *lexer) peek() rune { if l.pos \u0026gt;= len(l.input) { return 0 } return l.input[l.pos] } func (l *lexer) skipSpaces() { for unicode.IsSpace(l.peek()) { l.next() } } func (l *lexer) readIdent() string { start := l.pos - 1 for unicode.IsLetter(l.peek()) || unicode.IsDigit(l.peek()) || l.peek() == \u0026#39;_\u0026#39; { l.next() } return string(l.input[start:l.pos]) } func (l *lexer) scan() []token { var toks []token for { l.skipSpaces() ch := l.peek() if ch == 0 { toks = append(toks, token{typ: tEOF}) break } switch ch { case \u0026#39;(\u0026#39;: l.next() toks = append(toks, token{typ: tLParen, lit: \u0026#34;(\u0026#34;}) case \u0026#39;)\u0026#39;: l.next() toks = append(toks, token{typ: tRParen, lit: \u0026#34;)\u0026#34;}) default: if unicode.IsLetter(ch) { l.next() id := strings.ToUpper(l.readIdent()) switch id { case \u0026#34;TRUE\u0026#34;: toks = append(toks, token{typ: tTrue, lit: \u0026#34;TRUE\u0026#34;}) case \u0026#34;FALSE\u0026#34;: toks = append(toks, token{typ: tFalse, lit: \u0026#34;FALSE\u0026#34;}) case \u0026#34;AND\u0026#34;: toks = append(toks, token{typ: tAnd, lit: \u0026#34;AND\u0026#34;}) case \u0026#34;OR\u0026#34;: toks = append(toks, token{typ: tOr, lit: \u0026#34;OR\u0026#34;}) case \u0026#34;NOT\u0026#34;: toks = append(toks, token{typ: tNot, lit: \u0026#34;NOT\u0026#34;}) default: toks = append(toks, token{typ: tIdent, lit: id}) } } else { panic(fmt.Sprintf(\u0026#34;非法字元: %q\u0026#34;, ch)) } } } return toks } // ====== AST \u0026amp; Interpreter ====== type BoolExpr interface { EvalBool(env map[string]bool) (bool, error) String() string } type BoolLiteral struct{ Val bool } func (b BoolLiteral) EvalBool(_ map[string]bool) (bool, error) { return b.Val, nil } func (b BoolLiteral) String() string { return fmt.Sprintf(\u0026#34;%v\u0026#34;, b.Val) } type VarRef struct{ Name string } func (v VarRef) EvalBool(env map[string]bool) (bool, error) { val, ok := env[v.Name] if !ok { return false, fmt.Errorf(\u0026#34;變數 %q 未定義\u0026#34;, v.Name) } return val, nil } func (v VarRef) String() string { return v.Name } type Not struct{ X BoolExpr } func (n Not) EvalBool(env map[string]bool) (bool, error) { x, err := n.X.EvalBool(env) if err != nil { return false, err } return !x, nil } func (n Not) String() string { return \u0026#34;NOT(\u0026#34; + n.X.String() + \u0026#34;)\u0026#34; } type And struct{ L, R BoolExpr } func (a And) EvalBool(env map[string]bool) (bool, error) { lv, err := a.L.EvalBool(env) if err != nil { return false, err } if !lv { return false, nil // 短路 } rv, err := a.R.EvalBool(env) if err != nil { return false, err } return lv \u0026amp;\u0026amp; rv, nil } func (a And) String() string { return \u0026#34;(\u0026#34; + a.L.String() + \u0026#34; AND \u0026#34; + a.R.String() + \u0026#34;)\u0026#34; } type Or struct{ L, R BoolExpr } func (o Or) EvalBool(env map[string]bool) (bool, error) { lv, err := o.L.EvalBool(env) if err != nil { return false, err } if lv { return true, nil // 短路 } rv, err := o.R.EvalBool(env) if err != nil { return false, err } return lv || rv, nil } func (o Or) String() string { return \u0026#34;(\u0026#34; + o.L.String() + \u0026#34; OR \u0026#34; + o.R.String() + \u0026#34;)\u0026#34; } // ====== Parser (recursive descent) ====== type parser struct { toks []token pos int } func newParser(toks []token) *parser { return \u0026amp;parser{toks: toks} } func (p *parser) peek() token { if p.pos \u0026gt;= len(p.toks) { return token{typ: tEOF} } return p.toks[p.pos] } func (p *parser) next() token { t := p.peek() p.pos++ return t } func (p *parser) expect(tt tokenType) (token, error) { t := p.next() if t.typ != tt { return token{}, fmt.Errorf(\u0026#34;語法錯誤，預期 %v 得到 %v\u0026#34;, tt, t.typ) } return t, nil } func (p *parser) parseExpr() (BoolExpr, error) { return p.parseOr() } func (p *parser) parseOr() (BoolExpr, error) { left, err := p.parseAnd() if err != nil { return nil, err } for p.peek().typ == tOr { p.next() right, err := p.parseAnd() if err != nil { return nil, err } left = Or{L: left, R: right} } return left, nil } func (p *parser) parseAnd() (BoolExpr, error) { left, err := p.parseNot() if err != nil { return nil, err } for p.peek().typ == tAnd { p.next() right, err := p.parseNot() if err != nil { return nil, err } left = And{L: left, R: right} } return left, nil } func (p *parser) parseNot() (BoolExpr, error) { if p.peek().typ == tNot { p.next() x, err := p.parsePrimary() if err != nil { return nil, err } return Not{X: x}, nil } return p.parsePrimary() } func (p *parser) parsePrimary() (BoolExpr, error) { switch p.peek().typ { case tTrue: p.next() return BoolLiteral{Val: true}, nil case tFalse: p.next() return BoolLiteral{Val: false}, nil case tIdent: t := p.next() return VarRef{Name: t.lit}, nil case tLParen: p.next() e, err := p.parseExpr() if err != nil { return nil, err } if _, err := p.expect(tRParen); err != nil { return nil, err } return e, nil default: return nil, errors.New(\u0026#34;預期 Primary，卻遇到其他記號\u0026#34;) } } // ====== Demo ====== func main() { input := \u0026#34;NOT (A AND TRUE) OR (B AND (NOT C))\u0026#34; lex := newLexer(input) toks := lex.scan() // fmt.Println(toks) // debug p := newParser(toks) ast, err := p.parseExpr() if err != nil { panic(err) } fmt.Println(\u0026#34;AST:\u0026#34;, ast.String()) env := map[string]bool{ \u0026#34;A\u0026#34;: true, \u0026#34;B\u0026#34;: true, \u0026#34;C\u0026#34;: false, } val, err := ast.EvalBool(env) if err != nil { panic(err) } fmt.Printf(\u0026#34;Env=%v\\n\u0026#34;, env) fmt.Printf(\u0026#34;Expr=%q =\u0026gt; %v\\n\u0026#34;, input, val) } 輸出示例（可能略有不同）：\nAST: ((NOT(A AND true)) OR (B AND NOT(C))) Env=map[A:true B:true C:false] Expr=\u0026#34;NOT (A AND TRUE) OR (B AND (NOT C))\u0026#34; =\u0026gt; true 3.4 擴充：加入 XOR # 只要新增節點與解析規則（通常優先級與 OR 同層或介於 AND/OR 之間）：\ntype Xor struct{ L, R BoolExpr } func (x Xor) EvalBool(env map[string]bool) (bool, error) { lv, err := x.L.EvalBool(env); if err != nil { return false, err } rv, err := x.R.EvalBool(env); if err != nil { return false, err } return lv != rv, nil } 接著在 parser 的某一層循環把 tXor 納入即可。\n4. 範例二：簡單算術直譯器（加減乘除、括號、變數） # 4.1 文法（常見） # Expr := Term { (\u0026#34;+\u0026#34; | \u0026#34;-\u0026#34;) Term } Term := Factor { (\u0026#34;*\u0026#34; | \u0026#34;/\u0026#34;) Factor } Factor := NUMBER | IDENT | \u0026#34;(\u0026#34; Expr \u0026#34;)\u0026#34; 4.2 精簡實作（重點片段） # // 節點 type NumLit struct{ V float64 } func (n NumLit) EvalNum(env map[string]float64) (float64, error) { return n.V, nil } type NumVar struct{ Name string } func (v NumVar) EvalNum(env map[string]float64) (float64, error) { val, ok := env[v.Name] if !ok { return 0, fmt.Errorf(\u0026#34;未定義變數 %q\u0026#34;, v.Name) } return val, nil } type BinOp struct { Op string // \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;/\u0026#34; L, R NumExpr } func (b BinOp) EvalNum(env map[string]float64) (float64, error) { lv, err := b.L.EvalNum(env); if err != nil { return 0, err } rv, err := b.R.EvalNum(env); if err != nil { return 0, err } switch b.Op { case \u0026#34;+\u0026#34;: return lv + rv, nil case \u0026#34;-\u0026#34;: return lv - rv, nil case \u0026#34;*\u0026#34;: return lv * rv, nil case \u0026#34;/\u0026#34;: if rv == 0 { return 0, errors.New(\u0026#34;除以零\u0026#34;) } return lv / rv, nil default: return 0, fmt.Errorf(\u0026#34;未知運算子 %q\u0026#34;, b.Op) } } type NumExpr interface { EvalNum(env map[string]float64) (float64, error) } 解析器與 Lexer 可複用上一個範例，改成支援數字與 + - * /，此處略。\n5. 與其它模式的對照 # Visitor：也可走 AST，但訪問行為與資料結構分離，便於新增「操作」。Interpreter 更偏向「節點自己解釋自己」。 Composite：AST 的樹狀結構常可視為 Composite；Interpreter 是在此結構上提供 Eval。 Strategy：不同求值策略（例如短路 vs 非短路、懶求值）可以用 Strategy 注入到 Interpreter 內。 6. 何時使用 / 避免 # 適合：\n有固定且相對簡單的文法；需要可讀的規則或查詢（微型 DSL）。 規則變動與擴充頻繁；希望以程式碼新增節點類別即可擴充功能。 避免：\n文法龐大/複雜（SQL 級別、完整程式語言）。→ 考慮採用既有 parser 工具（如 ANTLR、PEG）或編譯器框架。 評估效能極端敏感（海量重複求值且 AST 極大）。→ 事前編譯/最佳化或產生位元碼較好。 7. 效能與工程化建議 # 字串 interning/變數查表：將 env 換成 map[int]bool，用符號表把識別字映到整數 ID，提高查詢速度。\n常數摺疊（Constant Folding）、死節點刪除：建 AST 後做一次優化，減少執行期成本。\nMemoization：對純函式節點可快取結果（若 env 不變）。\n安全性：限制可用運算子/函式，避免注入風險；或在規則上做白名單檢查。\n測試策略：\nTable-driven 測試（Go 慣用） 巡迴確認優先級（AND 優於 OR、乘除優於加減） 錯誤案例（未定義變數、括號不匹配、除以零） 8. Table-driven 測試（布林直譯器示意） # func Example_booleanInterpreter() { cases := []struct { input string env map[string]bool want bool }{ {\u0026#34;TRUE AND FALSE\u0026#34;, nil, false}, {\u0026#34;A OR B\u0026#34;, map[string]bool{\u0026#34;A\u0026#34;: false, \u0026#34;B\u0026#34;: true}, true}, {\u0026#34;NOT (A AND TRUE) OR (B AND (NOT C))\u0026#34;, map[string]bool{\u0026#34;A\u0026#34;: true, \u0026#34;B\u0026#34;: true, \u0026#34;C\u0026#34;: false}, true}, } for _, tc := range cases { ast, _ := newParser(newLexer(tc.input).scan()).parseExpr() got, _ := ast.EvalBool(tc.env) fmt.Printf(\u0026#34;%q =\u0026gt; %v\\n\u0026#34;, tc.input, got) } // Output: // \u0026#34;TRUE AND FALSE\u0026#34; =\u0026gt; false // \u0026#34;A OR B\u0026#34; =\u0026gt; true // \u0026#34;NOT (A AND TRUE) OR (B AND (NOT C))\u0026#34; =\u0026gt; true } 9. 與實務場景結合 # 權限/策略判斷：例如「使用者部門=Sales AND (等級 ≥3 OR 擁有特殊標記)」。 行銷規則：滿額、地區、時段、會員等級的布林組合。 告警規則：指標超標條件的組合邏輯。 工作流程條件：狀態機轉移的守衛條件（guard conditions）。 10. 小結 # Interpreter 模式提供一條把「規則/語法」當作一級公民的實作路徑：\n以 AST 結構化語句 → 各節點負責解釋 → 易於擴充、測試與維護。 文法簡潔時非常合適；文法成長後，建議轉向生成式解析器或編譯/最佳化架構以維持效能與健壯性。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/interpreter-with-go/","section":"All my post","summary":"Interpreter with Go","title":"Interpreter with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/iterator/","section":"Tags","summary":"","title":"Iterator","type":"tags"},{"content":" Iterator（迭代器）模式（Behavioral Pattern） # Iterator 用來在不暴露集合內部結構的前提下，提供一個逐一存取聚合物件元素的方式。它把「走訪邏輯」從集合本身抽離，讓「遍歷」與「資料結構」解耦，方便替換不同的走訪策略（例如由前到後、由後到前、跳步、樹的前序/中序/後序等）。\n什麼時候用？ # 你不想讓使用者看到集合的內部表示（slice/map/tree…），但希望提供走訪能力。 你想支援多種遍歷策略，且彼此可以替換。 需要統一 API 走訪不同集合型別。 需要延遲（lazy）生成元素、避免一次性載入全部資料。 需要跨界限走訪（例如分頁 API、資料庫 rows），每次只取下一筆。 角色與結構 # Iterator：定義走訪介面（Next() 取得下一項、Value() 取得目前值、可選 Err()/Close()）。 Concrete Iterator：針對特定集合的實作。 Aggregate（可選）：集合本身，提供建立 Iterator 的方法（Iterator()）。 Client：使用 Iterator 來逐項讀取資料。 在 Go 中，標準庫常見的迭代風格有：\nbufio.Scanner：Scan()/Text()/Err() database/sql.Rows：Next()/Scan()/Err()/Close() io.Reader：雖不是 Iterator 介面，但有相同的「逐批取資料」精神（pull-based） Go 語言的設計取捨 # Go 已有 for range 對 slice/map/channel 很便利；只有在不想暴露內部結構或需要 lazy/策略化遍歷時，才值得自訂 Iterator。 Idiomatic Go 偏好簡單明確的介面，像 Next()/Value()/Err()/Close()，或乾脆用 channel 輸出（push-based）。 隨著 Go1.18+ 有 泛型，可以定義 Iterator[T] 更型別安全。 範例 1：最小可用 External Iterator（泛型） # package iterator // Iterator 是外部迭代器：呼叫端主動拉取（pull）下一個元素 type Iterator[T any] interface { Next() bool // 移動到下一個元素，回傳是否有值 Value() T // 取得當前元素值（只在 Next() 回傳 true 後呼叫） Err() error // 走訪過程中的錯誤（若有） Reset() // 可選：重置迭代器 } // 一個簡單的 slice 迭代器 type sliceIter[T any] struct { data []T i int } func (it *sliceIter[T]) Next() bool { if it.i \u0026gt;= len(it.data) { return false } it.i++ return true } func (it *sliceIter[T]) Value() T { return it.data[it.i-1] } func (it *sliceIter[T]) Err() error { return nil } func (it *sliceIter[T]) Reset() { it.i = 0 } // 建立函式 func FromSlice[T any](s []T) Iterator[T] { return \u0026amp;sliceIter[T]{data: s} } 使用方式：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;iterdemo/iterator\u0026#34; ) func main() { it := iterator.FromSlice([]int{10, 20, 30}) for it.Next() { fmt.Println(it.Value()) } if err := it.Err(); err != nil { fmt.Println(\u0026#34;iterate error:\u0026#34;, err) } } 優點\n不暴露底層結構（即使內部不是 slice 也可替換）。 可插拔不同遍歷策略。 範例 2：Aggregate + 多種策略（正向/逆向/步進） # package playlist type Song struct { Title string Artist string } type Iterable interface { IteratorForward() Iterator[*Song] IteratorBackward() Iterator[*Song] IteratorStep(step int) Iterator[*Song] } type Iterator[T any] interface { Next() bool Value() T Err() error } type Playlist struct { items []*Song } func NewPlaylist(items ...*Song) *Playlist { return \u0026amp;Playlist{items: items} } func (p *Playlist) IteratorForward() Iterator[*Song] { return \u0026amp;forward{p.items, -1} } func (p *Playlist) IteratorBackward() Iterator[*Song] { return \u0026amp;backward{p.items, len(p.items)} } func (p *Playlist) IteratorStep(step int) Iterator[*Song] { if step \u0026lt;= 0 { step = 1 } return \u0026amp;stepper{p.items, -step, step} } type forward struct{ data []*Song; i int } func (f *forward) Next() bool { f.i++; return f.i \u0026lt; len(f.data) } func (f *forward) Value() *Song { return f.data[f.i] } func (f *forward) Err() error { return nil } type backward struct{ data []*Song; i int } func (b *backward) Next() bool { b.i--; return b.i \u0026gt;= 0 } func (b *backward) Value() *Song { return b.data[b.i] } func (b *backward) Err() error { return nil } type stepper struct{ data []*Song; i, step int } func (s *stepper) Next() bool { s.i += s.step; return s.i \u0026lt; len(s.data) } func (s *stepper) Value() *Song { return s.data[s.i] } func (s *stepper) Err() error { return nil } 使用：\npl := playlist.NewPlaylist( \u0026amp;playlist.Song{\u0026#34;I Will Survive\u0026#34;, \u0026#34;Gloria Gaynor\u0026#34;}, \u0026amp;playlist.Song{\u0026#34;Africa\u0026#34;, \u0026#34;Toto\u0026#34;}, \u0026amp;playlist.Song{\u0026#34;Billie Jean\u0026#34;, \u0026#34;Michael Jackson\u0026#34;}, ) it := pl.IteratorBackward() for it.Next() { s := it.Value() fmt.Printf(\u0026#34;%s - %s\\n\u0026#34;, s.Artist, s.Title) } 範例 3：樹結構的走訪（中序 Iterator） # package btree type Node[T any] struct { Val T Left *Node[T] Right *Node[T] } type Iterator[T any] interface { Next() bool Value() T Err() error } type inorder[T any] struct { stack []*Node[T] cur *Node[T] val T } func InorderIterator[T any](root *Node[T]) Iterator[T] { return \u0026amp;inorder[T]{cur: root} } func (it *inorder[T]) pushLeft(n *Node[T]) { for n != nil { it.stack = append(it.stack, n) n = n.Left } } func (it *inorder[T]) Next() bool { if it.cur != nil { it.pushLeft(it.cur) it.cur = nil } if len(it.stack) == 0 { var zero T it.val = zero return false } n := it.stack[len(it.stack)-1] it.stack = it.stack[:len(it.stack)-1] it.val = n.Val if n.Right != nil { it.pushLeft(n.Right) } return true } func (it *inorder[T]) Value() T { return it.val } func (it *inorder[T]) Err() error { return nil } 使用：\nroot := \u0026amp;btree.Node[int]{Val: 2, Left: \u0026amp;btree.Node[int]{Val: 1}, Right: \u0026amp;btree.Node[int]{Val: 3}, } it := btree.InorderIterator(root) for it.Next() { fmt.Println(it.Value()) // 1, 2, 3 } 範例 4：Internal Iterator（回呼）與 Channel 版 # Internal Iterator（push，callback）\nfunc ForEach[T any](it Iterator[T], fn func(T) bool) error { for it.Next() { if ok := fn(it.Value()); !ok { break // 允許中途停止 } } return it.Err() } Channel 生成（push with goroutine）\nfunc ToChan[T any](it Iterator[T]) \u0026lt;-chan T { ch := make(chan T) go func() { defer close(ch) for it.Next() { ch \u0026lt;- it.Value() } // 可視需要處理 it.Err() }() return ch } // 使用 for v := range ToChan(iterator.FromSlice([]int{1,2,3})) { fmt.Println(v) } 內部迭代器與 channel 適合非同步資料來源、背壓或需要與 select/context 整合的情境。\n範例 5：功能性組合（Map/Filter/Take） # 用高階函式包裝，讓迭代可串接轉換，保持 lazy：\ntype FuncIter[T any] struct { next func() (T, bool, error) // 回傳 (值, 是否有值, 錯誤) } func FromSliceF[T any](s []T) *FuncIter[T] { i := 0 return \u0026amp;FuncIter[T]{ next: func() (T, bool, error) { if i \u0026gt;= len(s) { var z T; return z, false, nil } v := s[i]; i++ return v, true, nil }, } } func (fi *FuncIter[T]) Next() (T, bool, error) { return fi.next() } func Map[A, B any](src *FuncIter[A], f func(A) B) *FuncIter[B] { return \u0026amp;FuncIter[B]{next: func() (B, bool, error) { a, ok, err := src.Next() if !ok || err != nil { var z B; return z, ok, err } return f(a), true, nil }} } func Filter[T any](src *FuncIter[T], pred func(T) bool) *FuncIter[T] { return \u0026amp;FuncIter[T]{next: func() (T, bool, error) { for { v, ok, err := src.Next() if !ok || err != nil { return v, ok, err } if pred(v) { return v, true, nil } } }} } func Take[T any](src *FuncIter[T], n int) *FuncIter[T] { i := 0 return \u0026amp;FuncIter[T]{next: func() (T, bool, error) { if i \u0026gt;= n { var z T; return z, false, nil } v, ok, err := src.Next(); if !ok || err != nil { return v, ok, err } i++ return v, true, nil }} } // 使用 nums := FromSliceF([]int{1,2,3,4,5}) res := Take(Filter(Map(nums, func(x int) int { return x*x }), func(x int) bool { return x%2==0 }), 2) for { v, ok, err := res.Next(); if !ok || err != nil { break } fmt.Println(v) // 4, 16 } 外部 vs 內部迭代器（與 Go 風格對照） # 外部（pull-based）：for it.Next() { v := it.Value() }\n優點：呼叫端掌握節奏與中斷時機；易與錯誤處理整合（如 Err()）。 標準例：sql.Rows、bufio.Scanner 內部（push-based）：ForEach(it, fn) 或 channel\n優點：簡潔，可自然與 goroutine/select 合作；適合資料來源主動推送。 缺點：錯誤傳遞與中途控制需額外設計（回傳 bool、context 取消等）。 併發、安全與取消 # 若底層集合會被其他 goroutine 修改，Iterator 需：\n複製快照（成本較高），或 加鎖保護（可能降低吞吐），或 文件化為非併發安全，交由呼叫端保證。 與 context 整合：\nfunc ToChanCtx[T any](ctx context.Context, it Iterator[T]) \u0026lt;-chan T { ch := make(chan T) go func() { defer close(ch) for it.Next() { select { case \u0026lt;-ctx.Done(): return case ch \u0026lt;- it.Value(): } } }() return ch } Fail-fast：若偵測到底層被修改，可立即回錯（需要版本號/修改計數器）。\n實務建議（Idiomatic Go） # 先問自己是否需要 Iterator：若只包裝 []T 且不需隱藏結構，直接 for range。 當資料來源是串流/分頁或需要策略化遍歷，Iterator 很合適（例如 API 分頁、樹走訪、搜尋結果）。 介面保持小而穩（Next/Value/Err[/Close/Reset]）；或仿 Scanner：Scan() + Text()/Bytes()/Err()。 需要跨邊界資源（DB、網路）時，記得提供 Close()。 若要與函式式操作（Map/Filter）配合，考慮使用泛型 + lazy 設計，避免中間切片拷貝。 與其他語言/框架對比 # Java 的 Iterator 與 Iterable 是語言級常見介面；C# 有 IEnumerable\u0026lt;T\u0026gt;/yield。 Go 沒有語法糖（像 yield），但可用 channel 或函式閉包模擬 lazy 產生器，或用泛型實作型別安全的迭代鏈。 總結 # Iterator 模式在 Go 裡最常見的落地型態，就是「外部迭代器（Next/Value/Err）」與「channel 推送」兩條路。 當你需要封裝集合細節、延遲生成、可替換策略、或串流式處理時，Iterator 能讓介面更乾淨、模組化也更靈活。 結合泛型與高階函式，可以自然地構成可組合的資料管線（Map/Filter/Take），同時保有 Go 的效能與簡潔風格。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/iterator-with-go/","section":"All my post","summary":"Iterator with Go","title":"Iterator with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/mediator/","section":"Tags","summary":"","title":"Mediator","type":"tags"},{"content":"下面用「易懂 → 深入 → 實作 → 延伸」的順序，把行為型模式中的 Mediator（仲介者／調停者） 徹底講清楚，並用 Golang 實作多個範例（含逐步重構、執行輸出與進階話題：並發、耦合度、與 Observer/EventBus 的比較）。\nMediator 是什麼？ # 定義：Mediator 將一組物件彼此之間錯綜複雜的「多對多互動」集中到一個「中介者」裡，讓各個物件（稱為 Colleague）不再直接相互呼叫，而是改為只認識 Mediator。 目標：降低物件之間的耦合度、讓互動規則集中管理、使得每個成員更簡單、更容易替換與測試。\n沒有 Mediator：A 調 B、B 調 C、C 又調 A… 形成網狀依賴。 有了 Mediator：A/B/C 都只呼叫 Mediator，互動規則統一在 Mediator。 典型角色\nMediator：定義同事之間互動的抽象介面。 ConcreteMediator：落地實作互動規則；持有並協調各 Colleague。 Colleague：只負責各自職責，所有跨物件互動都透過 Mediator。 何時使用\nUI 元件之間充滿相依（按鈕、輸入框、下拉選單彼此驅動）。 子系統／模組之間互調規則多、且常改（例如工作流程引擎、聊天室路由、航管塔台）。 想降低單元測試與替換成本：把規則集中到 Mediator，其他成員保持單純。 Mediator 的好處與代價 # 優點\n降低同事物件的直接耦合，便於替換與單元測試。 行為規則集中，變更點單一、可讀性提升。 更容易新增／移除同事，不會牽動到一堆互相呼叫的地方。 可能缺點\nMediator 容易長大成為「上帝物件（God Object）」：所有規則都擠進來。 若互動非常頻繁，單點 Mediator 可能成效能瓶頸，需要分片或事件化設計。 需要謹慎處理併發與重入（特別在 Go 裡）。 先看「沒有 Mediator」的痛點（聊天室例） # 想像一個最陽春的聊天室：每個使用者要能傳訊息給其他人。\npackage main import \u0026#34;fmt\u0026#34; type User struct { Name string // 直接持有其他使用者（糟糕示範） Contacts []*User } func (u *User) SendToAll(msg string) { for _, c := range u.Contacts { c.Receive(u.Name, msg) } } func (u *User) Receive(from, msg string) { fmt.Printf(\u0026#34;[%s] \u0026lt;- %s: %s\\n\u0026#34;, u.Name, from, msg) } func main() { alice := \u0026amp;User{Name: \u0026#34;Alice\u0026#34;} bob := \u0026amp;User{Name: \u0026#34;Bob\u0026#34;} carol := \u0026amp;User{Name: \u0026#34;Carol\u0026#34;} alice.Contacts = []*User{bob, carol} bob.Contacts = []*User{alice} carol.Contacts = []*User{alice} alice.SendToAll(\u0026#34;Hi all\u0026#34;) bob.SendToAll(\u0026#34;Hello Alice\u0026#34;) } 問題\nUser 必須知道其他人是誰，Contacts 變動就得同步更新別人的清單。 新增「訊息審核、群組、禁言、私訊」等規則？得改多個地方。 測試與替換困難，依賴關係像蜘蛛網。 引入 Mediator（聊天室重構） # 我們把「傳遞與規則」集中在 ChatRoom（Mediator）：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type Mediator interface { Register(u Colleague) Broadcast(from Colleague, msg string) Whisper(from Colleague, to string, msg string) error } type Colleague interface { Name() string Receive(from, msg string) SetMediator(m Mediator) } type ChatRoom struct { mu sync.RWMutex users map[string]Colleague } func NewChatRoom() *ChatRoom { return \u0026amp;ChatRoom{users: make(map[string]Colleague)} } func (c *ChatRoom) Register(u Colleague) { c.mu.Lock() defer c.mu.Unlock() u.SetMediator(c) c.users[u.Name()] = u } func (c *ChatRoom) Broadcast(from Colleague, msg string) { c.mu.RLock() defer c.mu.RUnlock() // 未來在這裡做過濾、審核、記錄、風控等規則都很自然 for name, u := range c.users { if name == from.Name() { continue } u.Receive(from.Name(), msg) } } func (c *ChatRoom) Whisper(from Colleague, to string, msg string) error { c.mu.RLock() defer c.mu.RUnlock() target, ok := c.users[to] if !ok { return fmt.Errorf(\u0026#34;user %s not found\u0026#34;, to) } target.Receive(fmt.Sprintf(\u0026#34;%s(whisper)\u0026#34;, from.Name()), msg) return nil } type User struct { name string m Mediator } func NewUser(name string) *User { return \u0026amp;User{name: name} } func (u *User) Name() string { return u.name } func (u *User) SetMediator(m Mediator) { u.m = m } func (u *User) Receive(from, msg string) { fmt.Printf(\u0026#34;[%s] \u0026lt;- %s: %s\\n\u0026#34;, u.name, from, msg) } // Colleague 只專注自身行為，跨物件互動交給 Mediator func (u *User) Say(msg string) { u.m.Broadcast(u, msg) } func (u *User) Whisper(to, msg string) { _ = u.m.Whisper(u, to, msg) } func main() { room := NewChatRoom() alice := NewUser(\u0026#34;Alice\u0026#34;) bob := NewUser(\u0026#34;Bob\u0026#34;) carol := NewUser(\u0026#34;Carol\u0026#34;) room.Register(alice) room.Register(bob) room.Register(carol) alice.Say(\u0026#34;Hi all\u0026#34;) bob.Whisper(\u0026#34;Alice\u0026#34;, \u0026#34;Hello privately\u0026#34;) carol.Say(\u0026#34;Nice to meet you ~\u0026#34;) } 觀察\nUser 不再知道任何其他 User 的存在，只知道 Mediator。 將來要新增「黑名單」「審核」「頻率限制」「關鍵字過濾」「訊息儲存」都只要改 ChatRoom。 使用 sync.RWMutex，支援多讀單寫；在併發 Say/Whisper 時就比較安全。 另一個經典：航管塔台（Air Traffic Control） # 塔台 = Mediator；飛機 = Colleague。起降順序、跑道占用、天氣限制等規則集中在塔台。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type Tower interface { RequestLanding(*Plane) bool RequestTakeoff(*Plane) bool NotifyLanded(*Plane) NotifyTakeoff(*Plane) } type Plane struct { id string tower Tower } func NewPlane(id string, t Tower) *Plane { return \u0026amp;Plane{id: id, tower: t} } func (p *Plane) AttemptLanding() { if p.tower.RequestLanding(p) { fmt.Println(p.id, \u0026#34;landing...\u0026#34;) p.tower.NotifyLanded(p) } else { fmt.Println(p.id, \u0026#34;holding pattern (cannot land now)\u0026#34;) } } func (p *Plane) AttemptTakeoff() { if p.tower.RequestTakeoff(p) { fmt.Println(p.id, \u0026#34;taking off...\u0026#34;) p.tower.NotifyTakeoff(p) } else { fmt.Println(p.id, \u0026#34;wait to takeoff\u0026#34;) } } type SimpleTower struct { mu sync.Mutex runwayFree bool } func NewSimpleTower() *SimpleTower { return \u0026amp;SimpleTower{runwayFree: true} } func (t *SimpleTower) RequestLanding(p *Plane) bool { t.mu.Lock() defer t.mu.Unlock() if t.runwayFree { t.runwayFree = false fmt.Println(\u0026#34;[Tower] Landing granted to\u0026#34;, p.id) return true } return false } func (t *SimpleTower) RequestTakeoff(p *Plane) bool { t.mu.Lock() defer t.mu.Unlock() if t.runwayFree { t.runwayFree = false fmt.Println(\u0026#34;[Tower] Takeoff granted to\u0026#34;, p.id) return true } return false } func (t *SimpleTower) NotifyLanded(p *Plane) { t.mu.Lock() defer t.mu.Unlock() fmt.Println(\u0026#34;[Tower]\u0026#34;, p.id, \u0026#34;landed; runway free\u0026#34;) t.runwayFree = true } func (t *SimpleTower) NotifyTakeoff(p *Plane) { t.mu.Lock() defer t.mu.Unlock() fmt.Println(\u0026#34;[Tower]\u0026#34;, p.id, \u0026#34;airborne; runway free\u0026#34;) t.runwayFree = true } func main() { tower := NewSimpleTower() a := NewPlane(\u0026#34;A320@UA101\u0026#34;, tower) b := NewPlane(\u0026#34;B738@DL202\u0026#34;, tower) a.AttemptLanding() b.AttemptLanding() b.AttemptLanding() // 再試一次，等跑道釋放 } 重點\n跑道資源與排程策略都在 SimpleTower，飛機不彼此溝通。 要改「先來先服務」→「優先權（燃油低者先）」、多跑道、天氣條件，都只改塔台。 UI 對話框範例（常見於桌面／Web GUI） # 三個元件：TextBox、Checkbox、Button。規則：\n若 Checkbox 勾選「我同意」，且 TextBox 非空，才可啟用 Button。 元件不互知，統一回報狀態變更給 DialogMediator。 package main import \u0026#34;fmt\u0026#34; type Widget interface { Changed() // 通知 Mediator：我變了 SetMediator(Mediator) } type Mediator interface { Notify(sender Widget) } type DialogMediator struct { username *TextBox agree *Checkbox submit *Button } func NewDialogMediator() *DialogMediator { m := \u0026amp;DialogMediator{} m.username = \u0026amp;TextBox{m: m} m.agree = \u0026amp;Checkbox{m: m} m.submit = \u0026amp;Button{m: m} m.update() return m } func (m *DialogMediator) Notify(sender Widget) { m.update() } func (m *DialogMediator) update() { canSubmit := m.username.text != \u0026#34;\u0026#34; \u0026amp;\u0026amp; m.agree.checked m.submit.enabled = canSubmit fmt.Printf(\u0026#34;UI =\u0026gt; text:%q, agree:%v, submit.enabled:%v\\n\u0026#34;, m.username.text, m.agree.checked, m.submit.enabled) } // ==== Widgets ==== type TextBox struct { m Mediator text string } func (t *TextBox) SetMediator(m Mediator) { t.m = m } func (t *TextBox) Changed() { t.m.Notify(t) } func (t *TextBox) Input(s string) { t.text = s t.Changed() } type Checkbox struct { m Mediator checked bool } func (c *Checkbox) SetMediator(m Mediator) { c.m = m } func (c *Checkbox) Changed() { c.m.Notify(c) } func (c *Checkbox) Toggle() { c.checked = !c.checked c.Changed() } type Button struct { m Mediator enabled bool } func (b *Button) SetMediator(m Mediator) { b.m = m } func (b *Button) Changed() { b.m.Notify(b) } func (b *Button) Click() { if !b.enabled { fmt.Println(\u0026#34;Button disabled\u0026#34;) return } fmt.Println(\u0026#34;Submitted!\u0026#34;) } func main() { dialog := NewDialogMediator() dialog.username.Input(\u0026#34;ian\u0026#34;) dialog.agree.Toggle() dialog.submit.Click() } 觀念\n規則集中在 DialogMediator.update()。 元件只負責自身狀態與向 mediator 回報改變，避免交叉操控。 併發與實務注意（Go 特別版） # 鎖的粒度\n讀多寫少場景（聊天室 broadcast）：使用 RWMutex；寫操作（註冊、黑名單更新）使用 Lock。 如需跨 goroutine 回呼，避免持鎖呼叫外部方法（可能造成死鎖或長時間阻塞）；可先複製快照，在鎖外迭代發送。 去抖／節流\nUI／事件風暴時可在 Mediator 端加 debounce/throttle，或以 channel 緩衝（worker pool 消化）。 可組態化\n把規則拆成策略（Strategy）或責任鏈（Chain of Responsibility）注入 Mediator，避免變成 God Object。 測試\n對 Mediator 寫單元測試（mock Colleague）；對 Colleague 則以假 mediator 驗證它只做該做的事。 與其他模式的比較 # Observer：一對多通知，Publisher 不認識 Subscriber 細節；適合「廣播式變更」。 Mediator 則是集中協調具體互動規則，常常需要知道每個參與者狀態來做判斷。 Event Bus：更鬆散、去中心化；處理全域事件分派。 Mediator 偏向「上下文限定（同一對話框／同一聊天室）」的局部協調中心。 Facade：對外簡化子系統介面；不負責內部物件互動流程。 Mediator 則主導內部互動。 Command：封裝請求；常與 Mediator 合用，把互動請求包成命令交給 Mediator 執行。 設計建議（落地清單） # 把規則放到 Mediator，避免 Colleague 互相查詢（違規徵象：同事彼此拿彼此指標、到處 if/else）。\n保持 Mediator 精瘦：\n規則多時，可拆為多個 mediator，或將子規則以策略／管線註入。 介面最小化：\nColleague 對 Mediator 保持極簡 API（如 Changed()、Send()），降低雙方耦合。 並發規劃：\n對頻繁互動使用 channel、worker pool 或分片 mediator（按群組分房、按跑道分塔台）。 小型基準與複雜度直覺 # 單次 broadcast：O(n)（n = 同事數），實務可用分區（房間/群組）分攤。 私訊：O(1) 查表（map）→ O(1)。 註冊/移除：O(1) map 操作；若附帶通知則另計。 鎖競爭：依場景，可以 快照 + 鎖外通知 降低臨界區時間。 迷你實作清單（可直接套用） # 聊天室：如上 ChatRoom，加上：\n黑名單 map[string]struct{}； 關鍵字過濾 []Rule； 訊息儲存（注入 interface Store）。 航管：SimpleTower → PriorityTower（用 heap 依優先權排），多跑道 []Runway。\nUI Dialog：Mediator + Widgets；加 debounce、表單驗證策略注入。\n補充：將廣播改為「鎖外通知」的安全寫法 # func (c *ChatRoom) Broadcast(from Colleague, msg string) { // 先拍快照 c.mu.RLock() targets := make([]Colleague, 0, len(c.users)) for name, u := range c.users { if name == from.Name() { continue } targets = append(targets, u) } c.mu.RUnlock() // 鎖外通知，避免長時間持鎖與 re-entrancy for _, u := range targets { u.Receive(from.Name(), msg) } } 一句話總結 # Mediator 透過「把互動規則集中在中介者」來解耦物件間複雜的多對多關係。 在 Go 中，特別留意併發與臨界區，把規則封裝在 Mediator，讓同事物件保持單純，就能寫出可維護、可擴充、好測試的系統。\n","date":"2025-09-04","externalUrl":null,"permalink":"/docs/mediator-with-go/","section":"All my post","summary":"Mediator with Go","title":"Mediator with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/memento/","section":"Tags","summary":"","title":"Memento","type":"tags"},{"content":"下面用「深入但好讀」的方式介紹 Memento（備忘錄）模式，並附上完整 Golang 範例（含 Undo/Redo、深拷貝注意事項、容量控制、交易式還原）來幫你一把。\n什麼是 Memento（備忘錄）？ # 目的：在不破壞封裝的前提下，將物件的內部狀態快照化（snapshot）並在日後回復（restore）。 典型用途：Undo/Redo、檢查點（checkpoint）、樂觀嘗試（speculative）、交易式回滾（transaction-like rollback）。\n參與者（Roles） # Originator：擁有內部狀態的物件。它能建立與回復備忘錄，但不需公開內部細節。 Memento：狀態快照。在狹義介面（caretaker 看見）下通常是**不透明（opaque）**的型別。 Caretaker：只負責保存、取回 Memento；不解讀內容。 何時使用？ # 需要 Undo/Redo 堆疊 需要 暫存點 / 還原點 要避免對外暴露內部屬性/欄位，但又希望能回復狀態 想將「狀態保存」和「狀態修改」的關注點分離 在 Go 中的設計重點 # 沒有 friend（像 C++），可用封裝策略：對外只暴露 EditorMemento（空介面或不含方法的介面），實際的 editorMemento 不導出（小寫），只能在同一 package內建立與使用 → Caretaker 無法窺探內容。 若狀態含 slice / map / 指標，務必深拷貝，避免後續修改「污染舊快照」。 大量快照要容量控制（例如只保留最近 N 筆）或做**增量（diff）**策略（進階）。 範例：文字編輯器（含 Undo/Redo 與交易式回滾） # 功能：輸入文字、移動游標、選取範圍；支援 Undo/Redo；示範深拷貝與容量上限；並提供 WithTransaction 在操作失敗時回滾。\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // ====== Memento 封裝：對外不透明 ====== type EditorMemento interface{ isEditorMemento() } // 狹義介面（narrow interface） // 實際快照結構：不導出（小寫）→ 外部無法 new/讀取欄位 type editorMemento struct { content string cursor int selection [2]int // 若有 slice/map/ptr，這裡要深拷貝 } func (*editorMemento) isEditorMemento() {} // ====== Originator：Editor ====== type Editor struct { content string cursor int selection [2]int // [start, end] } func NewEditor() *Editor { return \u0026amp;Editor{} } func (e *Editor) Type(s string) { // 在游標位置插入 left := e.content[:e.cursor] right := e.content[e.cursor:] e.content = left + s + right e.cursor += len(s) // 輸入後取消選取 e.selection = [2]int{e.cursor, e.cursor} } func (e *Editor) MoveCursor(pos int) { if pos \u0026lt; 0 { pos = 0 } if pos \u0026gt; len(e.content) { pos = len(e.content) } e.cursor = pos e.selection = [2]int{pos, pos} } func (e *Editor) Select(start, end int) { if start \u0026lt; 0 { start = 0 } if end \u0026gt; len(e.content) { end = len(e.content) } if start \u0026gt; end { start, end = end, start } e.selection = [2]int{start, end} e.cursor = end } func (e *Editor) DeleteSelection() { start, end := e.selection[0], e.selection[1] if start == end { return } left := e.content[:start] right := e.content[end:] e.content = left + right e.MoveCursor(start) e.selection = [2]int{start, start} } func (e *Editor) Content() string { return e.content } func (e *Editor) Cursor() int { return e.cursor } func (e *Editor) Selection() [2]int { return e.selection } // 建立備忘錄：記錄當前狀態（如有 slice/map/ptr，務必深拷貝） func (e *Editor) CreateMemento() EditorMemento { m := \u0026amp;editorMemento{ content: e.content, cursor: e.cursor, selection: e.selection, // 陣列值複製，安全 } return m } // 從備忘錄回復 func (e *Editor) Restore(m EditorMemento) { // 只能在本 package 看到具體型別 em, ok := m.(*editorMemento) if !ok { return } e.content = em.content e.cursor = em.cursor e.selection = em.selection } // ====== Caretaker：UndoManager（含 Redo 與容量上限） ====== type UndoManager struct { undoStack []EditorMemento redoStack []EditorMemento limit int origin *Editor } func NewUndoManager(origin *Editor, limit int) *UndoManager { if limit \u0026lt;= 0 { limit = 100 // 預設上限 } return \u0026amp;UndoManager{ origin: origin, limit: limit, } } // PushSnapshot：在變更前/後進行快照都可，但一致性最重要；這裡示範「變更前」先推 func (u *UndoManager) PushSnapshot() { m := u.origin.CreateMemento() u.undoStack = append(u.undoStack, m) // 新的操作打斷 redo 鏈 u.redoStack = u.redoStack[:0] // 容量控制：只保留最近 limit 筆 if len(u.undoStack) \u0026gt; u.limit { drop := len(u.undoStack) - u.limit u.undoStack = u.undoStack[drop:] } } func (u *UndoManager) CanUndo() bool { return len(u.undoStack) \u0026gt; 0 } func (u *UndoManager) CanRedo() bool { return len(u.redoStack) \u0026gt; 0 } func (u *UndoManager) Undo() bool { if !u.CanUndo() { return false } // 在回復前，將當前狀態放進 redoStack curr := u.origin.CreateMemento() u.redoStack = append(u.redoStack, curr) // 取出最後一個 undo 快照並回復 last := u.undoStack[len(u.undoStack)-1] u.undoStack = u.undoStack[:len(u.undoStack)-1] u.origin.Restore(last) return true } func (u *UndoManager) Redo() bool { if !u.CanRedo() { return false } // 在回復前，把當前狀態丟回 undoStack curr := u.origin.CreateMemento() u.undoStack = append(u.undoStack, curr) last := u.redoStack[len(u.redoStack)-1] u.redoStack = u.redoStack[:len(u.redoStack)-1] u.origin.Restore(last) return true } // WithTransaction：若 fn 返回錯誤則回滾至進入時狀態 func (u *UndoManager) WithTransaction(fn func() error) error { snapshot := u.origin.CreateMemento() err := fn() if err != nil { u.origin.Restore(snapshot) } return err } // ====== Demo ====== func main() { ed := NewEditor() undo := NewUndoManager(ed, 5) // 1) 打字前先推快照 undo.PushSnapshot() ed.Type(\u0026#34;Hello\u0026#34;) fmt.Println(\u0026#34;1:\u0026#34;, ed.Content()) // Hello // 2) 再打一段 undo.PushSnapshot() ed.Type(\u0026#34;, world\u0026#34;) fmt.Println(\u0026#34;2:\u0026#34;, ed.Content()) // Hello, world // 3) 選取 + 刪除 undo.PushSnapshot() ed.Select(5, 12) // 選取 \u0026#34;, world\u0026#34; ed.DeleteSelection() fmt.Println(\u0026#34;3:\u0026#34;, ed.Content()) // Hello // Undo ok := undo.Undo() fmt.Println(\u0026#34;Undo #1:\u0026#34;, ok, ed.Content()) // 回到 step 2: Hello, world ok = undo.Undo() fmt.Println(\u0026#34;Undo #2:\u0026#34;, ok, ed.Content()) // 回到 step 1: Hello // Redo ok = undo.Redo() fmt.Println(\u0026#34;Redo #1:\u0026#34;, ok, ed.Content()) // 回到 step 2: Hello, world // 交易式操作：若失敗就回滾 err := undo.WithTransaction(func() error { ed.MoveCursor(1000) // 大於長度會被夾到尾端 ed.Type(\u0026#34;!!!\u0026#34;) // 模擬失敗 return errors.New(\u0026#34;save failed\u0026#34;) }) fmt.Println(\u0026#34;Txn err:\u0026#34;, err != nil, \u0026#34;content:\u0026#34;, ed.Content()) // 失敗→回滾，仍是 Hello, world } 執行重點 # EditorMemento 是不透明介面，Caretaker 只存取、傳遞，看不到內容。 editorMemento 不導出，只有同 package 的 Editor 能建立與還原，封裝成立。 UndoManager 提供 PushSnapshot/Undo/Redo 與 WithTransaction，示範回滾。 深拷貝（必看） # 若狀態包含 slice/map/ptr，請在 CreateMemento 時做深拷貝。例如：\ntype State struct { buf []rune } func cloneRunes(r []rune) []rune { cp := make([]rune, len(r)) copy(cp, r) return cp } type origin struct{ s State } type memento2 struct{ buf []rune } func (*memento2) isEditorMemento() {} func (o *origin) CreateMemento() EditorMemento { return \u0026amp;memento2{buf: cloneRunes(o.s.buf)} } func (o *origin) Restore(m EditorMemento) { if mm, ok := m.(*memento2); ok { o.s.buf = cloneRunes(mm.buf) } } 不做深拷貝會導致歷史快照隨時間被污染（因為 slice/map 共享底層資料）。\n變體與進階 # 1) 序列化快照（可跨程序/持久化） # 用 encoding/json 或 encoding/gob 把狀態轉成位元組存檔。優點是儲存與載入簡單、跨語言也友好；缺點是效能與空間可能較差。\n// 假設 editor 狀態可序列化 type serialMemento []byte func (e *Editor) CreateJSONMemento() (serialMemento, error) { type dto struct { Content string Cursor int Selection [2]int } b, err := json.Marshal(dto{e.content, e.cursor, e.selection}) return b, err } func (e *Editor) RestoreJSON(b serialMemento) error { type dto struct { Content string Cursor int Selection [2]int } var d dto if err := json.Unmarshal(b, \u0026amp;d); err != nil { return err } e.content, e.cursor, e.selection = d.Content, d.Cursor, d.Selection return nil } 2) 窄/寬介面（Narrow vs Wide） # 狹義介面：Caretaker 看不到任何欄位（本例）。最保護封裝。 寬介面：Memento 暴露讀取器給 Originator 使用，Caretaker 也可能看得到一些內容（較少用）。 3) 與 Command 的取捨 # Memento：儲存整體狀態快照，還原簡單；快照大時耗記憶體。 Command（逆操作）：記錄「如何逆轉」操作，空間較省，但實作每個逆操作較繁瑣且容易漏邊角。 4) 記憶體與效能 # 大量快照採 容量上限、節流 或 分頁儲存。 支援增量（diff）：只存變動片段（需客製合併/回放邏輯）。 5) 多 Originator # 多個物件共享同一 Undo 管理器時，Memento 需標識來源，或設計每個 originator 專屬堆疊。 6) 執行緒安全 # 若在多 goroutine 使用，UndoManager 及 Editor 的操作要加鎖或使用不可變資料結構。 小結 # Memento 讓你在不外洩內部狀態的情況下，做 Undo/Redo 與回滾。 在 Go 裡透過不導出型別 + 狹義介面實現封裝，並特別注意深拷貝。 搭配容量限制、交易式 API、甚至序列化策略，能把它做成實用的狀態時光機。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/memento-with-go/","section":"All my post","summary":"Memento with Go","title":"Memento with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/observer/","section":"Tags","summary":"","title":"Observer","type":"tags"},{"content":"下面用「繁體中文 + Golang」完整解說 Observer（觀察者）模式，並給你兩種實作： (1) 簡潔同步版（介面清楚、易懂） (2) 生產級非同步版（goroutine + channel、可取消、具備背壓）\n什麼是 Observer？ # Observer（觀察者）是一種行為型模式：一個主體（Subject）狀態改變時，會自動「通知」所有已訂閱的觀察者（Observer）。常見於 GUI 事件、資料流推播、設定變更、行情/報價推送、Domain Event 等。\n何時使用 # 事件/資料從一對多地推送出去（publish → many observers） 希望「主體」與「觀察者」解耦（主體不需知道觀察者細節） 動態增加/移除訂閱者（runtime attach/detach） 優缺點 # 優點\n鬆耦合：主體僅認識 Observer 介面 易擴充：可隨時新增觀察者 自然對應事件驅動 缺點\n通知鏈難追蹤（尤其非同步） 觀察者執行過慢會阻塞（同步）或造成佇列壓力（非同步） 錯誤處理路徑較分散 結構與關係（簡化） # +---------+ notify(event) +------------+ | Subject |---------------------------\u0026gt;| Observer A | +---------+ +------------+ | +------------+ | | Observer B | | +------------+ 範例一：同步 Push（最容易看懂的版本） # 重點\nSubject 維護觀察者清單 事件發生時，逐一呼叫 Update(event) 使用 sync.RWMutex 確保併發安全（增刪訂閱、通知） package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // ---- Observer 與事件定義 ---- type Event struct { Name string Data any } type Observer interface { Update(e Event) ID() string // 方便移除/辨識 } // ---- Subject 介面與實作 ---- type Subject interface { Attach(o Observer) Detach(id string) Notify(e Event) } type subjectImpl struct { mu sync.RWMutex observers map[string]Observer } func NewSubject() Subject { return \u0026amp;subjectImpl{ observers: make(map[string]Observer), } } func (s *subjectImpl) Attach(o Observer) { s.mu.Lock() defer s.mu.Unlock() s.observers[o.ID()] = o } func (s *subjectImpl) Detach(id string) { s.mu.Lock() defer s.mu.Unlock() delete(s.observers, id) } func (s *subjectImpl) Notify(e Event) { s.mu.RLock() defer s.mu.RUnlock() for _, o := range s.observers { // 同步呼叫：若任一觀察者很慢，整個通知會被拖慢 o.Update(e) } } // ---- 兩個具體觀察者 ---- type LoggerObserver struct{ id string } func (l *LoggerObserver) ID() string { return l.id } func (l *LoggerObserver) Update(e Event) { fmt.Printf(\u0026#34;[LOGGER %s] got event: %s -\u0026gt; %#v\\n\u0026#34;, l.id, e.Name, e.Data) } type MetricsObserver struct{ id string } func (m *MetricsObserver) ID() string { return m.id } func (m *MetricsObserver) Update(e Event) { fmt.Printf(\u0026#34;[METRICS %s] count event: %s\\n\u0026#34;, m.id, e.Name) } // ---- Demo ---- func main() { s := NewSubject() logger := \u0026amp;LoggerObserver{id: \u0026#34;log-1\u0026#34;} metrics := \u0026amp;MetricsObserver{id: \u0026#34;m-1\u0026#34;} s.Attach(logger) s.Attach(metrics) s.Notify(Event{Name: \u0026#34;price.update\u0026#34;, Data: map[string]any{\u0026#34;symbol\u0026#34;: \u0026#34;AAPL\u0026#34;, \u0026#34;price\u0026#34;: 222.35}}) fmt.Println(\u0026#34;--- detach metrics ---\u0026#34;) s.Detach(\u0026#34;m-1\u0026#34;) s.Notify(Event{Name: \u0026#34;price.update\u0026#34;, Data: map[string]any{\u0026#34;symbol\u0026#34;: \u0026#34;GOOG\u0026#34;, \u0026#34;price\u0026#34;: 145.10}}) } 適用情境：\n觀察者數量不大、執行快速 想先以最小成本導入 Observer 解構 範例二：非同步、可取消、可背壓（生產較常見） # 為什麼需要非同步？ 同步通知時，某個觀察者慢 → 卡住主體/其他觀察者。非同步將每個觀察者放到獨立 goroutine，用 channel 收事件，並可加上 buffer 與 context 來控制壓力與中止。\n設計要點\nAsyncObserver 內含一條 chan Event，容量代表背壓緩衝\nStart(ctx) 啟動獨立 goroutine 消費事件\nStop() 或 ctx cancel 時優雅關閉\n主體發佈時用 非阻塞 / 有阻塞策略：\n非阻塞（select { case ch\u0026lt;-e: default: ... }）可以丟棄/計數溢出 阻塞（直接 ch \u0026lt;- e）保證送達，但可能卡住 下例示範「有界佇列 + 丟棄策略」：\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Event struct { Name string Data any } type AsyncObserver interface { ID() string Start(ctx context.Context) // 啟動消費 loop Stop() // 停止（可選） Input() chan\u0026lt;- Event // 給 Subject 寫入的入口 Stats() (dropped uint64, inQueue int32) // 觀察狀態（可觀測性） } type asyncObserver struct { id string ch chan Event wg sync.WaitGroup stop context.CancelFunc dropped uint64 inQueue int32 } func NewAsyncObserver(id string, buf int) *asyncObserver { return \u0026amp;asyncObserver{ id: id, ch: make(chan Event, buf), } } func (o *asyncObserver) ID() string { return o.id } func (o *asyncObserver) Start(parent context.Context) { ctx, cancel := context.WithCancel(parent) o.stop = cancel o.wg.Add(1) go func() { defer o.wg.Done() for { select { case \u0026lt;-ctx.Done(): // drain (視情況)；此處直接退出 return case e := \u0026lt;-o.ch: // 模擬處理 log.Printf(\u0026#34;[OBSERVER %s] consume: %s\u0026#34;, o.id, e.Name) time.Sleep(50 * time.Millisecond) } } }() } func (o *asyncObserver) Stop() { if o.stop != nil { o.stop() } o.wg.Wait() } func (o *asyncObserver) Input() chan\u0026lt;- Event { return o.ch } func (o *asyncObserver) Stats() (uint64, int32) { return o.dropped, int32(len(o.ch)) } // ---- Subject（非同步版） ---- type AsyncSubject interface { Attach(o AsyncObserver) Detach(id string) Notify(e Event) // 非阻塞丟入各觀察者佇列（可能丟棄） Shutdown() } type asyncSubject struct { mu sync.RWMutex observers map[string]AsyncObserver ctx context.Context cancel context.CancelFunc } func NewAsyncSubject() *asyncSubject { ctx, cancel := context.WithCancel(context.Background()) return \u0026amp;asyncSubject{ observers: make(map[string]AsyncObserver), ctx: ctx, cancel: cancel, } } func (s *asyncSubject) Attach(o AsyncObserver) { s.mu.Lock() defer s.mu.Unlock() o.Start(s.ctx) s.observers[o.ID()] = o } func (s *asyncSubject) Detach(id string) { s.mu.Lock() defer s.mu.Unlock() if o, ok := s.observers[id]; ok { o.Stop() delete(s.observers, id) } } func (s *asyncSubject) Notify(e Event) { s.mu.RLock() defer s.mu.RUnlock() for _, o := range s.observers { // 非阻塞送入，滿了就丟棄（也可改成阻塞/超時/重試） select { case o.Input() \u0026lt;- e: default: // 這裡可以累計 dropped、打 metrics 或記錄 warn log // 為簡化示例，略過 dropped 計數更新 log.Printf(\u0026#34;[SUBJECT] drop event for %s: %s\u0026#34;, o.ID(), e.Name) } } } func (s *asyncSubject) Shutdown() { s.cancel() s.mu.Lock() defer s.mu.Unlock() for id, o := range s.observers { o.Stop() delete(s.observers, id) } } // ---- Demo ---- func main() { s := NewAsyncSubject() defer s.Shutdown() // 兩個觀察者：不同 buffer，模擬不同承受能力 o1 := NewAsyncObserver(\u0026#34;logger\u0026#34;, 8) o2 := NewAsyncObserver(\u0026#34;analytics\u0026#34;, 2) s.Attach(o1) s.Attach(o2) // 高頻事件 for i := 0; i \u0026lt; 20; i++ { s.Notify(Event{ Name: \u0026#34;price.update\u0026#34;, Data: map[string]any{\u0026#34;tick\u0026#34;: i}, }) } time.Sleep(500 * time.Millisecond) // 動態移除 s.Detach(\u0026#34;analytics\u0026#34;) // 再推一些事件 for i := 20; i \u0026lt; 30; i++ { s.Notify(Event{Name: \u0026#34;price.update\u0026#34;, Data: i}) } time.Sleep(400 * time.Millisecond) } 此版本的要點\n每個觀察者各自的 goroutine 消費，互不阻塞 Notify 以 非阻塞 寫入：隊列滿 → 丟棄策略（你也可改為阻塞或有超時的 select） Shutdown/Detach 會 優雅停止 觀察者 goroutine Push vs Pull 模型 # Push（上面兩個例子）：主體把事件資料直接推到觀察者 Pull：主體只告知「有變化」，觀察者再回頭向主體拉取詳細資料（通常給 Subject Query API，減少 payload） 簡單 Pull 介面示意：\ntype ReadOnlyState interface { GetCurrentPrice(symbol string) (float64, bool) } type PullObserver interface { UpdateHint(hint string, s ReadOnlyState) // 收到提示，再自行向 s 拉取 } 與 Pub/Sub 的差異（在 Go 生態常見） # Observer：主體持有觀察者清單，直接呼叫它們（或推入它們的 channel）\nPub/Sub：透過**獨立中介（Broker / EventBus）**路由事件；發布者與訂閱者互不相識\n在 Go 中可用 channel + 中央 dispatcher 模擬；或使用 message broker（NATS/Kafka）等 實務建議 # 小流量/簡單邏輯：先用同步版，可讀性最好 多觀察者或慢處理：改用非同步 + 有界佇列，必要時加入超時/丟棄/重試策略 可觀測性：提供 dropped/queue depth、處理延遲等 metrics 取消與關閉：用 context.Context 或 Shutdown 確保資源回收 錯誤處理：Observer 的錯誤不要向上冒泡到 Subject；各自記錄與上報 介面穩定：Observer.Update 的參數可用 Event（型別 + 任意 Payload）以利擴充；或使用泛型（Go 1.18+） ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/observer-with-go/","section":"All my post","summary":"Observer with Go","title":"Observer with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/prototype/","section":"Tags","summary":"","title":"Prototype","type":"tags"},{"content":"下面用 Prototype（原型模式） 在 Golang 做一份「觀念 → 實務 → 陷阱 → 最佳實務」的完整說明，並給出可直接複製的程式範例（含淺拷貝、深拷貝、登記表 Registry、以及多型實作）。\nPrototype 是什麼？ # 定義（GoF） 透過複製（Clone）既有物件來建立新物件，而不經由建構流程。當建立成本昂貴、或建構過程複雜（需要許多參數、I/O、驗證）時，改以複製現成「原型」更快、更安全。\n關鍵目的\n避免昂貴的初始化/建構（如大量預計算、I/O）。 以「樣板（template）」快速產生客製化實例。 與 Abstract Factory / Builder 不同：Prototype 是用現成物件來生，而非用工廠/步驟「新建」。 在 Go 什麼時候用？ # 物件初始化成本高（讀檔/反序列化/昂貴計算），但之後會大量產生相似實例。 需要多型複製（不同具體型別，但對外只要呼叫 Clone()）。 需要「預註冊一些模板」：例如多種報表樣式、預設 API 請求、UI 元件預設風格等。 淺拷貝 vs 深拷貝（超重要） # 類型 淺拷貝效果 深拷貝效果 基本型別（int、bool、float） 直接值拷貝 ✔️ 同 struct（無指標/切片/map） 欄位值拷貝 ✔️ 同 切片（[]T） header 拷貝，底層陣列共用 ❗ 需複製底層元素 ✅ map 指標共用（兩者同指同張 map）❗ 需新建 map 並逐一複製 key/value ✅ 指標欄位 指到同個物件 ❗ 需另建新物件並複製其內容 ✅ 含 Mutex/chan/file 複製危險/不合法 ❗ 應避免拷貝；改用不可拷貝設計 範例 A：最基本的 Prototype 介面 + 淺/深拷貝對照 # package proto import \u0026#34;time\u0026#34; // 產品介面：具有 Clone 能力 type Prototype interface { Clone() Prototype } // 具體產品：包含切片、map、指標，方便示範深拷貝 type Document struct { Title string Tags []string Attrs map[string]string Created *time.Time } // (1) 錯誤示範：淺拷貝（會共享底層切片/map/指標） func (d *Document) ShallowClone() *Document { cp := *d // struct 值拷貝：Tags/Attrs/Created 僅拷貝 header/指標 return \u0026amp;cp } // (2) 正確示範：深拷貝（逐一複製容器與指標對象） func (d *Document) DeepClone() *Document { cp := \u0026amp;Document{ Title: d.Title, } // 複製 Tags if d.Tags != nil { cp.Tags = make([]string, len(d.Tags)) copy(cp.Tags, d.Tags) } // 複製 Attrs if d.Attrs != nil { cp.Attrs = make(map[string]string, len(d.Attrs)) for k, v := range d.Attrs { cp.Attrs[k] = v } } // 複製 Created（指標） if d.Created != nil { t := *d.Created cp.Created = \u0026amp;t } return cp } // 為了符合 Prototype 介面，導向深拷貝 func (d *Document) Clone() Prototype { return d.DeepClone() } 使用與差異觀察：\ndoc := \u0026amp;proto.Document{ Title: \u0026#34;Spec\u0026#34;, Tags: []string{\u0026#34;draft\u0026#34;}, Attrs: map[string]string{\u0026#34;lang\u0026#34;: \u0026#34;zh-TW\u0026#34;}, } sh := doc.ShallowClone() dp := doc.DeepClone() doc.Tags[0] = \u0026#34;final\u0026#34; doc.Attrs[\u0026#34;lang\u0026#34;] = \u0026#34;en\u0026#34; fmt.Println(sh.Tags[0]) // \u0026#34;final\u0026#34;（共享底層→被影響） fmt.Println(dp.Tags[0]) // \u0026#34;draft\u0026#34;（深拷貝→不受影響） 範例 B：多型 Prototype + 登記表（Registry） # 當你需要依名稱（或型號）快速取得「樣板」並 clone：\npackage registry import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // 1) 原型介面 type Prototype interface{ Clone() Prototype } // 2) 登記表 type Registry struct { mu sync.RWMutex pool map[string]Prototype } func NewRegistry() *Registry { return \u0026amp;Registry{pool: make(map[string]Prototype)} } func (r *Registry) Register(name string, p Prototype) { r.mu.Lock() defer r.mu.Unlock() r.pool[name] = p } func (r *Registry) Create(name string) (Prototype, error) { r.mu.RLock() p, ok := r.pool[name] r.mu.RUnlock() if !ok { return nil, fmt.Errorf(\u0026#34;unknown prototype: %s\u0026#34;, name) } return p.Clone(), nil } 搭配不同具體產品（多型）：\ntype Circle struct{ X, Y, R int } func (c *Circle) Clone() Prototype { cp := *c return \u0026amp;cp } type Label struct{ Text string; Style map[string]string } func (l *Label) Clone() Prototype { cp := \u0026amp;Label{Text: l.Text} if l.Style != nil { cp.Style = make(map[string]string, len(l.Style)) for k, v := range l.Style { cp.Style[k] = v } } return cp } // 使用 reg := registry.NewRegistry() reg.Register(\u0026#34;smallCircle\u0026#34;, \u0026amp;Circle{X: 5, Y: 5, R: 10}) reg.Register(\u0026#34;title\u0026#34;, \u0026amp;Label{Text: \u0026#34;Hello\u0026#34;, Style: map[string]string{\u0026#34;size\u0026#34;: \u0026#34;24\u0026#34;}}) p1, _ := reg.Create(\u0026#34;smallCircle\u0026#34;) // 新 Circle（值複製） p2, _ := reg.Create(\u0026#34;title\u0026#34;) // 新 Label（深拷貝 Style） 注意併發：登記/讀取加鎖，或在 init() 階段註冊固定原型。\n範例 C：與 JSON/Gob 反序列化結合的「通用深拷貝」（務必看注意事項） # 有時你想快速深拷貝一個「樹狀資料」。可用 encoding/json 或 encoding/gob 做「序列化 → 反序列化」：\n// JSON 方式（簡易但有侷限：需可導出欄位、time/特殊型別處理慎重） func DeepCopyJSON[T any](in T) (T, error) { var zero T b, err := json.Marshal(in) if err != nil { return zero, err } var out T if err := json.Unmarshal(b, \u0026amp;out); err != nil { return zero, err } return out, nil } 侷限與風險\n欄位需為導出（大寫），否則無法編碼。 time.Time、complex、chan、func、sync.Mutex 等需特別處理或避開。 成本較高（序列化開銷），不適合 hot path。 建議：手寫深拷貝在關鍵邏輯、效能敏感處仍是王道；JSON/Gob 僅適合工具性或非關鍵路徑。\n範例 D：複製「不可拷貝」型別：策略與避坑 # sync.Mutex / sync.RWMutex：不可拷貝。把它們放在「行為物件」內，而不是資料模型內；或讓模型保持不可變（immutable）。 io.ReadCloser / *os.File / sql.DB 等具資源狀態：不要複製，改用外部注入或重新開啟。 context.Context：不應拷貝，傳遞即可。 性能與測試 # 手寫深拷貝通常最快，且可精準控制。 JSON/Gob 深拷貝方便但慢，適合管理面、非 hot path。 做 Benchmark：比較建構成本 vs Clone 成本，驗證 Prototype 帶來的實際收益。 簡易基準（示意）：\nfunc BenchmarkClone(b *testing.B) { proto := \u0026amp;Document{ Title: \u0026#34;big\u0026#34;, Tags: make([]string, 1000), Attrs: make(map[string]string, 1000), } for i := 0; i \u0026lt; 1000; i++ { proto.Tags[i] = fmt.Sprintf(\u0026#34;t%d\u0026#34;, i) proto.Attrs[strconv.Itoa(i)] = \u0026#34;v\u0026#34; } b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { _ = proto.DeepClone() } } 與其他創建型模式比較（何時選 Prototype？） # 模式 用途 何時優先 Factory Method 以可覆寫的「建立點」生出單一產品 需要多型建立但仍「新建」物件 Abstract Factory 一次生出一族相關產品 需要成套一致的多個產品 Builder 複雜建構步驟的漸進式組裝 需要多步驟建構、可讀性佳 Prototype 以複製現有物件取得新實例 初始化昂貴、或模板 → 大量複製 最佳實務清單 # 先決定要深拷貝到什麼深度：明確列出「要複製/不複製」的欄位（尤其是大型切片/快取）。 避免共享可變容器：切片、map、指標欄位基本都要重建。 對多型產品：用 Prototype 介面 + 各具體型別自己的 Clone()。 Registry（登記式）：適合「名稱 → 原型模板」的場景，但要注意並發安全。 敏感型別（mutex、file、conn、chan…）不要拷貝；改用外部依賴或不可變設計。 效能敏感：手寫深拷貝，並針對最大資料結構做 benchmark。 測試：寫出「修改 clone 不影響原型」的斷言，確保深拷貝正確。 一個整合度較高的可複製範例 # package profile import \u0026#34;time\u0026#34; type Address struct { City string Streets []string } type UserProfile struct { ID int64 Name string Labels map[string]string Address *Address CreatedAt time.Time // 值類型，直接拷貝即可 } func (p *UserProfile) Clone() *UserProfile { cp := \u0026amp;UserProfile{ ID: p.ID, Name: p.Name, CreatedAt: p.CreatedAt, // 值拷貝 OK } // 深拷貝 map if p.Labels != nil { cp.Labels = make(map[string]string, len(p.Labels)) for k, v := range p.Labels { cp.Labels[k] = v } } // 深拷貝指標 + 內部切片 if p.Address != nil { addr := \u0026amp;Address{City: p.Address.City} if p.Address.Streets != nil { addr.Streets = make([]string, len(p.Address.Streets)) copy(addr.Streets, p.Address.Streets) } cp.Address = addr } return cp } 驗證不互相影響：\nu1 := \u0026amp;UserProfile{ ID: 1, Name: \u0026#34;Ian\u0026#34;, Labels: map[string]string{\u0026#34;role\u0026#34;:\u0026#34;admin\u0026#34;}, Address: \u0026amp;Address{City:\u0026#34;Taipei\u0026#34;, Streets: []string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;}}, } u2 := u1.Clone() u2.Name = \u0026#34;Another\u0026#34; u2.Labels[\u0026#34;role\u0026#34;] = \u0026#34;user\u0026#34; u2.Address.Streets[0] = \u0026#34;C\u0026#34; fmt.Println(u1.Name) // \u0026#34;Ian\u0026#34;（不受影響） fmt.Println(u1.Labels[\u0026#34;role\u0026#34;]) // \u0026#34;admin\u0026#34;（不受影響） fmt.Println(u1.Address.Streets[0]) // \u0026#34;A\u0026#34;（不受影響） 小結 # Prototype 在 Go 的精髓：正確地複製（特別是切片、map、指標）以避免共享可變狀態。 當建構昂貴或想要以模板快速產生多個實例時，Prototype 很實用。 實務上常與Registry、多型 Clone() 搭配；效能敏感路徑請手寫深拷貝並做 benchmark。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/prototype-with-go/","section":"All my post","summary":"Prototype with Go","title":"Prototype with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/proxy/","section":"Tags","summary":"","title":"Proxy","type":"tags"},{"content":"下面用 Proxy（代理人模式） 在 Golang 做一份「觀念 → 角色 → Go 風格實作（存取控制／虛擬載入／快取／遠端代理）→ 併發與錯誤 → 與相近模式比較 → 易錯點」的完整解說；每段都附上可直接複製的範例。\nProxy 是什麼？何時用？ # 定義（GoF） 為某個物件提供一個替身（stand-in），這個替身與真實物件有相同介面，但在呼叫之前或之後，攔截並施加額外的管控（例如：權限、存活期、延遲載入、快取、遠端通訊、資源統計）。\n典型用途\n保護代理（Protection）：RBAC 權限檢查、白名單、配額。 虛擬代理（Virtual / Lazy）：昂貴物件延遲建立（例如延遲載入檔案/影像/DB 連線）。 快取代理（Caching）：重複查詢直接回舊值，減少 I/O。 遠端代理（Remote）：以在地物件的形式，呼叫其實是發到遠端（RPC/HTTP）。 智慧參考（Smart Reference）：統計存取次數、惰性關閉、引用計數。 關鍵差異：Proxy 的目的在「控制存取」與「替身」；Decorator 在「擴充行為」且通常不改用法語義。\n結構與 Go 寫法 # Subject（介面）：對外 API。 RealSubject（真實物件）：實作介面，提供核心功能。 Proxy（代理）：實作同一介面；內含 RealSubject，在呼叫前/後進行控制邏輯。 Go 寫法自然以 interface + composition 完成。\n範例 1：保護代理（RBAC 存取控制） # 情境：只有 ADMIN 能刪除訂單；其他角色只能讀取。\npackage proxy_protect import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; ) // Subject type OrderService interface { Get(ctx context.Context, id string) (string, error) Delete(ctx context.Context, id string) error } // RealSubject type orderSvc struct{} func NewRealOrderSvc() OrderService { return \u0026amp;orderSvc{} } func (s *orderSvc) Get(ctx context.Context, id string) (string, error) { return \u0026#34;order:\u0026#34;+id, nil } func (s *orderSvc) Delete(ctx context.Context, id string) error { return nil } // --- 保護代理 --- // 從 ctx 取出角色（示意） type ctxKey struct{} func WithRole(ctx context.Context, role string) context.Context { return context.WithValue(ctx, ctxKey{}, role) } func roleOf(ctx context.Context) string { if v := ctx.Value(ctxKey{}); v != nil { return v.(string) } return \u0026#34;\u0026#34; } type authProxy struct{ next OrderService } func WithAuth(next OrderService) OrderService { return \u0026amp;authProxy{next: next} } func (p *authProxy) Get(ctx context.Context, id string) (string, error) { return p.next.Get(ctx, id) } func (p *authProxy) Delete(ctx context.Context, id string) error { if roleOf(ctx) != \u0026#34;ADMIN\u0026#34; { return errors.New(\u0026#34;forbidden: need ADMIN\u0026#34;) } return p.next.Delete(ctx, id) } 使用\nreal := proxy_protect.NewRealOrderSvc() svc := proxy_protect.WithAuth(real) ctxUser := proxy_protect.WithRole(context.Background(), \u0026#34;USER\u0026#34;) ctxAdmin := proxy_protect.WithRole(context.Background(), \u0026#34;ADMIN\u0026#34;) _, _ = svc.Get(ctxUser, \u0026#34;A\u0026#34;) // ok _ = svc.Delete(ctxUser, \u0026#34;A\u0026#34;) // -\u0026gt; forbidden _ = svc.Delete(ctxAdmin, \u0026#34;A\u0026#34;) // ok 重點：Proxy 與 Real 實作同介面，呼叫端不必知道是否在使用代理。\n範例 2：虛擬代理（Lazy / 延遲載入） # 情境：建立影音縮圖 Thumbnail 很昂貴（要讀檔解碼）。改成：第一次使用時才載入。\npackage proxy_virtual import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // Subject type Image interface { Size() (w, h int, err error) Display() error } // RealSubject（昂貴） type realImage struct { file string w, h int } func loadImage(file string) *realImage { // 假裝讀檔與解碼 return \u0026amp;realImage{file: file, w: 1920, h: 1080} } func (img *realImage) Size() (int, int, error) { return img.w, img.h, nil } func (img *realImage) Display() error { fmt.Println(\u0026#34;display\u0026#34;, img.file); return nil } // Proxy（lazy） type proxyImage struct { file string once sync.Once real *realImage } func NewImage(file string) Image { return \u0026amp;proxyImage{file: file} } func (p *proxyImage) ensure() { p.once.Do(func(){ p.real = loadImage(p.file) }) } func (p *proxyImage) Size() (int, int, error) { p.ensure(); return p.real.Size() } func (p *proxyImage) Display() error { p.ensure(); return p.real.Display() } 特點：直到第一次 Size() / Display() 才解碼；之後重複使用同一 realImage。\n範例 3：快取代理（Memoization／讀多寫少） # 情境：價格查詢實際會打 API，很慢；對同一 SKU 的重複查詢先回快取。\npackage proxy_cache import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // Subject type PriceAPI interface { PriceOf(ctx context.Context, sku string) (int, error) // cents } // RealSubject（假裝很慢） type priceAPI struct{} func NewReal() PriceAPI { return \u0026amp;priceAPI{} } func (p *priceAPI) PriceOf(ctx context.Context, sku string) (int, error) { time.Sleep(50 * time.Millisecond) // IO 延遲 if sku == \u0026#34;\u0026#34; { return 0, errors.New(\u0026#34;bad sku\u0026#34;) } return 1299, nil } // Proxy（快取） type CacheProxy struct { next PriceAPI mu sync.RWMutex data map[string]int ttl time.Duration exp map[string]time.Time } func WithCache(next PriceAPI, ttl time.Duration) *CacheProxy { return \u0026amp;CacheProxy{next: next, data: map[string]int{}, exp: map[string]time.Time{}, ttl: ttl} } func (p *CacheProxy) PriceOf(ctx context.Context, sku string) (int, error) { now := time.Now() p.mu.RLock() v, ok := p.data[sku] e, hasExp := p.exp[sku] p.mu.RUnlock() if ok \u0026amp;\u0026amp; hasExp \u0026amp;\u0026amp; now.Before(e) { return v, nil } val, err := p.next.PriceOf(ctx, sku) if err != nil { return 0, err } p.mu.Lock() p.data[sku] = val p.exp[sku] = now.Add(p.ttl) p.mu.Unlock() return val, nil } 要點：\nProxy 可維護 TTL、統計命中率、主動失效。 真正資料一致性仍由後端服務保證；快取只是前段的代理。 範例 4：遠端代理（Remote / Client Stub） # 情境：在本機我們拿到的是 UserService 介面；實作其實是HTTP 客戶端，呼叫遠端服務。\npackage proxy_remote import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) // Subject type UserService interface { NameOf(ctx context.Context, id int64) (string, error) } // Proxy as RealSubject（client stub） type httpUserService struct { base *url.URL cli *http.Client } func NewHTTP(base string) (UserService, error) { u, err := url.Parse(base); if err != nil { return nil, err } return \u0026amp;httpUserService{base: u, cli: http.DefaultClient}, nil } func (s *httpUserService) NameOf(ctx context.Context, id int64) (string, error) { req, _ := http.NewRequestWithContext(ctx, \u0026#34;GET\u0026#34;, s.base.String()+fmt.Sprintf(\u0026#34;/users/%d\u0026#34;, id), nil) resp, err := s.cli.Do(req) if err != nil { return \u0026#34;\u0026#34;, err } defer resp.Body.Close() if resp.StatusCode != 200 { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;status %d\u0026#34;, resp.StatusCode) } var out struct{ Name string `json:\u0026#34;name\u0026#34;` } if err := json.NewDecoder(resp.Body).Decode(\u0026amp;out); err != nil { return \u0026#34;\u0026#34;, err } return out.Name, nil } 重點：\n對使用者來說就是呼叫 NameOf()；實際是跨網路。 這就是典型的「遠端代理 / Client Stub」。 併發、安全與錯誤處理（實戰建議） # 介面語義：Proxy 必須維持相同的介面與錯誤語義；若要轉換錯誤，請用 %w 包裝以保留 errors.Is/As 能力。\n併發保護：\n快取／延遲載入常需要 sync.RWMutex 或 sync.Once；避免重複初始化與資料競態。 熱鍵可用 singleflight（避免 stampede）。 資源生命週期：\n遠端代理通常需要 Close()（連線、閘道）；可在介面中加 io.Closer 或額外方法。 虛擬代理的真實物件若持有檔案/連線，記得釋放。 觀測與限流：\nProxy 是導入 metrics / tracing / 限流 / 熔斷 的天然位置，但若僅做橫切擴充且不涉「替身/存取控制」，那更像 Decorator。 效能：\n每層代理都有間接呼叫與鎖開銷；在熱路徑要測試（go test -bench）。 快取鍵與 TTL 設計需貼近業務，避免髒資料或低命中。 與相近模式比較 # 模式 目的 與 Proxy 差異 Decorator 在同介面上疊加行為（記錄、重試、限流） 不一定是「替身」；Proxy 著重存取控制/延遲/遠端 Adapter 轉換介面使相容 Proxy 不改介面；Adapter 會換簽章/資料形狀 Facade 對多子系統提供簡化外觀 Facade 是「總控流程」，非替身；Proxy 面向單一 Subject Bridge 抽象與實作分離、雙維度演進 設計時的解耦，不是呼叫時的替身 常見陷阱與最佳實務 # 代理破壞語義：回傳型別、錯誤類型或副作用與真實物件不一致 → 測試要比對契約。 全域快取失控：Proxy 快取無上限或無 TTL → 記憶體暴增；加大小限制或淘汰策略。 懶載入 race / 重複初始化：請用 sync.Once 或雙重檢查鎖。 過度代理：一個介面疊太多層代理，追蹤困難；集中到組裝層，明確每層責任。 把 Decorator 當 Proxy：若沒有替身／存取控制需求，只是加日誌/重試，考慮用 Decorator 命名與語意更清楚。 迷你整合示例（可直接跑）：RBAC + 快取 代理組合 # package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // ==== 取自前面：Subject ==== type PriceAPI interface{ PriceOf(ctx context.Context, sku string) (int, error) } type priceAPI struct{} func (p *priceAPI) PriceOf(ctx context.Context, sku string) (int, error) { time.Sleep(30*time.Millisecond); return 1299, nil } // ==== 保護代理 ==== type ctxKey struct{} func WithRole(ctx context.Context, role string) context.Context { return context.WithValue(ctx, ctxKey{}, role) } func roleOf(ctx context.Context) string { if v := ctx.Value(ctxKey{}); v != nil { return v.(string) } return \u0026#34;\u0026#34; } type protectProxy struct{ next PriceAPI } func WithProtect(next PriceAPI) PriceAPI { return \u0026amp;protectProxy{next: next} } func (p *protectProxy) PriceOf(ctx context.Context, sku string) (int, error) { if roleOf(ctx) == \u0026#34;BANNED\u0026#34; { return 0, fmt.Errorf(\u0026#34;forbidden\u0026#34;) } return p.next.PriceOf(ctx, sku) } // ==== 快取代理 ==== type cacheProxy struct { next PriceAPI m map[string]struct{ val int; exp time.Time } } func WithCache(next PriceAPI, ttl time.Duration) PriceAPI { return \u0026amp;cacheProxy{next: next, m: map[string]struct{val int; exp time.Time}{},} } func (c *cacheProxy) PriceOf(ctx context.Context, sku string) (int, error) { if it, ok := c.m[sku]; ok \u0026amp;\u0026amp; time.Now().Before(it.exp) { return it.val, nil } v, err := c.next.PriceOf(ctx, sku); if err != nil { return 0, err } c.m[sku] = struct{val int; exp time.Time}{v, time.Now().Add(2*time.Second)} return v, nil } func main() { var api PriceAPI = \u0026amp;priceAPI{} api = WithCache(api, 2*time.Second) api = WithProtect(api) ctx := WithRole(context.Background(), \u0026#34;USER\u0026#34;) v1, _ := api.PriceOf(ctx, \u0026#34;ABC\u0026#34;) // 第一次：慢 v2, _ := api.PriceOf(ctx, \u0026#34;ABC\u0026#34;) // 第二次：快取 fmt.Println(v1, v2) ctxBan := WithRole(context.Background(), \u0026#34;BANNED\u0026#34;) _, err := api.PriceOf(ctxBan, \u0026#34;ABC\u0026#34;) fmt.Println(\u0026#34;banned err:\u0026#34;, err != nil) } 小結 # Proxy 以「替身物件、同介面」為核心，專注存取控制／延遲載入／快取／遠端呼叫等需求。 在 Go：用 interface + 組合，代理內放 RealSubject；注意併發保護、錯誤語義、資源壽命。 與 Decorator/Adapter/Facade/Bridge 明確區分語義，讓後續維護者一看就懂「這層是代理、那層是裝飾」。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/proxy-with-go/","section":"All my post","summary":"Proxy with Go","title":"Proxy with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/singleton/","section":"Tags","summary":"","title":"Singleton","type":"tags"},{"content":"下面用 Singleton（單例模式） 在 Golang 做一個完整、實務導向的解說：核心概念、常見實作（eager/lazy）、參數化初始化、併發與測試注意、何時不用 Singleton，以及替代方案。附上一系列可直接複製的 Go 範例。\n是什麼與何時用 # 定義：保證整個行程（process）中某個型別只有唯一實例，並提供存取該實例的全域入口。\n常見用途\n設定/組態（Config）：只讀或固定週期更新。 共享資源：連線池（DB/Redis）、客製化日誌器（Logger）、全域 Registry。 昂貴建置的服務：模型/字典/快取載入器。 在 Go 中，套件級（package-level）變數 + 初始化本身就很「像」單例；但若要延遲初始化（lazy）、容錯與併發安全，仍建議用 sync.Once 等正式手法。\n實作 1：最常用的「lazy + 併發安全」寫法（sync.Once） # package singleton import ( \u0026#34;log\u0026#34; \u0026#34;sync\u0026#34; ) type Logger struct { Prefix string } func (l *Logger) Println(v ...any) { log.Println(append([]any{l.Prefix}, v...)...) } var ( once sync.Once instance *Logger ) // GetLogger：第一次呼叫時才建立（lazy），而且 thread-safe。 func GetLogger() *Logger { once.Do(func() { instance = \u0026amp;Logger{Prefix: \u0026#34;[APP]\u0026#34;} }) return instance } 說明\nsync.Once 確保內部 func() 只執行一次（對所有 goroutine）。 之後每次呼叫 GetLogger() 都回傳同一個指標。 實作 2：Eager（提早初始化） # package singleton var eager = \u0026amp;Logger{Prefix: \u0026#34;[APP]\u0026#34;} // 聲明時就建好 func EagerLogger() *Logger { return eager } 何時用：建構成本小、沒有失敗風險（或失敗就整個程式退出）、不需依賴外部資源。\n實作 3：參數化初始化（只接受「第一次」的參數） # 單例有一個實務痛點：要帶參數（例如從環境變數或檔案讀設定）。通例是：第一次呼叫的人決定初始化；之後的參數會被忽略或回錯誤。\npackage config import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type Config struct { Env string Debug bool } var ( once sync.Once cfg *Config initErr error ) // InitAndGet：第一次呼叫可帶參數；之後再帶參數會被忽略（回傳既有 cfg）。 func InitAndGet(env string, debug bool) (*Config, error) { once.Do(func() { if env == \u0026#34;\u0026#34; { initErr = fmt.Errorf(\u0026#34;env cannot be empty\u0026#34;) return } cfg = \u0026amp;Config{Env: env, Debug: debug} }) return cfg, initErr } 使用\nc, err := config.InitAndGet(\u0026#34;prod\u0026#34;, false) // 第一次：真的初始化 // 之後：即使傳不同參數也不會改變既有實例 _ = c Go 1.21+：可以用 sync.OnceValue/sync.OnceFunc 簡化 lazy 單例（若你的編譯器版本支援）：\nvar getCfg = sync.OnceValue(func() *Config { // 實作初始化與容錯（必要時可 panic 再由上層 recover） return \u0026amp;Config{Env: \u0026#34;prod\u0026#34;} }) // 取得單例 cfg := getCfg() 實作 4：分鍵單例（per-key singleton）（進階） # 有時你需要「每個 key 一個單例」（例如每個地區一個客戶端）。可用 sync.Map + sync.Once 或 singleflight 實現：\npackage multiton import ( \u0026#34;sync\u0026#34; ) type Client struct{ region string } var ( clients sync.Map // map[string]*entry ) type entry struct { once sync.Once ptr *Client } func GetClient(region string) *Client { ei, _ := clients.LoadOrStore(region, \u0026amp;entry{}) e := ei.(*entry) e.once.Do(func() { e.ptr = \u0026amp;Client{region: region} }) return e.ptr } 實作 5：可測試的單例（測試替身 / 重設） # 單例最常被抱怨：很難測試。建議：\n盡量讓依賴注入取代硬性單例（把單例只放在組裝層使用）。 若一定要全域單例，為測試檔提供重設機制（只在 _test.go 或以 build tag 限制）。 // file: logger.go package singleton import \u0026#34;sync\u0026#34; type Logger struct{ /* ... */ } var ( once sync.Once instance *Logger ) func GetLogger() *Logger { once.Do(func() { instance = \u0026amp;Logger{} }) return instance } // file: logger_test.go package singleton import \u0026#34;testing\u0026#34; // 測試輔助：重設（只存在於測試編譯單元） func reset() { instance = nil once = sync.Once{} } func TestLogger(t *testing.T) { reset() l := GetLogger() if l == nil { t.Fatal(\u0026#34;nil\u0026#34;) } } 注意：不要把 reset 介面暴露到正式程式。若要更安全，使用 build tag //go:build testutil 將 reset 侷限於測試。\n執行緒安全與效能細節 # 千萬別用「雙重檢查鎖定（DCL）」+ 原始 *T == nil 的花式寫法；Go 中 sync.Once 已經是最佳解（簡潔、正確、足夠快）。 讀多寫少的單例狀況，多數時間只是拿指標，開銷極小。 若單例內部還有可變狀態（例如熱更新設定），仍需在內部用 sync.RWMutex 或 atomic.Value 管理。 type SafeConfig struct { v atomic.Value // 內含 *Config } func (s *SafeConfig) Load() *Config { return s.v.Load().(*Config) } func (s *SafeConfig) Store(c *Config) { s.v.Store(c) } 反模式與實務建議 # 過度使用單例\n單例 = 隱含全域狀態 → 使測試、重用、平行化變困難。 建議：把單例留在組裝層（main/wire/fx）；業務層多用介面 + 注入。 帶 I/O 的初始化\n例如一開始就打 DB/讀檔：若初始化失敗要怎麼辦？ 建議：讓 Get() 或 Init() 回傳 error；或在組裝期先完成初始化、檢查後再啟動服務。 跨測試污染\nGo 測試是同一行程下執行多個 test。全域單例若不可重設，測試會互相污染。 建議：為測試提供 reset（僅限測試編譯）或避免在被測套件內直接取用單例。 完整示例：可參數化、可回傳錯誤、可測試的單例 # package appcfg import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;sync\u0026#34; ) type Config struct { AppName string Env string Debug bool } var ( once sync.Once cfg *Config initErr error ) type Options struct { AppName string Env string // \u0026#34;dev\u0026#34;/\u0026#34;staging\u0026#34;/\u0026#34;prod\u0026#34; Debug bool } // Init：可以由 main 在啟動期呼叫；或在第一次 Get() 時延遲初始化 func Init(opt Options) error { once.Do(func() { if opt.AppName == \u0026#34;\u0026#34; { opt.AppName = os.Getenv(\u0026#34;APP_NAME\u0026#34;) } if opt.Env == \u0026#34;\u0026#34; { opt.Env = os.Getenv(\u0026#34;APP_ENV\u0026#34;) } if opt.Env == \u0026#34;\u0026#34; { initErr = fmt.Errorf(\u0026#34;APP_ENV missing\u0026#34;) return } cfg = \u0026amp;Config{ AppName: opt.AppName, Env: opt.Env, Debug: opt.Debug, } }) return initErr } func Get() (*Config, error) { if cfg != nil || initErr != nil { return cfg, initErr } // 若尚未初始化，可選擇：1) 自動用預設初始化；或 2) 回錯誤，要求呼叫端先 Init return nil, fmt.Errorf(\u0026#34;config not initialized; call appcfg.Init first\u0026#34;) } 使用\nfunc main() { if err := appcfg.Init(appcfg.Options{AppName: \u0026#34;svc\u0026#34;, Env: \u0026#34;prod\u0026#34;}); err != nil { panic(err) } c, _ := appcfg.Get() _ = c } 測試（僅示意）\n// 在 _test.go 用 build tag 或私有 reset() 重設 once/cfg 何時不用 Singleton？（或用什麼替代） # HTTP handler / gRPC 服務：通常在組裝期把依賴（DB/Cache/Logger）以參數注入，而不是在 handler 內呼叫單例。 每請求不同設定或租戶（multi-tenant）：改用 per-key 工廠/快取（multiton）。 生命週期管理：使用 DI/生命周期框架（如 Uber/Fx、Wire）協助建構、關閉資源，比全域單例更好控管。 總結 # Go 中實作 Singleton 的黃金寫法：sync.Once（lazy + 併發安全）。 若需參數化：只讓第一次呼叫決定；之後忽略或回錯誤。 注意測試與全域狀態污染；能注入就注入，把單例留在組裝層。 進階需求可用 multiton、atomic.Value 或（Go 1.21+）sync.OnceValue 精簡程式。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/singleton-with-go/","section":"All my post","summary":"Singleton with Go","title":"Singleton with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/state/","section":"Tags","summary":"","title":"State","type":"tags"},{"content":"下面用「觀念 → 基本骨架 → 經典範例（Turnstile、販賣機）→ 進階技巧（併發、table-driven FSM、與 Strategy 比較）」的順序，深入介紹 State（狀態）模式，並以 Golang 完整示範。\n什麼是 State 模式？ # 定義：把「因狀態不同而改變的行為」封裝成一組 State 物件。Context 只負責持有目前狀態，對外提供穩定 API；實際邏輯由不同 State 決定，並在需要時切換到下一個狀態。\n想像場景：閘門（投入代幣 → 解鎖／推門 → 上鎖）、TCP 連線（CLOSED/ESTABLISHED）、訂單流程（Created→Paid→Shipped→Closed）… 徵兆：if state == ... { ... } else if state == ... { ... } 在各處蔓延；修改時易出錯。\n角色\nState（介面/抽象類）：定義狀態下允許的操作。 ConcreteStateX：在某個狀態下，實作各操作與「轉移到下一狀態」的規則。 Context：對外 API；內部持有 State，把請求委派給當前 State。 好處\n把分支邏輯集中到各 State，Context 乾淨、可替換、好測試。 新增/修改狀態 → 只動到對應 ConcreteState。 讓「行為」與「狀態轉移」自然貼合。 代價/風險\n類別數量增加；若狀態很多，需控管檔案與命名。 跨狀態共享資料需小心：放 Context（共享）或包成服務注入。 Go 基本骨架 # // State 介面：定義在此 Context 中允許的操作 type State interface { Name() string Handle(ctx *Context, input any) error } // Context：持有目前狀態，對外暴露穩定 API type Context struct { state State // 共享資料（如餘額、庫存、旗標……） } func NewContext(initial State) *Context { return \u0026amp;Context{state: initial} } func (c *Context) SetState(s State) { c.state = s } func (c *Context) StateName() string { return c.state.Name() } func (c *Context) Do(input any) error { return c.state.Handle(c, input) } 註：實務上通常不是單一 Handle，而是針對每個動作開方法（如下方兩個範例）。\n範例一：Turnstile（閘門） # 狀態：Locked / Unlocked 事件：Coin()（投幣）、Push()（推門） package main import \u0026#34;fmt\u0026#34; // ==== Context ==== type Turnstile struct { state TurnstileState } func NewTurnstile() *Turnstile { t := \u0026amp;Turnstile{} t.SetState(\u0026amp;Locked{}) // 初始為上鎖 return t } func (t *Turnstile) SetState(s TurnstileState) { t.state = s } func (t *Turnstile) StateName() string { return t.state.Name() } func (t *Turnstile) Coin() { t.state.Coin(t) } func (t *Turnstile) Push() { t.state.Push(t) } // ==== State ==== type TurnstileState interface { Name() string Coin(t *Turnstile) Push(t *Turnstile) } type Locked struct{} func (Locked) Name() string { return \u0026#34;Locked\u0026#34; } func (Locked) Coin(t *Turnstile) { fmt.Println(\u0026#34;Coin accepted → unlock\u0026#34;) t.SetState(\u0026amp;Unlocked{}) } func (Locked) Push(t *Turnstile) { fmt.Println(\u0026#34;Blocked. Insert coin first.\u0026#34;) } type Unlocked struct{} func (Unlocked) Name() string { return \u0026#34;Unlocked\u0026#34; } func (Unlocked) Coin(t *Turnstile) { fmt.Println(\u0026#34;Already unlocked; coin returned\u0026#34;) } func (Unlocked) Push(t *Turnstile) { fmt.Println(\u0026#34;Pushed → lock again\u0026#34;) t.SetState(\u0026amp;Locked{}) } func main() { ts := NewTurnstile() fmt.Println(\u0026#34;State:\u0026#34;, ts.StateName()) ts.Push() // 不能推 ts.Coin() // 投幣解鎖 fmt.Println(\u0026#34;State:\u0026#34;, ts.StateName()) ts.Coin() // 已解鎖，再投退幣 ts.Push() // 推門、回到 Locked fmt.Println(\u0026#34;State:\u0026#34;, ts.StateName()) } 要點\n每個狀態自己決定事件的結果與下一個狀態。 Context 干淨、無 if state==...。 範例二：販賣機（含共享資料、錯誤處理） # 需求：\n狀態：Idle（待機）、HasMoney（已投幣）、Dispensing（出貨） 共享資料：balance（餘額）、stock（庫存） 動作：Insert(amount), Select(item), Refund() package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // ==== Context ==== type VendingMachine struct { state VMState balance int stock int price int } func NewVM(stock, price int) *VendingMachine { vm := \u0026amp;VendingMachine{stock: stock, price: price} vm.SetState(\u0026amp;Idle{}) return vm } func (v *VendingMachine) SetState(s VMState) { v.state = s } func (v *VendingMachine) StateName() string { return v.state.Name() } func (v *VendingMachine) Insert(amount int) error { return v.state.Insert(v, amount) } func (v *VendingMachine) Select() error { return v.state.Select(v) } func (v *VendingMachine) Refund() (int, error) { return v.state.Refund(v) } // ==== State 介面 ==== type VMState interface { Name() string Insert(v *VendingMachine, amount int) error Select(v *VendingMachine) error Refund(v *VendingMachine) (int, error) } // ==== Concrete States ==== type Idle struct{} func (Idle) Name() string { return \u0026#34;Idle\u0026#34; } func (Idle) Insert(v *VendingMachine, amount int) error { if v.stock \u0026lt;= 0 { return errors.New(\u0026#34;sold out\u0026#34;) } v.balance += amount fmt.Println(\u0026#34;Insert:\u0026#34;, amount, \u0026#34;=\u0026gt; balance:\u0026#34;, v.balance) v.SetState(\u0026amp;HasMoney{}) return nil } func (Idle) Select(v *VendingMachine) error { return errors.New(\u0026#34;insert money first\u0026#34;) } func (Idle) Refund(v *VendingMachine) (int, error) { if v.balance == 0 { return 0, nil } amt := v.balance v.balance = 0 return amt, nil } type HasMoney struct{} func (HasMoney) Name() string { return \u0026#34;HasMoney\u0026#34; } func (HasMoney) Insert(v *VendingMachine, amount int) error { v.balance += amount fmt.Println(\u0026#34;Insert:\u0026#34;, amount, \u0026#34;=\u0026gt; balance:\u0026#34;, v.balance) return nil } func (HasMoney) Select(v *VendingMachine) error { if v.stock \u0026lt;= 0 { return errors.New(\u0026#34;sold out\u0026#34;) } if v.balance \u0026lt; v.price { return fmt.Errorf(\u0026#34;need %d more\u0026#34;, v.price - v.balance) } // 轉 Dispensing v.SetState(\u0026amp;Dispensing{}) return v.state.Select(v) // 由 Dispensing 執行出貨 } func (HasMoney) Refund(v *VendingMachine) (int, error) { amt := v.balance v.balance = 0 v.SetState(\u0026amp;Idle{}) return amt, nil } type Dispensing struct{} func (Dispensing) Name() string { return \u0026#34;Dispensing\u0026#34; } func (Dispensing) Insert(v *VendingMachine, _ int) error { return errors.New(\u0026#34;busy dispensing\u0026#34;) } func (Dispensing) Select(v *VendingMachine) error { // 出貨 v.balance -= v.price v.stock-- fmt.Printf(\u0026#34;Dispense 1 item. stock=%d, balance=%d\\n\u0026#34;, v.stock, v.balance) // 出貨後：若還有餘額 → 回到 HasMoney；否則回 Idle if v.balance \u0026gt; 0 { v.SetState(\u0026amp;HasMoney{}) } else { v.SetState(\u0026amp;Idle{}) } return nil } func (Dispensing) Refund(v *VendingMachine) (int, error) { return 0, errors.New(\u0026#34;busy dispensing\u0026#34;) } func main() { vm := NewVM(2, 10) fmt.Println(\u0026#34;State:\u0026#34;, vm.StateName()) _ = vm.Insert(5) // 餘額不足 if err := vm.Select(); err != nil { fmt.Println(\u0026#34;Select:\u0026#34;, err) } _ = vm.Insert(10) // 餘額 15 _ = vm.Select() // 出貨，餘額 5，狀態回 HasMoney fmt.Println(\u0026#34;State:\u0026#34;, vm.StateName()) refund, _ := vm.Refund() // 退 5，回 Idle fmt.Println(\u0026#34;Refund:\u0026#34;, refund, \u0026#34;State:\u0026#34;, vm.StateName()) // 再買一個 _ = vm.Insert(10) _ = vm.Select() // 出貨，庫存剩 0，轉 Idle fmt.Println(\u0026#34;State:\u0026#34;, vm.StateName()) if err := vm.Insert(10); err != nil { fmt.Println(\u0026#34;Insert:\u0026#34;, err) } // sold out } 重點\n狀態之間的切換內聚在 concrete state 裡：HasMoney.Select() → Dispensing → 完成後再切回。 共享資料（餘額、庫存）放在 Context，避免各 state 重複維護。 錯誤訊息由 state 決定，對外 API 穩定。 與 Strategy、表格驅動 FSM 的比較 # State vs Strategy\nStrategy：用不同策略實作同一演算法，不涉及「狀態轉移」。 State：行為 + 狀態轉移成套，呼叫某操作會導致下一個狀態（內聚轉移）。 物件導向 State vs 表格驅動（table-driven FSM）\n若狀態爆炸（很多 state × event），可用表格紀錄轉移規則；但轉移邏輯分散在 map/表格與 handler。 物件導向 State 可讀性高、貼近領域語意；表格法在狀態很多時更低耦、好產生器自動化。 table-driven 範例（簡版）\ntype StateID string type EventID string type Transition struct { From StateID Event EventID To StateID Act func(ctx *Context) error // 動作（可選） } type FSM struct { state StateID trans map[StateID]map[EventID]Transition ctx *Context } func NewFSM(initial StateID, transitions []Transition, ctx *Context) *FSM { tmap := map[StateID]map[EventID]Transition{} for _, tr := range transitions { if tmap[tr.From] == nil { tmap[tr.From] = map[EventID]Transition{} } tmap[tr.From][tr.Event] = tr } return \u0026amp;FSM{state: initial, trans: tmap, ctx: ctx} } func (f *FSM) Send(ev EventID) error { row := f.trans[f.state] tr, ok := row[ev] if !ok { return fmt.Errorf(\u0026#34;invalid %s on %s\u0026#34;, ev, f.state) } if tr.Act != nil { if err := tr.Act(f.ctx); err != nil { return err } } f.state = tr.To return nil } 適合：規則由配置檔/資料驅動、或需圖形化工具生成轉移表。\n併發與實務建議（Go 特別版） # 狀態切換的互斥\n若 Context 在多 goroutine 下被操作，必須以 sync.Mutex／RWMutex 或 atomic.Value 保護「讀/寫 state 與共享資料」。 避免在持鎖期間做「外部阻塞行為」（I/O、callback）→ 先計算轉移、釋鎖後執行副作業。 不可重入（reentrancy）\n某些 state 方法呼叫另一個會觸發 re-enter，容易亂序；可用事件佇列（channel）序列化。 狀態爆炸時的拆分\n依「領域子流程」分多個 Context/子 FSM；或把驗證/副作用抽為 Strategy/Policy 注入 State。 測試\n對每個 state 的每個事件驗證：狀態轉移 + 副作用（餘額/庫存/日誌）。 用假件（fake）取代外部資源（儲存、通知）。 什麼時候選 State？ # 同一 Context 的動作，因狀態不同而行為截然不同。 常見複雜分支遍布多處；你想把它集中、語意化。 需要自然地「呼叫 → 觸發轉移」並可擴充新狀態。 一句話總結 # State 模式讓「行為」與「狀態轉移」同處一室，Context 專心轉送請求； 在 Go 裡，善用介面拆分與共享資料放 Context，配合互斥控制，就能寫出可讀、可測、好擴充的狀態導向程式。\n","date":"2025-09-04","externalUrl":null,"permalink":"/docs/state-with-go/","section":"All my post","summary":"State with Go","title":"State with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/strategy/","section":"Tags","summary":"","title":"Strategy","type":"tags"},{"content":"下面用「繁體中文 + Golang」帶你一次搞懂 Strategy（策略）模式：何時用、怎麼設計、跟其它行為型模式的差異，以及多種實戰範例（含可單元測試的寫法、介面版／函式版、泛型版）。\nStrategy 是什麼？ # Strategy（策略）把「演算法/行為」抽離成可替換的物件，在執行期能切換不同策略而不改動呼叫端邏輯。 關鍵點：\n將「變化的部分（演算法）」以介面抽象，將「不變的部分（流程/脈絡）」固定在 Context。 新增策略＝新增類型，不動既有呼叫碼 → 開放封閉原則（OCP）。 簡化結構（ASCII）：\nClient -\u0026gt; Context ----\u0026gt; Strategy (interface) / | \\ ConcreteA | ConcreteC B 什麼時候用？ # 同一種「目標功能」有多種算法（例如：定價方案、排序比較器、重試退避、壓縮/加密、快取淘汰策略）。 你希望以組態/參數來切換行為，而不是用一堆 if/else 或 switch。 你要對演算法做A/B 測試、灰度發布或動態選路。 範例 1：電商折扣策略（典型介面實作） # 介面與 Context # package pricing // Strategy：定義折扣演算法介面 type DiscountStrategy interface { Discount(original int64) int64 // 傳回折扣後的價格（單位：分/cent） } // Context：固定購物/結帳流程，注入策略 type Checkout struct { strategy DiscountStrategy } // 可在建構時注入，也可提供 setter 讓執行期切換 func NewCheckout(s DiscountStrategy) *Checkout { return \u0026amp;Checkout{strategy: s} } func (c *Checkout) SetStrategy(s DiscountStrategy) { c.strategy = s } func (c *Checkout) Pay(original int64) int64 { if c.strategy == nil { // 預設不打折 return original } return c.strategy.Discount(original) } 幾個策略 # package pricing type NoDiscount struct{} func (NoDiscount) Discount(original int64) int64 { return original } type PercentageOff struct{ Percent int } // e.g. 20% off func (p PercentageOff) Discount(original int64) int64 { if p.Percent \u0026lt;= 0 { return original } return original * int64(100-p.Percent) / 100 } type ThresholdMinus struct { // 滿額折 Threshold int64 // 門檻 Minus int64 // 直減 } func (t ThresholdMinus) Discount(original int64) int64 { if original \u0026gt;= t.Threshold { if original - t.Minus \u0026gt; 0 { return original - t.Minus } return 0 } return original } 使用與測試 # package pricing_test import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/your/module/pricing\u0026#34; ) func TestCheckout(t *testing.T) { c := pricing.NewCheckout(pricing.NoDiscount{}) if got := c.Pay(10000); got != 10000 { t.Fatalf(\u0026#34;want 10000 got %d\u0026#34;, got) } c.SetStrategy(pricing.PercentageOff{Percent: 20}) if got := c.Pay(10000); got != 8000 { t.Fatalf(\u0026#34;want 8000 got %d\u0026#34;, got) } c.SetStrategy(pricing.ThresholdMinus{Threshold: 5000, Minus: 1200}) if got := c.Pay(10000); got != 8800 { t.Fatalf(\u0026#34;want 8800 got %d\u0026#34;, got) } } 亮點\n新增策略類型即可擴充；Context 與呼叫端不變。 可搭配 DI/組態在執行期決定策略。 範例 2：用「函式就是策略」（更地道的 Go 寫法） # Go 函式是一等公民，可直接把策略寫成函式型別，減少樣板碼。\npackage retry import ( \u0026#34;math\u0026#34; \u0026#34;time\u0026#34; ) type Backoff func(attempt int) time.Duration // 第幾次重試 -\u0026gt; 等待多久 func NoBackoff(int) time.Duration { return 0 } func FixedBackoff(d time.Duration) Backoff { return func(int) time.Duration { return d } } func ExponentialBackoff(base time.Duration, factor float64) Backoff { return func(attempt int) time.Duration { return time.Duration(float64(base) * math.Pow(factor, float64(attempt-1))) } } // Context: 執行可重試的操作 func DoWithRetry(op func() error, attempts int, b Backoff) error { if b == nil { b = NoBackoff } var err error for i := 1; i \u0026lt;= attempts; i++ { if err = op(); err == nil { return nil } time.Sleep(b(i)) } return err } 優點：不用定義介面/結構；寫起來快；單元測試更容易替換行為。 缺點：若策略需要維護狀態（例如：根據歷史結果動態調整），結構體+介面會更清晰。\n範例 3：泛型 + 比較器策略（定製排序） # 在 Go 1.18+ 可用泛型把 Comparator 變成策略：\npackage gsort import \u0026#34;slices\u0026#34; // Comparator：a \u0026lt; b 回傳 true（上升序用） type LessFunc[T any] func(a, b T) bool func SortBy[T any](xs []T, less LessFunc[T]) { slices.SortFunc(xs, func(a, b T) int { switch { case less(a, b): return -1 case less(b, a): return 1 default: return 0 } }) } 使用：\ntype User struct{ ID int; Name string; Score int } users := []User{{1,\u0026#34;Amy\u0026#34;,80},{2,\u0026#34;Bob\u0026#34;,95},{3,\u0026#34;Zo\u0026#34;,95}} // 依 Score DESC，再依 Name ASC gsort.SortBy(users, func(a, b User) bool { if a.Score != b.Score { return a.Score \u0026gt; b.Score } return a.Name \u0026lt; b.Name }) 這其實就是排序策略（比較器）注入。\n範例 4：策略工廠 + 組態選擇（與 DI/設定整合） # package factory import \u0026#34;fmt\u0026#34; type Strategy interface{ Do(input string) string } type upper struct{} func (upper) Do(s string) string { return strings.ToUpper(s) } type suffix struct{ S string } func (s suffix) Do(x string) string { return x + s.S } func NewStrategy(kind string, args map[string]any) (Strategy, error) { switch kind { case \u0026#34;upper\u0026#34;: return upper{}, nil case \u0026#34;suffix\u0026#34;: s, _ := args[\u0026#34;s\u0026#34;].(string) return suffix{S: s}, nil default: return nil, fmt.Errorf(\u0026#34;unknown strategy: %s\u0026#34;, kind) } } 用途：把策略的選擇外移到 YAML/ENV/Flag；部署時不用改碼，只調設定。\n與其它模式的差異 # Strategy vs. State 兩者都包裝行為。State會根據「內部狀態轉移」自動切換策略（行為），多用於有限狀態機；Strategy通常由外部選擇或組態決定，演算法之間平行無狀態轉移。\nStrategy vs. Template Method Template用繼承/步驟骨架固定流程，由子類覆寫局部步驟；Strategy用組合注入整個演算法物件，Go 更偏好 Strategy（因為沒傳統 OOP 繼承）。\nStrategy vs. Policy/Bridge Policy 常是 Strategy 的同義詞。Bridge 著重抽象與實作分離，解決多維度變化；Strategy 偏演算法替換。\n測試、可觀測性與併發 # 測試：\n介面策略：以假物件（stub）替換策略，檢驗 Context 的邏輯。 函式策略：傳入 lambda，直接控制回傳值與副作用，測試更輕巧。 可觀測性：\n用裝飾器為策略加上 log/metrics（計時、錯誤率）；或在 Context 外層包一層「觀測策略」。 併發：\n策略若有可變狀態，務必保護（如 sync.Mutex）或設計成無狀態/不可變物件（推薦）。 在高併發路徑避免大量小物件分配，可用池化或讓策略為單例（只要無狀態）。 常見陷阱與實務建議 # 策略過度細分：切太碎會讓呼叫端組裝成本上升；以演算法維度而非步驟來劃分。\n介面膨脹：Strategy 介面要小而穩定；需要多個輸入就弄一個 Context struct 帶參數，避免介面頻繁變更。\n隱性耦合：策略彼此之間不要互相知道；若要共用資料，用只讀依賴（如設定值）或由外層注入。\n效能：\n介面呼叫有動態派發成本，但 Go 很小，多半可忽略。熱路徑可考慮函式策略或 //go:nosplit 等極端優化（通常不需要）。 函式策略在 hot path 中會更輕量些（少一層方法值/iface 開銷）。 可滾動升級：策略新增不動主流程，可搭配**特性旗標（feature flag）**做灰度切換。\n速查清單（Cheat Sheet） # 介面版本（面向物件、可帶狀態）\n定義 Strategy 介面 實作多個策略結構體 Context 內持有 Strategy，對外只暴露高階方法 支援 setter/建構子注入以便執行期切換 函式版本（Go 風格、輕量）\n定義 type Strategy func(...) ... 提供幾個策略工廠（回傳函式） Context 接受該函式並在流程中呼叫 泛型版本（容器/排序/比對）\n定義 LessFunc[T] / EqualFunc[T] 在泛型演算法中注入比較策略 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/strategy-with-go/","section":"All my post","summary":"Strategy with Go","title":"Strategy with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/template-method/","section":"Tags","summary":"","title":"Template Method","type":"tags"},{"content":"來一次把 Template Method（模板方法） 用「繁中＋ Golang」講透：概念、什麼時候用、在 Go（沒有繼承）的實作技巧（介面版／嵌入版／函式鉤子版／泛型版），加上可直接跑的程式範例與測試重點。\n是什麼？為何用？ # Template Method：在父類（Go 沒有傳統繼承，等下用替代法）定義演算法骨架（固定步驟順序），把某些可變步驟交給子類/子型別去實作（稱為鉤子 Hook）。 好處：\n流程（步驟順序）一致、可重用；變動只發生在局部步驟。 滿足 好萊塢原則（別呼叫我，我會呼叫你）：框架掌控流程，具體實作只提供掛鉤。 典型場景：ETL、檔案輸出流程、HTTP 請求處理管線、交易/訂單處理、工作流引擎的一致步驟＋可擴充細節。\n與 Strategy 比：Template固定流程＋換步驟；Strategy是整個演算法可替換。\nGo 沒繼承，怎麼做 Template？ # 常見 3 招：\n介面 + 上下文（Context）： Context 寫死流程，介面定義鉤子。具體型別實作介面 → 最直覺、型別安全。\n結構體嵌入（Embedding）+ 可選覆寫： 用一個 Base 結構體持有函式欄位（或小介面），子型別嵌入它，視需要覆寫函式欄位 → 常見於需要少量可覆寫點。\n函式鉤子（Functions as hooks）： 一個 Run(opts Hooks) 的模板方法，Hooks 是一組可選函式欄位 → Go 風格、輕量、超好測試。\n下面給你三個實戰版。\n範例一：資料匯出流程（介面 + Context 版） # 需求：固定流程 Validate -\u0026gt; Transform -\u0026gt; Write -\u0026gt; AfterWrite，不同匯出器（CSV/JSON）實作細節。\npackage exporter import ( \u0026#34;encoding/csv\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;io\u0026#34; ) // ---- Template 的「鉤子介面」 ---- type Exporter interface { Validate([]map[string]any) error Transform([]map[string]any) ([]byte, error) Write(w io.Writer, payload []byte) error AfterWrite(count int) error // 可做收尾/記錄 } // ---- Template 的「固定流程」 ---- type Pipeline struct { impl Exporter } func NewPipeline(e Exporter) *Pipeline { return \u0026amp;Pipeline{impl: e} } // Template Method：固定步驟順序 func (p *Pipeline) Run(w io.Writer, rows []map[string]any) (int, error) { if err := p.impl.Validate(rows); err != nil { return 0, err } payload, err := p.impl.Transform(rows) if err != nil { return 0, err } if err := p.impl.Write(w, payload); err != nil { return 0, err } if err := p.impl.AfterWrite(len(rows)); err != nil { return 0, err } return len(rows), nil } // ---- 兩個具體 Exporter：CSV 與 JSON ---- type CSVExporter struct{ Headers []string } func (c CSVExporter) Validate(rows []map[string]any) error { if len(c.Headers) == 0 { return errors.New(\u0026#34;headers required\u0026#34;) } return nil } func (c CSVExporter) Transform(rows []map[string]any) ([]byte, error) { // 先轉成 [][]string，再由 Write 寫（也可在 Write 才輸出） buf := \u0026amp;bytes.Buffer{} w := csv.NewWriter(buf) if err := w.Write(c.Headers); err != nil { return nil, err } for _, r := range rows { record := make([]string, len(c.Headers)) for i, h := range c.Headers { if v, ok := r[h]; ok { record[i] = fmt.Sprint(v) } } if err := w.Write(record); err != nil { return nil, err } } w.Flush() return buf.Bytes(), w.Error() } func (c CSVExporter) Write(w io.Writer, payload []byte) error { _, err := w.Write(payload); return err } func (c CSVExporter) AfterWrite(count int) error { return nil } type JSONExporter struct{} func (JSONExporter) Validate(rows []map[string]any) error { return nil } func (JSONExporter) Transform(rows []map[string]any) ([]byte, error) { return json.Marshal(rows) } func (JSONExporter) Write(w io.Writer, payload []byte) error { _, err := w.Write(payload); return err } func (JSONExporter) AfterWrite(count int) error { return nil } 用法/測試片段\nrows := []map[string]any{{\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;Amy\u0026#34;},{\u0026#34;id\u0026#34;:2,\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;}} csvPipe := exporter.NewPipeline(exporter.CSVExporter{Headers: []string{\u0026#34;id\u0026#34;,\u0026#34;name\u0026#34;}}) buf := \u0026amp;bytes.Buffer{} n, _ := csvPipe.Run(buf, rows) // buf.String() 取得 CSV 內容；n == 2 jsonPipe := exporter.NewPipeline(exporter.JSONExporter{}) buf2 := \u0026amp;bytes.Buffer{} _, _ = jsonPipe.Run(buf2, rows) // buf2.Bytes() 是 JSON 亮點：\n流程固定、實作替換；新增 XML 只需寫新 Exporter，不動 Pipeline.Run。 範例二：HTTP 請求處理骨架（嵌入 + 可覆寫鉤子） # 需求：所有處理器共用「前處理 → 核心處理 → 後處理」，個別路由可覆寫部分鉤子。\npackage webtmpl import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) type BaseHandler struct { // 可覆寫的鉤子（皆為可選） Before func(w http.ResponseWriter, r *http.Request) error Handle func(w http.ResponseWriter, r *http.Request) error // required After func(w http.ResponseWriter, r *http.Request, err error) } func (h BaseHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { start := time.Now() if h.Before != nil { if err := h.Before(w, r); err != nil { http.Error(w, \u0026#34;bad request\u0026#34;, http.StatusBadRequest) if h.After != nil { h.After(w, r, err) } return } } var err error if h.Handle != nil { err = h.Handle(w, r) } else { err = fmt.Errorf(\u0026#34;Handle not set\u0026#34;) http.Error(w, \u0026#34;internal\u0026#34;, http.StatusInternalServerError) } if h.After != nil { h.After(w, r, err) } else { if err != nil { log.Printf(\u0026#34;error: %v\u0026#34;, err) } } _ = start // 可計時、打 metrics } // 具體路由：覆寫 Before/After func NewUserHandler() http.Handler { h := BaseHandler{ Before: func(w http.ResponseWriter, r *http.Request) error { if r.Header.Get(\u0026#34;X-Token\u0026#34;) == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;no token\u0026#34;) } return nil }, Handle: func(w http.ResponseWriter, r *http.Request) error { w.Write([]byte(`{\u0026#34;ok\u0026#34;:true}`)) return nil }, After: func(w http.ResponseWriter, r *http.Request, err error) { if err != nil { log.Printf(\u0026#34;user handler err: %v\u0026#34;, err) } }, } return h } 說明：\nServeHTTP 就是 Template Method：固定順序；Before/Handle/After 是鉤子。 新增路由只要提供不同的鉤子函式，不會破壞全局流程一致性。 範例三：ETL/工作流骨架（函式鉤子版，極輕量） # 需求：資料處理流程固定：讀 → 處理 → 寫；鉤子用函式欄位，測試超好寫。\npackage flow type Hooks[T any, U any] struct { Before func() error Read func() ([]T, error) // required Process func([]T) ([]U, error) // required Write func([]U) error // required After func(err error) error } func Run[T any, U any](h Hooks[T, U]) error { if h.Read == nil || h.Process == nil || h.Write == nil { return fmt.Errorf(\u0026#34;missing required hooks\u0026#34;) } if h.Before != nil { if err := h.Before(); err != nil { return err } } rows, err := h.Read() if err != nil { if h.After != nil { _ = h.After(err) } return err } out, err := h.Process(rows) if err != nil { if h.After != nil { _ = h.After(err) } return err } err = h.Write(out) if h.After != nil { _ = h.After(err) } return err } 使用\nerr := flow.Run(flow.Hooks[int,string]{ Read: func() ([]int, error) { return []int{1,2,3}, nil }, Process: func(xs []int) ([]string, error) { out := make([]string, len(xs)) for i, v := range xs { out[i] = fmt.Sprintf(\u0026#34;v=%d\u0026#34;, v) } return out, nil }, Write: func(ss []string) error { fmt.Println(strings.Join(ss, \u0026#34;,\u0026#34;)) return nil }, }) 優點：最少樣板、擴充快、單測容易注入假鉤子。 缺點：少了明確型別階層（但在 Go 常常更實用）。\n測試建議 # 流程不變性：為 Template Method 寫一個序列探針（把每一步 push 到 slice）驗證順序不變。 錯誤路徑：分別在 Before/Transform/Write/After 注入錯誤，檢查是否短路與資源釋放正確。 替身鉤子：函式版直接傳匿名函式；介面版做 fake exporter；嵌入版替換函式欄位。 何時用／不該用 # 適合：\n你的流程步驟固定、各步細節常需要客製（跨多實作共享一份流程）。 想要「框架式用法」：團隊統一骨架、降低重複與不一致。 不適合：\n流程本身也常變（那更像 Strategy/Chain-of-Responsibility/Policy 組合）。 步驟之間耦合很弱、只是幾個工具函式 → 一般 helper 更直白。 與其它模式速比 # Template vs Strategy：Template 固定流程、開放步驟；Strategy 替換整個演算法。 Template vs Hook（框架用語）：Hook 是 Template 的具體手段；前者是一個設計模式名，後者強調擴充點。 Template vs Chain of Responsibility：Chain 是「可中斷的串接處理」，流程長度/順序可動；Template 的步驟與順序固定。 小結（Go 實作心法） # 優先介面 + Context：清楚、強型別。 需要彈性就用函式鉤子：少樣板、超好測試。 嵌入覆寫：當你希望提供預設行為並允許少量覆寫時最好用。 保持鉤子小而單一職責，必要時在鉤子裡再組合 Strategy/Decorator 做到乾淨可測。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/template-method-with-go/","section":"All my post","summary":"Template method with Go","title":"Template method with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/tags/visitor/","section":"Tags","summary":"","title":"Visitor","type":"tags"},{"content":"下面用「繁體中文＋ Golang」帶你一次吃透 Visitor（訪問者）模式：動機、結構、什麼時候用、在 Go 的實作要點（含經典雙重派發、Acyclic Visitor、函式版）、以及容易踩的坑與測試建議。\nVisitor 是什麼？為何需要？ # **Visitor（訪問者）把「對一組既有資料結構（元素階層）**的各種操作」抽離成獨立物件（訪問者）。 核心交換：\n易增訪問者（新增一種操作很容易） 難增元素型別（加新節點類型要改所有訪問者） 典型應用：\n編譯器/直譯器中的 AST 走訪（計算值、印成字串、產生位元碼）。 複雜樹狀物件（檔案系統、GUI 元件樹、圖形場景）上的多種操作（面積/周長/匯出/渲染/驗證/權限檢查）。 報表系統在既有模型上做不同聚合/輸出格式。 經典結構（雙重派發 / Double Dispatch） # Go 沒有多型方法多載，但可用「介面 + 每個具體元素各有一個 Visit 方法」達成雙重派發。\nVisitor 介面：VisitXxx(*Xxx) Element 介面：Accept(Visitor) Client -\u0026gt; Element.Accept(v) -\u0026gt; v.VisitConcreteElement(e) 範例 1：Shape 元素樹（Area / Perimeter 訪問者） # package shape // --- Elements --- type Element interface { Accept(v Visitor) } type Circle struct{ R float64 } func (c *Circle) Accept(v Visitor) { v.VisitCircle(c) } type Rect struct{ W, H float64 } func (r *Rect) Accept(v Visitor) { v.VisitRect(r) } // --- Visitor --- type Visitor interface { VisitCircle(*Circle) VisitRect(*Rect) } // AreaVisitor：計算面積 type AreaVisitor struct{ Area float64 } func (a *AreaVisitor) VisitCircle(c *Circle) { a.Area += 3.1415926535 * c.R * c.R } func (a *AreaVisitor) VisitRect(r *Rect) { a.Area += r.W * r.H } // PerimeterVisitor：計算周長 type PerimeterVisitor struct{ Sum float64 } func (p *PerimeterVisitor) VisitCircle(c *Circle) { p.Sum += 2 * 3.1415926535 * c.R } func (p *PerimeterVisitor) VisitRect(r *Rect) { p.Sum += 2 * (r.W + r.H) } 使用：\ns := []shape.Element{ \u0026amp;shape.Circle{R: 2}, \u0026amp;shape.Rect{W: 3, H: 4}, } area := \u0026amp;shape.AreaVisitor{} peri := \u0026amp;shape.PerimeterVisitor{} for _, e := range s { e.Accept(area) e.Accept(peri) } // area.Area, peri.Sum 即為結果 重點\n新增訪問者（例如 ExportVisitor、ValidateVisitor）→ 不動元素結構。 若新增元素（例如 Triangle），所有訪問者都要補 VisitTriangle（缺點）。 範例 2：AST 訪問（Eval / Print） # AST 是 Visitor 的經典場景：節點種類固定（Binary/Number/Unary…），但操作很多（求值、印字串、類型檢查、最佳化…）。\npackage ast // --- Elements (AST Nodes) --- type Node interface{ Accept(v Visitor) } type Num struct{ V int } func (n *Num) Accept(v Visitor) { v.VisitNum(n) } type Add struct{ L, R Node } func (a *Add) Accept(v Visitor) { v.VisitAdd(a) } type Mul struct{ L, R Node } func (m *Mul) Accept(v Visitor) { v.VisitMul(m) } // --- Visitor --- type Visitor interface { VisitNum(*Num) VisitAdd(*Add) VisitMul(*Mul) } // EvalVisitor：計算值 type EvalVisitor struct{ stack []int } func (e *EvalVisitor) push(x int) { e.stack = append(e.stack, x) } func (e *EvalVisitor) pop() int { v := e.stack[len(e.stack)-1]; e.stack = e.stack[:len(e.stack)-1]; return v } func (e *EvalVisitor) VisitNum(n *Num) { e.push(n.V) } func (e *EvalVisitor) VisitAdd(a *Add) { a.L.Accept(e); a.R.Accept(e) r, l := e.pop(), e.pop() e.push(l + r) } func (e *EvalVisitor) VisitMul(m *Mul) { m.L.Accept(e); m.R.Accept(e) r, l := e.pop(), e.pop() e.push(l * r) } func (e *EvalVisitor) Result() int { return e.stack[0] } // PrintVisitor：印成中序字串（含括號） type PrintVisitor struct{ buf []byte } func (p *PrintVisitor) write(s string){ p.buf = append(p.buf, s...) } func (p *PrintVisitor) String() string { return string(p.buf) } func (p *PrintVisitor) VisitNum(n *Num) { p.write(fmt.Sprintf(\u0026#34;%d\u0026#34;, n.V)) } func (p *PrintVisitor) VisitAdd(a *Add) { p.write(\u0026#34;(\u0026#34;); a.L.Accept(p); p.write(\u0026#34; + \u0026#34;); a.R.Accept(p); p.write(\u0026#34;)\u0026#34;) } func (p *PrintVisitor) VisitMul(m *Mul) { p.write(\u0026#34;(\u0026#34;); m.L.Accept(p); p.write(\u0026#34; * \u0026#34;); m.R.Accept(p); p.write(\u0026#34;)\u0026#34;) } 使用：\nexpr := \u0026amp;ast.Add{ // (2 + 3) * 4 L: \u0026amp;ast.Add{L: \u0026amp;ast.Num{2}, R: \u0026amp;ast.Num{3}}, R: \u0026amp;ast.Mul{L: \u0026amp;ast.Num{4}, R: \u0026amp;ast.Num{1}}, } ev := \u0026amp;ast.EvalVisitor{} expr.Accept(ev) _ = ev.Result() // -\u0026gt; 10 pv := \u0026amp;ast.PrintVisitor{} expr.Accept(pv) _ = pv.String() // -\u0026gt; \u0026#34;((2 + 3) + (4 * 1))\u0026#34; Acyclic Visitor（去耦版）：用 type switch 避免方法膨脹 # 若元素種類很多、但某些訪問者只關心其中幾個型別，可用「單一 Visit(any) + type switch」：不必為每個元素都定義方法。\ntype Element interface{ Accept(v Visitor) } type Visitor interface{ Visit(any) } // 單一入口 type File struct{ Name string; Size int64 } func (f *File) Accept(v Visitor){ v.Visit(f) } type Dir struct{ Name string; Children []Element } func (d *Dir) Accept(v Visitor){ v.Visit(d) } // 只關心 File 的訪問者 type TotalSize struct{ Sum int64 } func (t *TotalSize) Visit(x any) { switch n := x.(type) { case *File: t.Sum += n.Size case *Dir: for _, c := range n.Children { c.Accept(t) } } } 取捨\n✅ 避免為每個元素都在 Visitor 上開一個方法（減少介面爆炸）。 ❌ 失去編譯期型別保證（type switch 若漏寫，可能靜默忽略）。 函式即訪問者（Go 風格） # 若你只是要「走訪元素並執行一段操作」，可以把 Visitor 壓縮成函式型別。\ntype WalkFunc func(e Element) func Walk(e Element, f WalkFunc) { switch n := e.(type) { case *File: f(n) case *Dir: f(n) for _, c := range n.Children { Walk(c, f) } } } // 用法：計數、搜尋、過濾、收集都很方便 count := 0 Walk(root, func(e Element) { if _, ok := e.(*File); ok { count++ } }) 優點：極簡、可讀；缺點：不具完整的 Visitor 結構性與可擴充性（但常常已足夠）。\n在 Go 的實務建議 # 封裝與套件邊界\n若元素型別（AST/樹）相對穩定，且操作常變 → 用經典 Visitor。 若元素型別常新增 → 慎用，因為要改所有訪問者。可改走 type switch / acyclic 或多方法組合。 指標 vs 值\n多半用 指標：避免拷貝、允許訪問者調整狀態（若你允許變更）。 只讀訪問者則可仍用指標，但不要修改內容。 不可變 or 可變\n純讀取（計算、輸出、驗證）→ 不要改元素狀態，避免副作用。 轉換訪問者（如 AST Best-Practice：回傳新樹）→ 可改為 VisitXxx(*Xxx) Node 的風格，或建立 Builder。 錯誤處理\n訪問者內可能需要傳遞錯誤，可在 Visitor 結構體上有 Err error 欄位；或讓 Accept 回傳 error（但就要改介面）。 效能\n介面呼叫成本通常可忽略；超熱路徑考量扁平化、快取、或函式訪問者。 避免在走訪中產生大量臨時物件（重複使用 buffer/stack）。 測試\n每個 Visitor 用小型樹測邊界情況（空節點、深度、巨量子節點）。 Snapshot/Golden 測試對 Print/Export 類訪問者很好用。 Fuzz 測試可找型別分支遺漏。 與其它模式對比 # Visitor vs. Strategy：兩者都抽離行為。Visitor 著重「在既有元素樹上新增操作」；Strategy 著重「替換演算法」。 Visitor vs. Composite：常一起使用。Composite 形成樹；Visitor 定義在樹上執行的操作。 Visitor vs. Iterator：Iterator 管 traversal；Visitor 管在每個節點上執行的「動作」。兩者可搭配（先 iterator 取序列，再對每個元素做 visitor）。 小型測試範例（以 Shape 為例） # package shape_test import ( \u0026#34;testing\u0026#34; \u0026#34;example.com/shape\u0026#34; ) func TestAreaPerimeter(t *testing.T) { shapes := []shape.Element{ \u0026amp;shape.Circle{R: 2}, \u0026amp;shape.Rect{W: 3, H: 4}, } area := \u0026amp;shape.AreaVisitor{} peri := \u0026amp;shape.PerimeterVisitor{} for _, e := range shapes { e.Accept(area) e.Accept(peri) } if area.Area != 3.1415926535*4 + 12 { t.Fatalf(\u0026#34;area mismatch: %v\u0026#34;, area.Area) } if peri.Sum \u0026lt; 2*3.1415926535*2+14-1e-9 || peri.Sum \u0026gt; 2*3.1415926535*2+14+1e-9 { t.Fatalf(\u0026#34;perimeter mismatch: %v\u0026#34;, peri.Sum) } } 何時不要用 Visitor？ # 元素型別變動頻繁（每加一種節點就得改所有訪問者）。 結構很扁平、操作很少，用簡單的 switch type 更直接。 只需要一次性操作；寫一個 helper 函式就好。 速查清單（Cheat Sheet） # 元素介面：Accept(v Visitor) 訪問者介面：VisitXxx(*Xxx)（雙重派發） 優先在「節點型別穩定、操作常新增」的系統使用（AST、模型匯出/校驗）。 Go 的替代：Acyclic Visitor（單一 Visit + type switch）、函式訪問者，可讓開發更輕盈。 ","date":"2025-09-04","externalUrl":null,"permalink":"/docs/visitor-with-go/","section":"All my post","summary":"Visitor with Go","title":"Visitor with Go","type":"docs"},{"content":"","date":"2025-09-04","externalUrl":null,"permalink":"/authors/wz-chen/","section":"Authors","summary":"","title":"WZ Chen","type":"authors"},{"content":"Leetcode link : Balanced Binary Tree 思路 # 判斷對稱二元樹要比較的是哪兩個節點，要比較的不是左右節點！\n對於二元樹是否對稱，要比較的是根節點的左子樹與右子樹是不是相互翻轉的\n在遞歸遍歷的過程中，也是要同時遍兩棵樹\n只能是 後序遍歷，因為我們要透過遞歸函數的返回值來判斷兩個子樹的內側節點和外側節點是否相等\n要比較內側和外側節點 -\u0026gt; 遍歷順序是左右中\n遞迴法\n確定遞歸函數的參數和返回值 要比較的是根節點的兩個子樹是否是互相翻轉的 -\u0026gt; 所以要比較的是兩個樹 -\u0026gt; 參數自然也是左子樹節點和右子樹節點。 傳回值自然是 bool 型別。 確定終止條件 要把兩個節點為空的情況弄清楚！否則後面比較數值的時候就會操作空指標了\n節點為空的情況有：\n左節點為空，右節點不為空，不對稱，return false 左不為空，右為空，不對稱 return false 左右都為空，對稱，回傳 true 確定單層遞歸的邏輯 處理 左右節點都不為空，且數值相同的情況。 比較二元樹外側是否對稱：傳入的是左節點的左孩子，右節點的右孩子。 比較內側是否對稱 -\u0026gt; 傳入左節點的右孩子，右節點的左孩子。 如果左右都對稱就回傳 true ，有一側不對稱就回傳 false 。 迭代法\n不是前中後序的迭代寫法，因為本題的本質是判斷兩個樹是否是相互翻轉的，其實已經不是所謂二元樹遍歷的前中後序的關係了。\n比較兩個樹（根節點的左右子樹）是否要互相翻轉，（注意這不是層序遍歷）\n使用 queue 使用 stack 其實是把左右兩個子樹要比較的元素順序放進一個容器，然後成對成對的取出來進行比較，那麼其實使用 stack 也是可以的。 只要把 queue 原封不動的改成 stack 就可以了 解法 # post order recursive # class Solution { public: bool compare(TreeNode* left, TreeNode* right) { // 首先排除空节点的情况 if (left == NULL \u0026amp;\u0026amp; right != NULL) return false; else if (left != NULL \u0026amp;\u0026amp; right == NULL) return false; else if (left == NULL \u0026amp;\u0026amp; right == NULL) return true; // 排除了空节点，再排除数值不相同的情况 else if (left-\u0026gt;val != right-\u0026gt;val) return false; // 此时就是：左右节点都不为空，且数值相同的情况 // 此时才做递归，做下一层的判断 bool outside = compare(left-\u0026gt;left, right-\u0026gt;right); // 左子树：左、 右子树：右 bool inside = compare(left-\u0026gt;right, right-\u0026gt;left); // 左子树：右、 右子树：左 bool isSame = outside \u0026amp;\u0026amp; inside; // 左子树：中、 右子树：中 （逻辑处理） return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root-\u0026gt;left, root-\u0026gt;right); } }; // 时间复杂度： O(n) 樹共有 n 個節點 // 空间复杂度： O(logn) 為樹高 h post order iterative with queue # class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root-\u0026gt;left); // 将左子树头结点加入队列 que.push(root-\u0026gt;right); // 将右子树头结点加入队列 while (!que.empty()) { // 接下来就要判断这两个树是否相互翻转 TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode \u0026amp;\u0026amp; !rightNode) { // 左节点为空、右节点为空，此时说明是对称的 continue; } // 左右一个节点不为空，或者都不为空但数值不相同，返回false if ((!leftNode || !rightNode || (leftNode-\u0026gt;val != rightNode-\u0026gt;val))) { return false; } que.push(leftNode-\u0026gt;left); // 加入左节点左孩子 que.push(rightNode-\u0026gt;right); // 加入右节点右孩子 que.push(leftNode-\u0026gt;right); // 加入左节点右孩子 que.push(rightNode-\u0026gt;left); // 加入右节点左孩子 } return true; } }; // 时间复杂度： O(n) // 空间复杂度： O(w) ： w 為最大寬度 介於 O(1) 與 O(n) (完全二元最底層約有 n/2 個節點)之間 post order iterative with stack # class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack\u0026lt;TreeNode*\u0026gt; st; // 这里改成了栈 st.push(root-\u0026gt;left); st.push(root-\u0026gt;right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode \u0026amp;\u0026amp; !rightNode) { continue; } if ((!leftNode || !rightNode || (leftNode-\u0026gt;val != rightNode-\u0026gt;val))) { return false; } st.push(leftNode-\u0026gt;left); st.push(rightNode-\u0026gt;right); st.push(leftNode-\u0026gt;right); st.push(rightNode-\u0026gt;left); } return true; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：最佳／平均（平衡樹: O(logn) 最壞（嚴重偏斜樹）:O(n) ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/balanced-binary-tree/","section":"All my post","summary":"Balanced Binary Tree","title":"Balanced Binary Tree","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"Leetcode link : Invert Binary Tree 描述 # 思路 # 這題目使用前序遍歷和後序遍歷都可以 唯獨中序遍歷不方便，因為中序遍歷會把某些節點的左右孩子翻轉了兩次 層序遍歷依然可以，只要把每個節點的左右孩子翻轉一下的遍歷方式都是可以的 解法 # pre order recursive # class Solution { public: TreeNode* invertTree(TreeNode* root) { // 1. 確定遞歸函數的參數和返回值 // 參數就是要傳入節點的指針，不需要其他參數了，通常此時定下來主要參數，如果在寫遞歸的邏輯中發現還需要其他參數的時候，隨時補充。 // 傳回值的話其實也不需要，但是題目中給的要回傳root節點的指針，可以直接用題目定義好的函數，所以就函數的回傳類型為TreeNode*。 if (root == NULL) return root; // 2. 確定終止條件 當前節點為空的時候，就返回 // 3. 確定單層遞歸的邏輯 前序遍歷，所以先進行交換左右孩子節點，然後反轉左子樹，反轉右子樹。 swap(root-\u0026gt;left, root-\u0026gt;right); // 中 invertTree(root-\u0026gt;left); // 左 invertTree(root-\u0026gt;right); // 右 return root; } }; // 时间复杂度： O(n) 樹共有 n 個節點 // 空间复杂度： O(logn) 為樹高 h pre order iterative # class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; stack\u0026lt;TreeNode*\u0026gt; st; st.push(root); while(!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); if(node-\u0026gt;right) st.push(node-\u0026gt;right); // 右 if(node-\u0026gt;left) st.push(node-\u0026gt;left); // 左 } return root; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：最佳／平均（平衡樹: O(logn) 最壞（嚴重偏斜樹）:O(n) level order iterative # class Solution { public: TreeNode* invertTree(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); // 节点处理 if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return root; } }; // 时间复杂度： O(n) // 空间复杂度： O(w) ： w 為最大寬度 介於 O(1) 與 O(n) (完全二元最底層約有 n/2 個節點)之間 ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/invert-binary-tree/","section":"All my post","summary":"Invert Binary Tree","title":"Invert Binary Tree","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":"Leetcode link : Maximum Depth of Binary Tree 描述 # 二元樹的深度為根節點到最遠葉子節點的最長路徑上的節點數。 說明: 葉子節點是指沒有子節點的節點。 給定二元樹 [3,9,20,null,null,15,7]，返回它的最大深度 3 思路 # 解法 # i\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-\u0026gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-\u0026gt;val); // 中 cur = cur-\u0026gt;right; // 右 } } return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/maximum-depth-of-binary-tree/","section":"All my post","summary":"Maximum Depth of Binary Tree","title":"Maximum Depth of Binary Tree","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/tree/","section":"Tags","summary":"","title":"Tree","type":"tags"},{"content":"Leetcode link : Binary Tree Inorder Traversal 解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-\u0026gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-\u0026gt;val); // 中 cur = cur-\u0026gt;right; // 右 } } return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-inorder-traversal/","section":"All my post","summary":"Binary Tree Inorder Traversal","title":"Binary Tree Inorder Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Level Order Traversal 描述 # 思路 # 佇列來實現，佇列先進先出，符合一層一層遍歷的邏輯 而用棧先進後出適合模擬深度優先遍歷也就是遞歸的邏輯。 層序遍歷方式就是圖論中的廣度優先遍歷，只不過我們應用在二元樹上。 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-\u0026gt;val); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } result.push_back(vec); } return result; } }; // 时间复杂度： O(n) 節點僅 入隊一次、出隊一次 // 空间复杂度： O(n) 佇列最壞 O(n) 平均取決於樹的最大寬度 class Solution { public: void order(TreeNode* cur, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, int depth) { if (cur == nullptr) return; if (result.size() == depth) result.push_back(vector\u0026lt;int\u0026gt;()); result[depth].push_back(cur-\u0026gt;val); order(cur-\u0026gt;left, result, depth + 1); order(cur-\u0026gt;right, result, depth + 1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int depth = 0; order(root, result, depth); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：介於 O(logn) 與 O(n) 之間 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-level-order-traversal/","section":"All my post","summary":"Binary Tree Level Order Traversal","title":"Binary Tree Level Order Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Postorder Traversal 解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 vec.push_back(cur-\u0026gt;val); // 中 } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 // 前序是中左右 因此在後序調換處理順序 // 解釋：程式邏輯是中 左右，但左右是進去 stack 因此出來就會變成先處理右再處理左， // 因此就會是中 右左 // 最終再做反轉從 中右左 -\u0026gt; 左右中 得到後續 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-postorder-traversal/","section":"All my post","summary":"Binary Tree Postorder Traversal","title":"Binary Tree Postorder Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Preorder Traversal 思路 # 遞歸演算法的三個要素 決定遞迴函數的參數和回傳值： 決定哪些參數是遞迴的過程中需要處理的，那麼就在遞迴函數裡加上這個參數， 也要明確每次遞迴的傳回值是什麼進而決定遞迴函數的回傳類型。\n確定終止條件： 寫完了遞歸演算法, 運行的時候，常常會遇到棧溢出的錯誤，就是沒寫終止條件或者終止條件寫的不對，操作系統也是用一個棧的結構來保存每一層遞歸的信息，如果遞歸沒有終止，操作系統的內存棧必然就會溢出。\n確定單層遞歸的邏輯： 確定每一層遞歸需要處理的資訊。這裡也就會重複呼叫自己來實現遞歸的過程。\n解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 右（空节点不入栈） if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 左（空节点不入栈） } // 解釋：程式邏輯是中 右左，但右左是進去 stack 因此出來就會變成先處理左再處理右， // 因此最終就會是中 左右 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-preorder-traversal/","section":"All my post","summary":"Binary Tree Preorder Traversal","title":"Binary Tree Preorder Traversal","type":"docs"},{"content":"Leetcode link : Evaluate Reverse Polish Notation 描述 # 輸入: [\u0026ldquo;2\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;3\u0026rdquo;, \u0026quot; * \u0026ldquo;] 輸出: 9 解釋: 此算式轉換為常見的中綴算術表達式為：((2 + 1) * 3) = 9 思路 # 一種後綴表達式，所謂後綴就是指運算子寫在後面。\n平常使用的算式則是一種中綴式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n此算式的逆波蘭表達式寫法為 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n逆波蘭表達式主要有以下兩個優點：\n去掉括號後表達式無歧義，上式即便寫成 1 2 + 3 4 + * 也可以依序計算出正確結果。 適合用堆疊操作運算：遇到數字則入棧；遇到運算子則取出棧頂兩個數字進行計算，並將結果壓入堆疊中。 解法 # class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { // 力扣修改了后台测试数据，需要用longlong stack\u0026lt;long long\u0026gt; st; for (int i = 0; i \u0026lt; tokens.size(); i++) { if (tokens[i] == \u0026#34;+\u0026#34; || tokens[i] == \u0026#34;-\u0026#34; || tokens[i] == \u0026#34;*\u0026#34; || tokens[i] == \u0026#34;/\u0026#34;) { long long num1 = st.top(); st.pop(); long long num2 = st.top(); st.pop(); if (tokens[i] == \u0026#34;+\u0026#34;) st.push(num2 + num1); if (tokens[i] == \u0026#34;-\u0026#34;) st.push(num2 - num1); if (tokens[i] == \u0026#34;*\u0026#34;) st.push(num2 * num1); if (tokens[i] == \u0026#34;/\u0026#34;) st.push(num2 / num1); } else { st.push(stoll(tokens[i])); } } long long result = st.top(); st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事） return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/evaluate-reverse-polish-notation/","section":"All my post","summary":"Evaluate Reverse Polish Notation","title":"Evaluate Reverse Polish Notation","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/heap/","section":"Tags","summary":"","title":"Heap","type":"tags"},{"content":"Leetcode link : Implement Queue using Stacks 描述 # push(x) \u0026ndash; 將一個元素放入佇列的尾端。 pop() \u0026ndash; 從隊列首部移除元素。 peek() \u0026ndash; 傳回佇列首部的元素。 empty() \u0026ndash; 傳回佇列是否為空。 思路 # 在 push 資料的時候，只要資料放進輸入棧就好 在 pop 的時候 輸出棧如果為空，就把進棧資料全部導入進來（注意是全部導入），再從出棧彈出數據 輸出棧不為空，則直接從出棧彈出資料就可以了。 最後如何判斷隊列為空呢？如果進棧和出棧都為空的話，表示模擬的佇列為空了。\n解法 # class MyQueue { public: stack\u0026lt;int\u0026gt; stIn; stack\u0026lt;int\u0026gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-\u0026gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() \u0026amp;\u0026amp; stOut.empty(); } }; // 时间复杂度： 都为O(1)。pop和peek看起来像O(n)，实际上一个循环n会被使用n次，最后还是O(1) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/implement-queue-using-stacks/","section":"All my post","summary":"Implement Queue using Stacks","title":"Implement Queue using Stacks","type":"docs"},{"content":"Leetcode link : Implement Stack using Queues 描述 # push(x) \u0026ndash; 元素 x 入棧 pop() \u0026ndash; 移除棧頂元素 top() \u0026ndash; 取得棧頂元素 empty() \u0026ndash; 返回堆疊是否為空 解法 # class MyStack { public: queue\u0026lt;int\u0026gt; que1; queue\u0026lt;int\u0026gt; que2; // 辅助队列，用来备份 /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { que1.push(x); } /** Removes the element on top of the stack and returns that element. */ int pop() { int size = que1.size(); size--; while (size--) { // 将que1 导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); // 留下的最后一个元素就是要返回的值 que1.pop(); que1 = que2; // 再将que2赋值给que1 while (!que2.empty()) { // 清空que2 que2.pop(); } return result; } /** Get the top element. ** Can not use back() direactly. */ int top(){ int size = que1.size(); size--; while (size--){ // 将que1 导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); // 留下的最后一个元素就是要回返的值 que2.push(que1.front()); // 获取值后将最后一个元素也加入que2中，保持原本的结构不变 que1.pop(); que1 = que2; // 再将que2赋值给que1 while (!que2.empty()){ // 清空que2 que2.pop(); } return result; } /** Returns whether the stack is empty. */ bool empty() { return que1.empty(); } }; // 时间复杂度: pop为O(n)，top为O(n)，其他为O(1) // 空间复杂度： O(n) 優化 # 其實這題目就是用一個隊列就夠了\nclass MyStack { public: queue\u0026lt;int\u0026gt; que; MyStack() { } void push(int x) { que.push(x); } int pop() { int size = que.size(); size--; while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部 que.push(que.front()); que.pop(); } int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了 que.pop(); return result; } int top(){ int size = que.size(); size--; while (size--){ // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部 que.push(que.front()); que.pop(); } int result = que.front(); // 此时获得的元素就是栈顶的元素了 que.push(que.front()); // 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化 que.pop(); return result; } bool empty() { return que.empty(); } }; ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/implement-stack-using-queues/","section":"All my post","summary":"Implement Stack using Queues","title":"Implement Stack using Queues","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Leetcode link : Remove All Adjacent Duplicates In String 描述 # S 僅由小寫英文字母組成，1 \u0026lt;= S.length \u0026lt;= 20000\n重複項刪除操作會選擇兩個相鄰且相同的字母，並刪除它們。\n在 S 上重複執行重複項刪除操作，直到無法繼續刪除。\n在完成所有重複項刪除操作後傳回最終的字串。\n輸入：\u0026ldquo;abbaca\u0026rdquo; 輸出：\u0026ldquo;ca\u0026rdquo;\n在 \u0026ldquo;abbaca\u0026rdquo; 中，我們可以刪除 \u0026ldquo;bb\u0026rdquo; 由於兩個字母相鄰且相同，這是此時唯一可以執行刪除操作的重複項 之後我們得到字串 \u0026ldquo;aaca\u0026rdquo;，其中又只有 \u0026ldquo;aa\u0026rdquo; 可以執行重複項刪除操作 所以最後的字串為 \u0026ldquo;ca\u0026rdquo;。 思路 # 用棧來存放前面遍歷過的元素呢，去棧裡看一下我們是不是遍歷過相同數值的相鄰元素。 從堆疊中彈出剩餘元素，此時是字串 ac 從堆疊中彈出的元素是倒序的，所以再對字串進行反轉一下，就得到了最終的結果。 解法 # class Solution { public: string removeDuplicates(string S) { stack\u0026lt;char\u0026gt; st; for (char s : S) { if (st.empty() || s != st.top()) { st.push(s); } else { st.pop(); // s 与 st.top()相等的情况 } } string result = \u0026#34;\u0026#34;; while (!st.empty()) { // 将栈中元素放到result字符串汇总 result += st.top(); st.pop(); } reverse (result.begin(), result.end()); // 此时字符串需要反转一下 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) 優化 # 可以拿字串直接當棧，這樣省去了棧還要轉為字串的操作\nclass Solution { public: string removeDuplicates(string S) { string result; for(char s : S) { if(result.empty() || result.back() != s) { result.push_back(s); } else { result.pop_back(); } } return result; } }; ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/remove-all-adjacent-duplicates-in-string/","section":"All my post","summary":"Remove All Adjacent Duplicates In String","title":"Remove All Adjacent Duplicates In String","type":"docs"},{"content":"Leetcode link : Sliding Window Maximum 描述 # 思路 # 暴力法：O(n × k)\n遍歷一遍的過程中每次從視窗中再找到最大的數值\n去掉括號後表達式無歧義，上式即便寫成 1 2 + 3 4 + * 也可以依序計算出正確結果。\n適合用堆疊操作運算：遇到數字則入棧；遇到運算子則取出棧頂兩個數字進行計算，並將結果壓入堆疊中。\nQueue\nQueue 沒有必要維護視窗裡的所有元素，只需要維護有可能成為視窗裡最大值的元素就可以了，同時確保 Queue 裡的元素數值是由大到小的。\n對於視窗裡的元素{2, 3, 5, 1 ,4}，單調隊列裡只維護 {5, 4} 就夠了，保持單調隊列裡單調遞減，此時隊列出口元素就是窗口裡最大元素。\npop(value)：如果視窗移除的元素 value 等於單調佇列的出口元素，那麼佇列彈出元素，否則不用任何操作\npush(value)：如果 push 的元素 value 大於入口元素的數值，那麼就將佇列入口的元素彈出，直到 push 元素的數值小於等於佇列入口元素的數值為止\n保持如上規則，每次視窗移動的時候，只要問 que.front()就可以回到目前視窗的最大值。\n解法 # class Solution { private: class MyQueue { //单调队列（从大到小） public: deque\u0026lt;int\u0026gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) { if (!que.empty() \u0026amp;\u0026amp; value == que.front()) { que.pop_front(); } } // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) { while (!que.empty() \u0026amp;\u0026amp; value \u0026gt; que.back()) { que.pop_back(); } que.push_back(value); } // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() { return que.front(); } }; public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { MyQueue que; vector\u0026lt;int\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { // 先将前k的元素放进队列 que.push(nums[i]); } result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i \u0026lt; nums.size(); i++) { que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 } return result; } }; // 时间复杂度： O(n) // nums 中的每個元素最多也就被 push_back 和 pop_back 各一次，沒有任何多餘操作，所以整體的複雜度還是 O(n)。 // 空间复杂度： O(k) 一個輔助隊列 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/sliding-window-maximum/","section":"All my post","summary":"Sliding Window Maximum","title":"Sliding Window Maximum","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/stackqueue/","section":"Tags","summary":"","title":"Stack\u0026Queue","type":"tags"},{"content":"Leetcode link : Top K Frequent Elements 描述 # 給定一個非空的整數數組，傳回其中出現頻率前 k 高的元素。\n輸入: nums = [1,1,1,2,2,3], k = 2 輸出: [1,2]\n你可以假設給定的 k 總是合理的，且 1 ≤ k ≤ 陣列中不相同的元素的個數。 時間複雜度必須優於 O(nlogn), n 是數組的大小。 陣列中前 k 個高頻元素的集合是唯一的。 你可以按任意順序返回答案。 思路 # 解法 # class Solution { public: // 小顶堆 class mycomparison { public: bool operator()(const pair\u0026lt;int, int\u0026gt;\u0026amp; lhs, const pair\u0026lt;int, int\u0026gt;\u0026amp; rhs) { return lhs.second \u0026gt; rhs.second; } }; vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 要统计元素出现频率 unordered_map\u0026lt;int, int\u0026gt; map; // map\u0026lt;nums[i],对应出现的次数\u0026gt; for (int i = 0; i \u0026lt; nums.size(); i++) { map[nums[i]]++; } // 对频率排序 // 定义一个小顶堆，大小为k priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, mycomparison\u0026gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map\u0026lt;int, int\u0026gt;::iterator it = map.begin(); it != map.end(); it++) { pri_que.push(*it); if (pri_que.size() \u0026gt; k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); } } // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector\u0026lt;int\u0026gt; result(k); for (int i = k - 1; i \u0026gt;= 0; i--) { result[i] = pri_que.top().first; pri_que.pop(); } return result; } }; // 时间复杂度： O(nlogk) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/top-k-frequent-elements/","section":"All my post","summary":"Top K Frequent Elements","title":"Top K Frequent Elements","type":"docs"},{"content":"Leetcode link : Valid Parentheses 描述 # 給定一個只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字串，判斷字串是否有效。 有效字串需滿足： 左括號必須用相同類型的右括號閉合。 左括號必須以正確的順序閉合。 注意空字串可被認為是有效字串。 输入: \u0026ldquo;([)]\u0026rdquo; 输出: false 思路 # 已經遍歷完了字串，但是棧不為空，表示有相應的左括號沒有右括號來匹配，所以 return false 遍歷字串符合的過程中，發現棧裡沒有要符合的字元。所以 return false 遍歷字串匹配的過程中，棧已經為空了，沒有匹配的字元了，表示右括號沒有找到對應的左括號 return false 字串遍歷完之後，棧是空的，就表示全都匹配了 匹配左括號的時候，右括號先入棧，就只需要比較當前元素和棧頂相不相等就可以了，\n解法 # class Solution { public: bool isValid(string s) { if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求 stack\u0026lt;char\u0026gt; st; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) st.push(\u0026#39;)\u0026#39;); else if (s[i] == \u0026#39;{\u0026#39;) st.push(\u0026#39;}\u0026#39;); else if (s[i] == \u0026#39;[\u0026#39;) st.push(\u0026#39;]\u0026#39;); // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false else if (st.empty() || st.top() != s[i]) return false; else st.pop(); // st.top() 与 s[i]相等，栈弹出元素 } // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true return st.empty(); } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/valid-parentheses/","section":"All my post","summary":"Valid Parentheses","title":"Valid Parentheses","type":"docs"},{"content":"Leetcode link : 3Sum 描述 # 給你一個包含 n 個整數的陣列 nums，判斷 nums 中是否存在三個元素 a，b，c ，使得 a + b + c = 0 ？請你找出所有符合條件且不重複的三元組。\n注意： 答案中不可以包含重複的三元組。\n範例：給定數組 nums = [-1, 0, 1, 2, -1, -4]，滿足要求的三元組集合為： [ [-1, 0, 1], [-1, -1, 2] ]\n思路 # Hashing：O(n^2)\n兩層 for 迴圈就可以確定 兩個數值 第三個數 0-(a+b) 或 0 - (a + c) 是否在 數組裡出現過 題目中說的不可以包含重複的三元組。 -\u0026gt; 把符合條件的三元組放進 vector 中，然後再去重，這樣是非常費時的，很容易超時， 實這題目使用 Hashing 並不十分合適，因為在去重的操作中有很多細節需要注意，在面試中很難直接寫出沒有 bug 的代碼。 Two pointer：O(n^2)\n先將數組排序，然後有一層 for 循環\ni 從下標 0 的地方開始 定一個下標 left 定義在 i+1 的位置上 定義下標 right 在數組結尾的位置上。 還是在陣列中找到 abc 使得 a + b +c =0\n相當於 a = nums[i]，b = nums[left]，c = nums[right]。 如何移動 left 和 right 呢\n如果 nums[i] + nums[left] + nums[right] \u0026gt; 0 說明 此時三數總和大了，因為數組是排序後了 所以 right 下標就應該向左移動，這樣才能讓三數之和小一些。 如果 nums[i] + nums[left] + nums[right] \u0026lt; 0 說明 此時 三數之和小了，left 就向右移動，才能讓三數總和大一些 直到 left 與 right 相遇為止。\n解法 # class Solution { public: // 在一个数组中找到3个数形成的三元组，它们的和为0，不能重复使用（三数下标互不相同），且三元组不能重复。 // b（存储）== 0-(a+c)（检索） vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i++) { // 如果a是正数，a\u0026lt;b\u0026lt;c，不可能形成和为0的三元组 if (nums[i] \u0026gt; 0) break; // [a, a, ...] 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; // 这个set的作用是存储b unordered_set\u0026lt;int\u0026gt; set; for (int k = i + 1; k \u0026lt; nums.size(); k++) { // 去重b=c时的b和c if (k \u0026gt; i + 2 \u0026amp;\u0026amp; nums[k] == nums[k - 1] \u0026amp;\u0026amp; nums[k - 1] == nums[k - 2]) continue; // a+b+c=0 \u0026lt;=\u0026gt; b=0-(a+c) int target = 0 - (nums[i] + nums[k]); if (set.find(target) != set.end()) { result.push_back({nums[i], target, nums[k]}); // nums[k]成为c set.erase(target); } else { set.insert(nums[k]); // nums[k]成为b } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n)，额外的 set 开销 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i \u0026lt; nums.size(); i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] \u0026gt; 0) { return result; } // 错误去重a方法，将会漏掉-1,-1,2 这种情况 /* if (nums[i] == nums[i + 1]) { continue; } */ // 正确去重a方法 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right\u0026lt;=left 了，从而漏掉了 0,0,0 这种三元组 /* while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; */ if (nums[i] + nums[left] + nums[right] \u0026gt; 0) right--; else if (nums[i] + nums[left] + nums[right] \u0026lt; 0) left++; else { result.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[left], nums[right]}); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 // 因為 nums[left] 和 nums[right] 這對數字已經被用過並且記錄成答案，我們必須把視窗向內縮，才能繼續尋找下一組可能的配對，同時避免死迴圈或重複答案。 right--; left++; } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) 注意 # 兩數和要求回傳的是索引下標，而雙指標法一定要排序，一旦排序之後原數組的索引就被改變了。 兩數和要求回傳的是數值的話，就可以使用雙指標法了。 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/3sum/","section":"All my post","summary":"3Sum","title":"3Sum","type":"docs"},{"content":"Leetcode link : 4Sum 描述 # 題意：給定一個包含 n 個整數的陣列 nums 和一個目標值 target 判斷 nums 中是否存在四個元素 a，b，c 和 d ，使得 a + b + c + d 的值與 target 相等- 找出所有滿足條件且不重複的四元組。 注意：答案中不可以包含重複的四元組。 例： 給定數組 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 滿足要求的四元組集合為： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 思路 # 基本解法就是在 三數和 的基礎上再套一層 for 循環 但有一些細節要注意，例如： 不要判斷 nums[k] \u0026gt; target 就回傳了，三數之和 可以透過 nums[i] \u0026gt; 0 就回傳了，因為 0 已經是確定的數了，四數之和這道題目 target 是任意值。 例如：陣列是[-4, -3, -2, -1]，target 是 -10，不能因為 -4 \u0026gt; -10 而跳過。但是我們依舊可以去做剪枝 邏輯變成 nums[k] \u0026gt; target \u0026amp;\u0026amp; (nums[k] \u0026gt;=0 || target \u0026gt;= 0)就可以了。 雙指針解法： 兩層 for 循環 nums[k] + nums[i]為確定值 依然是循環內有 left 和 right 下標作為雙指針 找出 nums[k] + nums[i] + nums[left] + nums[right] == target 的情況 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k \u0026lt; nums.size(); k++) { // 剪枝处理 if (nums[k] \u0026gt; target \u0026amp;\u0026amp; nums[k] \u0026gt;= 0) { break; // 这里使用break，统一通过最后的return返回 } // 对nums[k]去重 if (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } for (int i = k + 1; i \u0026lt; nums.size(); i++) { // 2级剪枝处理 if (nums[k] + nums[i] \u0026gt; target \u0026amp;\u0026amp; nums[k] + nums[i] \u0026gt;= 0) { // 因为只要 nums[k] + nums[i] \u0026gt; target，那么 nums[i] 后面的数都是正数的话，就一定 不符合条件了。 break; } // 对nums[i]去重 if (i \u0026gt; k + 1 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target 会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target) { right--; // nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target 会溢出 } else if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target) { left++; } else { result.push_back(vector\u0026lt;int\u0026gt;{nums[k], nums[i], nums[left], nums[right]}); // 对nums[left]和nums[right]去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; } } } } return result; } }; // 时间复杂度： O(n^3) // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum/","section":"All my post","summary":"4Sum","title":"4Sum","type":"docs"},{"content":"Leetcode link : 4Sum II 描述 # 給定四個包含整數的陣列列表 A , B , C , D ,計算有多少個元組 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n為了使問題簡單化，所有的 A, B, C, D 具有相同的長度 N，且 0 ≤ N ≤ 500 。所有整數的範圍在 -2^28 到 2^28 - 1 之間，最終結果不會超過 2^31 - 1 。\n輸入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 輸出: 2\n解釋: 兩個元組如下: (0, 0, 0, 1) -\u0026gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -\u0026gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n思路 # 暴力法：\n時間複雜度是 O(n^4) Hashing：\n先定義 一個 unordered_map，key 放 a 和 b 兩數和，value 放 a 和 b 兩數之和出現的次數。 遍歷大 A 和大 B 數組，統計兩個數組元素總和，和出現的次數，放到 map。 定義 int 變數 count，用來統計 a+b+c+d = 0 出現的次數。 再遍歷大 C 和大 D 數組，找出如果 0-(c+d) 在 map 中出現過的話，就用 count 把 map 中 key 對應的 value 也就是出現次數統計出來。 最後回傳統計值 count 就可以了 解法 # class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B, vector\u0026lt;int\u0026gt;\u0026amp; C, vector\u0026lt;int\u0026gt;\u0026amp; D) { unordered_map\u0026lt;int, int\u0026gt; umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 for (int a : A) { for (int b : B) { umap[a + b]++; } } int count = 0; // 统计a+b+c+d = 0 出现的次数 // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) { for (int d : D) { if (umap.find(0 - (c + d)) != umap.end()) { count += umap[0 - (c + d)]; } } } return count; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n^2) 最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum-ii/","section":"All my post","summary":"4Sum II","title":"4Sum II","type":"docs"},{"content":"Leetcode link : Find Common Characters 描述 # 給你一個字串陣列 words ，請你找出所有在 words 的每個字串中都出現的共用字元（ 包括重複字元），並以陣列形式傳回。你可以按 任意順序 返回答案。\n範例 1：輸入：words = [\u0026ldquo;bella\u0026rdquo;,\u0026ldquo;label\u0026rdquo;,\u0026ldquo;roller\u0026rdquo;] 輸出：[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;]\n範例 2：輸入：words = [\u0026ldquo;cool\u0026rdquo;,\u0026ldquo;lock\u0026rdquo;,\u0026ldquo;cook\u0026rdquo;] 輸出：[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\n提示：1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] 由小寫英文字母組成\n思路 # 暴力法：\n時間複雜度是 O(n^m) 一個字串一個字串去搜，n 是字串長度，m 是有幾個字串。 碼實現也不容易，因為要統計 重複的字符，還要適當的替換或去重 Hashing：\n統計出搜尋字串裡 26 個字元的出現的頻率 取每個字元頻率最小值，最後轉成輸出格式就可以了 解法 # class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; A) { vector\u0026lt;string\u0026gt; result; if (A.size() == 0) return result; int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率 for (int i = 0; i \u0026lt; A[0].size(); i++) { // 用第一个字符串给hash初始化 hash[A[0][i] - \u0026#39;a\u0026#39;]++; } int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率 for (int i = 1; i \u0026lt; A.size(); i++) { memset(hashOtherStr, 0, 26 * sizeof(int)); for (int j = 0; j \u0026lt; A[i].size(); j++) { hashOtherStr[A[i][j] - \u0026#39;a\u0026#39;]++; } // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数 for (int k = 0; k \u0026lt; 26; k++) { hash[k] = min(hash[k], hashOtherStr[k]); } } // 将hash统计的字符次数，转成输出形式 for (int i = 0; i \u0026lt; 26; i++) { while (hash[i] != 0) { // 注意这里是while，多个重复的字符 string s(1, i + \u0026#39;a\u0026#39;); // char -\u0026gt; string result.push_back(s); hash[i]--; } } return result; } }; // 时间复杂度：O(n) 所有字元的總數 // 空间复杂度：O(1) 每條字串長度都是固定常數 或 可視為相同平均長度 L 時候字元總數 N = n * L 於是時間複雜度為 n\n如果字串長度差異很大、或隨著輸入放大而成長，就必須把長度考慮進去，寫成 O(nL) or O(N)\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-common-characters/","section":"All my post","summary":"Find Common Characters","title":"Find Common Characters","type":"docs"},{"content":"Leetcode link : Find the Index of the First Occurrence in a String 描述 # 給定一個 haystack 字串和一個 needle 字串，在 haystack 字串中找出 needle 字串出現的第一個位置 (從 0 開始)。如果不存在，則傳回 -1。\n範例 1: 輸入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 輸出: 2\n範例 2: 輸入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 輸出: -1\n當 needle 是空字串時，我們該回傳什麼值呢？這是一個在面試中很好的問題。\n對本題而言，當 needle 是空字串時我們應當傳回 0 。這與 Java 的 indexOf() 定義相符。\n思路 # 使用 KMP j 指向「待比較的 pattern 位置」（亦代表當前已匹配長度）。 失配時 j = next[j-1] 讓我們「盡量利用已知最長前後綴」，避免從頭比。 整個迴圈 每個 i 與 j 只會單調遞增或回退一次 → O(m) 解法 # class Solution { public: void getNext(int* next, const string\u0026amp; s) { int j = 0; // 已匹配的字元長度 next[0] = 0; // s[0] 的 LPS 為 0 for (int i = 1; i \u0026lt; s.size(); ++i) { // 若失配：沿用「已知最長前後綴」繼續回溯 while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1]; // 若匹配：匹配長度 +1 if (s[i] == s[j]) ++j; next[i] = j; // 紀錄位置 i 的 LPS } } int strStr(string haystack, string needle) { if (needle.empty()) return 0; vector\u0026lt;int\u0026gt; next(needle.size()); getNext(next.data(), needle); // 建 LPS int j = 0; // pattern 指針 for (int i = 0; i \u0026lt; haystack.size(); ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]) j = next[j - 1]; // 失配 → 回跳 if (haystack[i] == needle[j]) ++j; // 匹配 → 雙指標前進 if (j == needle.size()) // 全部匹配完成 return i - j + 1; // 回傳起始索引 } return -1; // 未找到 } }; // 时间复杂度: O(n + m) m：建表 (getNext) , n：匹配 (strStr) // 空间复杂度: O(m) m：建表 (getNext) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-the-index-of-the-first-occurrence-in-a-string/","section":"All my post","summary":"Find the Index of the First Occurrence in a String","title":"Find the Index of the First Occurrence in a String","type":"docs"},{"content":"Leetcode link : Happy Number 描述 # 「快樂數」定義為：對於一個正整數，每一次將該數替換為它每個位置上的數字的平方和，然後重複這個過程直到這個數變為 1，也可能是 無限循環 但始終變不到 1。如果 可以變成 1，那麼這個數就是快樂數。\n如果 n 是快樂數就回傳 True ；不是，則回傳 False 。\n輸入：19 輸出：true\n解釋： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1\n思路 # 我們遇到了要快速判斷一個元素是否出現集合裡的時候，就要考慮 Hashing\n判斷這個 sum 是否重複出現，如果重複了就是 return false， 否則一直找到 sum 為 1。\n判斷 sum 是否重複出現就可以使用 unordered_set。\n解法 # class Solution { public: // 取数值各个位上的单数之和 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while(1) { int sum = getSum(n); if (sum == 1) { return true; } // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false if (set.find(sum) != set.end()) { return false; } else { set.insert(sum); } n = sum; } } }; // 时间复杂度： O(logn) // 空间复杂度： O(logn) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/happy-number/","section":"All my post","summary":"Happy Number","title":"Happy Number","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/hashing/","section":"Tags","summary":"","title":"Hashing","type":"tags"},{"content":"Leetcode link : Intersection of Two Arrays 描述 # 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n題目刻意說明：輸出結果中的每個元素一定是唯一的，也就是說輸出的結果的去重的， 同時可以不考慮輸出結果的順序 -\u0026gt; unordered_set\n而這題目沒有限制數值的大小 -\u0026gt; 無法使用陣列來做哈希表\n哈希值比較少、特別分散、跨度非常大，使用數組就會造成空間的極大浪費 -\u0026gt; 使用另一種結構體 set set 有三種資料結構 std::set -\u0026gt; 底層為紅黑樹 std::multiset -\u0026gt; 底層為紅黑樹 std::unordered_set -\u0026gt; 底層為 hash table -\u0026gt; 使用 unordered_set 讀寫效率最高，不需對資料進行排序，也不要讓資料重複 解法 # class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set; // 存放结果，之所以用set是为了给结果集去重 unordered_set\u0026lt;int\u0026gt; nums_set(nums1.begin(), nums1.end()); for (int num : nums2) { // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(), result_set.end()); } }; // 时间复杂度： O(n + m) nums1 = n, nums2 = m // k 是最后要把 set 转成 vector 但因為長度必定小於 m or n 因此最終為 O(n + m) // 空间复杂度： O(n + k) nums_set = n, result_set = k 注意 # 遇到哈希問題我直接都用 set 不就得了，用什麼數組啊？ 直接使用 set 不僅佔空間比陣列大，而且速度要比陣列慢 set 把數值映射到 key 上都要做 hash 計算的。 不要小瞧 這個耗時，在數據量大的情況，差距是很明顯的。 當題目有限制較小的數值範圍時，例如：1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 就可以把 array 作為 hash，若範圍過大則採用 unordered_set ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/intersection-of-two-arrays/","section":"All my post","summary":"Intersection of Two Arrays","title":"Intersection of Two Arrays","type":"docs"},{"content":"Leetcode link : Ransom Note 描述 # 給定一個贖金信 (ransom) 字串和一個雜誌 (magazine) 字串，判斷第一個字串 ransom 能不能由第二個字串 magazines 裡面的字構成。如果可以構成，則傳回 true ；否則傳回 false。\n(題目說明：為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思。雜誌字串中的每個字元只能在贖金信字串中使用一次。)\n注意：你可以假設兩個字串均只含有小寫字母。 canConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n思路 # 「為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思」 這裡說明雜誌裡面的字母不可重複使用。 「你可以假設兩個字串都只含有小寫字母。」 說明只有小寫字母 解法 # class Solution { public: bool canConstruct(string ransomNote, string magazine) { for (int i = 0; i \u0026lt; magazine.length(); i++) { for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 在ransomNote中找到和magazine相同的字符 if (magazine[i] == ransomNote[j]) { ransomNote.erase(ransomNote.begin() + j); // ransomNote删除这个字符 break; } } } // 如果ransomNote为空，则说明magazine的字符可以组成ransomNote if (ransomNote.length() == 0) { return true; } return false; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) class Solution { public: bool canConstruct(string ransomNote, string magazine) { int record[26] = {0}; //add if (ransomNote.size() \u0026gt; magazine.size()) { return false; } for (int i = 0; i \u0026lt; magazine.length(); i++) { // 通过record数据记录 magazine里各个字符出现次数 record[magazine[i]-\u0026#39;a\u0026#39;] ++; } for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 遍历ransomNote，在record里对应的字符个数做--操作 record[ransomNote[j]-\u0026#39;a\u0026#39;]--; // 如果小于零说明ransomNote里出现的字符，magazine没有 if(record[ransomNote[j]-\u0026#39;a\u0026#39;] \u0026lt; 0) { return false; } } return true; } }; // 时间复杂度： O(m+n)，其中m表示ransomNote的长度，n表示magazine的长度 // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/ransom-note/","section":"All my post","summary":"Ransom Note","title":"Ransom Note","type":"docs"},{"content":"Leetcode link : Repeated Substring Pattern 描述 # 給定一個非空的字串，判斷它是否可以由它的一個子字串重複多次構成。\n給定的字串只含有小寫英文字母，且長度不超過10000\n輸入: \u0026ldquo;abcabcabcabc\u0026rdquo; 輸出: True\n解釋: 可由子字串 \u0026ldquo;abc\u0026rdquo; 重複四次構成。 (或子字串 \u0026ldquo;abcabc\u0026rdquo; 重複兩次構成。)\n思路 # 暴力法：O(n^2) 一個 for 迴圈取得 子字串的終止位置， 然後判斷子字串是否能重複構成字串，又嵌套一個 for 循環 其實我們只要判斷，以第一個字母為開始的子字串就可以 所以一個 for 迴圈取得子字串的終止位置就行了。 遍歷的時候 都不用遍歷結束，只需要遍歷到中間位置 因為子字串結束位置大於中間位置的話，一定不能重複組成字串 把 s 拼成 s+s 後再掐頭去尾，檢查 s 是否仍能出現在中間：O(n+m) find 為標準函式庫 -\u0026gt; 保證最壞 O(n+m) 使用 KMP getNext 計算 最長公共前後綴長度 解法 # bool repeatedSubstringPattern_bruteforce(const string\u0026amp; s) { int n = s.size(); if (n \u0026lt; 2) return false; // 長度 0 或 1 不可能 for (int len = 1; len \u0026lt;= n / 2; ++len) { if (n % len != 0) continue; // len 不是 n 的因數，直接跳過 bool ok = true; // 檢查第 len..n-1 位置的字元，是否與對應的 s[i-len] 相同 for (int i = len; i \u0026lt; n \u0026amp;\u0026amp; ok; ++i) { if (s[i] != s[i - len]) ok = false; } if (ok) return true; // 找到一組合法的 len } return false; } // 时间复杂度：O(n^2) // 空间复杂度：O(1) class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾 if (t.find(s) != std::string::npos) return true; // r return false; } }; // 時間複雜度為 O(n)（find 掃字串） // 空間複雜度 O(n)（存 t）。 class Solution { public: void getNext (int* next, const string\u0026amp; s){ next[0] = 0; // 第 0 個字元的 LPS 永遠是 0 int j = 0; // j = 目前可延續的最長匹配長度 for(int i = 1;i \u0026lt; s.size(); i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) { j = next[j - 1]; // 失配：退回上一個可用的 LPS } if(s[i] == s[j]) { j++; // 成功配對，匹配長度 +1 } next[i] = j; // 記錄 i 位置對應的 LPS } } bool repeatedSubstringPattern (string s) { if (s.size() == 0) { return false; } int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 \u0026amp;\u0026amp; len % (len - (next[len - 1] )) == 0) { return true; } return false; } }; // 時間複雜度為 O(n) // 空間複雜度 O(n) 注意 # 若字串由子字串 p 重複組成\n設 |p| = k，重複 m 次 (len = k·m)。\n整條字串的最長公共前後綴就是 p 重複 m-1 次 → 長度 len - k。\n因此 lps = len - k，且 k = len - lps。\n此時 len % k == 0 成立。\n若條件成立，必有重複子字串\nlps \u0026gt; 0 ⇒ 至少有一段前綴同時也是後綴。\nk = len - lps 為可能的週期長度。\n若 len % k == 0，把長度 k 的子字串複製 m = len/k 次即可拼回原字串。\n反例不可能通過測試\n若字串並非週期字串，lps 只能小於真正週期長度或為 0。\n即使 lps \u0026gt; 0，len % (len-lps) 也必定不等於 0。\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/repeated-substring-pattern/","section":"All my post","summary":"Repeated Substring Pattern","title":"Repeated Substring Pattern","type":"docs"},{"content":"Leetcode link : Reverse String 描述 # 寫一個函數，其作用是將輸入的字串反轉過來。輸入字串以字元數組 char[] 的形式給出。\n不要給另外的陣列分配額外的空間，你必須原地修改輸入陣列、使用 O(1) 的額外空間解決這個問題。\n你可以假設數組中的所有字元都是 ASCII 碼表中的可列印字元。\n思路 # swap 可以有兩種實現 常見的交換數值 過位元運算 // 1 int tmp = s[i]; s[i] = s[j]; s[j] = tmp; // 2 s[i] ^= s[j]; s[j] ^= s[i]; s[i] ^= s[j]; 解法 # class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for (int i = 0, j = s.size() - 1; i \u0026lt; s.size()/2; i++, j--) { swap(s[i],s[j]); } } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string/","section":"All my post","summary":"Reverse String","title":"Reverse String","type":"docs"},{"content":"Leetcode link : Reverse String II 描述 # 給定一個字串 s 和一個整數 k，從字串開頭算起, 每計數至 2k 個字符，就反轉這 2k 個字符中的前 k 個字符。\n如果剩餘字元少於 k 個，則將剩餘字元全部反轉。\n如果剩餘字符小於 2k 但大於或等於 k 個，則反轉前 k 個字符，其餘字符保持原樣。\n範例:輸入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 輸出: \u0026ldquo;bacdfeg\u0026rdquo;\n思路 # 在遍歷字串的過程中，只要讓 i += (2 * k) i 每次移動 2 \\* k 就可以了，然後判斷是否需要有反轉的區間。 因為要找的也就是每 2 * k 區間的起點 當需要固定規律一段一段去處理字串的時候，要想想在 for 迴圈的表達式上做做文章。 解法 # class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += (2 * k)) { // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k \u0026lt;= s.size()) { reverse(s.begin() + i, s.begin() + i + k ); } else { // 3. 剩余字符少于 k 个，则将剩余字符全部反转。 reverse(s.begin() + i, s.end()); } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string-ii/","section":"All my post","summary":"Reverse String II","title":"Reverse String II","type":"docs"},{"content":"Leetcode link : Reverse Words in a String 描述 # 輸入: \u0026quot; hello world! \u0026quot; 輸出: \u0026ldquo;world! hello\u0026rdquo;\n解釋: 輸入字串可以在前面或後麵包含多餘的空格，但是反轉後的字元不能包括。\n輸入: \u0026ldquo;a good example\u0026rdquo; 輸出: \u0026ldquo;example good a\u0026rdquo;\n解釋: 如果兩個字間有多餘的空格，將反轉後字間的空格減少到只含一個。\n不要使用輔助空間，空間複雜度要求為 O(1)\n思路 # 移除多餘空格 將整個字串反轉 將每個單字反轉 解法 # void removeExtraSpaces(string\u0026amp; s) { for (int i = s.size() - 1; i \u0026gt; 0; i--) { if (s[i] == s[i - 1] \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) { s.erase(s.begin() + i); } } // 删除字符串最后面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[s.size() - 1] == \u0026#39; \u0026#39;) { s.erase(s.begin() + s.size() - 1); } // 删除字符串最前面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[0] == \u0026#39; \u0026#39;) { s.erase(s.begin()); } } // 时间复杂度：O(n^2) // 一个 erase 本来就是O(n)的操作 而 erase 操作上面还套了一个 for 循环 // 空间复杂度：O(1) 使用雙指標法來去移除空格，最後 resize（重新設定）一下字串的大小，就可以做到 O(n)的時間複雜度。\n//版本一 void removeExtraSpaces(string\u0026amp; s) { int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针 // 去掉字符串前面的空格 while (s.size() \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; s.size() \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { fastIndex++; } for (; fastIndex \u0026lt; s.size(); fastIndex++) { // 去掉字符串中间部分的冗余空格 if (fastIndex - 1 \u0026gt; 0 // 只有當 fastIndex 至少為 1 時，才去讀 s[fastIndex-1]」，避免在 fastIndex==0 時往左越界 \u0026amp;\u0026amp; s[fastIndex - 1] == s[fastIndex] \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { continue; } else { s[slowIndex++] = s[fastIndex]; } } if (slowIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[slowIndex - 1] == \u0026#39; \u0026#39;) { // 去掉字符串末尾的空格 s.resize(slowIndex - 1); } else { s.resize(slowIndex); // 重新设置字符串大小 } } 精簡後的完整如下\nclass Solution { public: void reverse(string\u0026amp; s, int start, int end) { // 翻转，区间写法：左闭右闭 [] for (int i = start, j = end; i \u0026lt; j; i++, j--) { swap(s[i], s[j]); } } void removeExtraSpaces(string\u0026amp; s) { // 去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0, fast = 0, n = s.size(); // 跳過前導空格 while (fast \u0026lt; n \u0026amp;\u0026amp; s[fast] == \u0026#39; \u0026#39;) ++fast; for (; fast \u0026lt; n; ++fast) { // 如果當前字元是空格，而且前一個已經是空格，略過 if (s[fast] == \u0026#39; \u0026#39; \u0026amp;\u0026amp; (slow == 0 || s[slow - 1] == \u0026#39; \u0026#39;)) continue; s[slow++] = s[fast]; } // 移除尾端空格（可能剛好停在一格空白） if (slow \u0026gt; 0 \u0026amp;\u0026amp; s[slow - 1] == \u0026#39; \u0026#39;) --slow; s.resize(slow); // 調整字串實際長度 } string reverseWords(string s) { removeExtraSpaces( s); // 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; // removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i \u0026lt;= s.size(); ++i) { if (i == s.size() || s[i] == \u0026#39; \u0026#39;) { // 到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); // 翻转，注意是左闭右闭 []的翻转。 start = i + 1; // 更新下一个单词的开始下标start } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) 或 O(n)，取决于语言中字符串是否可变 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-words-in-a-string/","section":"All my post","summary":"Reverse Words in a String","title":"Reverse Words in a String","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/string/","section":"Tags","summary":"","title":"String","type":"tags"},{"content":"Leetcode link : Two Sum 描述 # 給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那兩個整數，並返回他們的數組下標。\n你可以假設每個輸入只會對應一個答案。但是，數組中同一個元素不能使用兩次。\n範例:\n已知 nums = [2, 7, 11, 15], target = 9 為 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n判斷元素是否出現，這個元素就要當 key，所以數組中的元素作為 key，有 key 對應的就是 value，value 用來存下標。 map 中的儲存結構為 {key：資料元素，value：陣列元素對應的下標}。 解法 # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i = 0; i \u0026lt; nums.size(); i++) { // 遍历当前元素，并在map中寻找是否有匹配的key auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter-\u0026gt;second, i}; // first ➜ 這筆資料的 Key（這裡是數值 nums[i]） // second ➜ 這筆資料的 Value（這裡是索引 i） } // 如果没找到匹配对，就把访问过的元素和下标加入到map中 map.insert(pair\u0026lt;int, int\u0026gt;(nums[i], i)); } return {}; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/two-sum/","section":"All my post","summary":"Two Sum","title":"Two Sum","type":"docs"},{"content":"Leetcode link : Valid Anagram 描述 # 給定兩個字串 s 和 t ，寫一個函數來判斷 t 是否是 s 的字母異位詞。\n範例 1: 輸入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 輸出: true\n範例 2: 輸入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 輸出: false\n說明: 你可以假設字串只包含小寫字母。\n思路 # 暴力法：\n兩層 for 循環，同時還要記錄字符是否重複出現 時間複雜度是 O(n^2) Hashing：\n定一個陣列叫做 record，大小為 26 就可以了，初始化為 0，用來上記錄字串 s 裡字元出現的次數 解法 # class Solution { public: bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i \u0026lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.size(); i++) { record[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; 26; i++) { if (record[i] != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/valid-anagram/","section":"All my post","summary":"Valid Anagram","title":"Valid Anagram","type":"docs"},{"content":"Leetcode link : Design Linked List 描述 # get(index)：取得鍊錶中第 index 個節點的值。如果索引無效，則傳回-1。 addAtHead(val)：在鍊錶的第一個元素之前新增一個值為 val 的節點。插入後，新節點將成為鍊錶的第一個節點。 addAtTail(val)：將值為 val 的節點追加到鍊錶的最後一個元素。 addAtIndex(index,val)：在鍊錶中的第 index 個節點之前加入值為 val 的節點。如果 index 等於鍊錶的長度，則該節點將附加到鍊錶的末尾。如果 index 大於鍊錶長度，則不會插入節點。如果 index 小於 0，則在頭部插入節點。 deleteAtIndex(index)：如果索引 index 有效，則刪除鍊錶中的第 index 個節點。 解法 # // 时间复杂度：涉及 `index` 的相关操作为 O(index), 其余为 O(1) // 空间复杂度：O(n) class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-\u0026gt;next != nullptr){ cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入节点 void addAtIndex(int index, int val) { if(index \u0026gt; _size) return; if(index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; //delete命令指示释放了tmp指针原本所指的那部分内存， //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后， //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针 //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间 tmp=nullptr; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/design-linked-list/","section":"All my post","summary":"Design Linked List","title":"Design Linked List","type":"docs"},{"content":"Leetcode link : Linked List Cycle II 描述 # 給定一個鍊錶，返回鍊錶開始入環的第一個節點。 如果鍊錶無環，則傳回 null。 為了表示給定鍊錶中的環，使用整數 pos 來表示鍊錶尾連接到鍊錶中的位置（索引從 0 開始）。 如果 pos 是 -1，則在該鍊錶中沒有環。 思路 # fast 走兩個節點，slow 走一個節點 fast 指標走過的節點數 = slow 指標走過的節點數 * 2 (x + y) * 2 = x + y + n (y + z) -\u0026gt; x = (n - 1) (y + z) + z 若 n 為 1 則 x = z 意味著 fast 指針在環形裡轉了一圈之後，就遇到了 slow 指針了 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇 if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-\u0026gt;next; index2 = index2-\u0026gt;next; // 兩個一起往前直到相遇 一個從頭 一個從相遇點 } return index2; // 返回环的入口 } } return NULL; } }; // 时间复杂度：O(n) 快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/linked-list-cycle-ii/","section":"All my post","summary":"Linked List Cycle II","title":"Linked List Cycle II","type":"docs"},{"content":"","date":"2025-07-31","externalUrl":null,"permalink":"/tags/linkedlist/","section":"Tags","summary":"","title":"LinkedList","type":"tags"},{"content":"Leetcode link : Remove Linked List Elements 描述 # 刪除鍊錶中等於給定值 val 的所有節點。 範例 1： 輸入：head = [1,2,6,3,4,5,6], val = 6 輸出：[1,2,3,4,5] 思路 # 在單鍊錶中 移除頭結點 和 移除其他節點 的操作方式是不一樣，需要單獨寫一段邏輯來處理移除頭結點的情況。 其實可以設定一個 虛擬頭結點，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了。 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL \u0026amp;\u0026amp; head-\u0026gt;val == val) { // 注意这里不是if ListNode* tmp = head; head = head-\u0026gt;next; delete tmp; } // 删除非头结点 ListNode* cur = head; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next!= NULL) { if (cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } return head; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 所有的 linked list 的題目都可以設定一個 dummyHead，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了 ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-linked-list-elements/","section":"All my post","summary":"Remove Linked List Elements","title":"Remove Linked List Elements","type":"docs"},{"content":"Leetcode link : Remove Nth Node From End of List 描述 # 給一個鍊錶，刪除鍊錶的倒數第 n 個結點，並且回到鍊錶的頭結點。\n進階：你能嘗試使用一趟掃描實現嗎？\n輸入：head = [1,2,3,4,5], n = 2 輸出：[1,2,3,5]\n範例 2：輸入：head = [1], n = 1 輸出：[]\n範例 3：輸入：head = [1,2], n = 1 輸出：[1]\n思路 # 使用快慢指針 fast 先走 n + 1 步 ，為什麼是 n+1 呢，因為只有這樣同時移動的時候 slow 才能指向刪除節點的上一個節點 解法 # class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete tmp; return dummyHead-\u0026gt;next; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-nth-node-from-end-of-list/","section":"All my post","summary":"Remove Nth Node From End of List","title":"Remove Nth Node From End of List","type":"docs"},{"content":"Leetcode link : Reverse Linked List 描述 # 反轉一個單鍊錶。 輸入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 輸出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 思路 # 只需要 改變鍊錶的next指標的指向，直接將鍊錶反轉，不用重新定義一個新的鍊錶 流程 # 定義一個 cur 指針，指向頭 結點 再定義一個 pre 指針，初始化為 null 把 cur-\u0026gt;next 節點用 tmp 指針保存一下 改變 cur-\u0026gt;next 的指向了，將 cur-\u0026gt;next 指向 pre 繼續移動 pre 和 cur 指針 cur 指標已經指向了 null，循環結束，return pre 指針 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; // 时间复杂度：O(n) 要递归处理链表的每个节点 // 空间复杂度：O(n) 递归调用了 n 层栈空间 // 可以看到双指针法中初始化 cur = head，pre = NULL class Solution { public: ListNode* reverse(ListNode* pre,ListNode* cur){ if(cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); } ListNode* reverseList(ListNode* head) { // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/reverse-linked-list/","section":"All my post","summary":"Reverse Linked List","title":"Reverse Linked List","type":"docs"},{"content":"Leetcode link : Swap Nodes in Pairs 描述 # 給定一個鍊錶，兩兩交換其中相鄰的節點，並傳回交換後的鍊錶。\n不能只是單純的改變節點內部的值，而是需要實際的進行節點交換。\n思路 # 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 頭接給 2 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 2 接給 1 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 此時 cur 已經改接了 2, 1 因此需要把它接到 3 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } ListNode* result = dummyHead-\u0026gt;next; delete dummyHead; return result; } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/swap-nodes-in-pairs/","section":"All my post","summary":"Swap Nodes in Pairs","title":"Swap Nodes in Pairs","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/array/","section":"Tags","summary":"","title":"Array","type":"tags"},{"content":"Leetcode link : Minimum Size Subarray Sum 描述 # 給定一個含有 n 個正整數的數組和一個正整數 s 找出該數組中滿足其和 ≥ s 的長度最小的 連續 子數組 並返回其長度。 如果不存在符合條件的子數組，則傳回 0。 思路 # 暴力解法：兩個 for 循環，不斷的尋找符合條件的子序列 時間複雜度：O(n^2) 空間複雜度：O(1) Sliding window： 時間複雜度：O(n) 空間複雜度：O(1) 每次需詢問三個問題： 窗口內是什麼？ 如何移動視窗的起始位置？ 如何移動視窗的結束位置？ 此題為例： 窗口 -\u0026gt; 滿足其和 ≥ s 的長度最小的 連續 子數組。 視窗的起始位置如何移動 -\u0026gt; 如果目前視窗的值大於等於 s 了，視窗就要向前移動了（也就是該縮小了）。 視窗的結束位置如何移動 -\u0026gt; 視窗的結束位置就是遍歷數組的指針，也就是 for 迴圈裡的索引。 解法 # class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n) // - 空间复杂度：O(1) class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i \u0026lt; nums.size(); i++) { // 设置子序列起点为i sum = 0; for (int j = i; j \u0026lt; nums.size(); j++) { // 设置子序列终止位置为j sum += nums[j]; if (sum \u0026gt;= s) { // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break } } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n^2) // - 空间复杂度：O(1) 注意 # 不要以為 for 裡放一個 while 就以為是 O(n^2) 主要是看每一個元素被操作的次數 每個元素在滑動窗後進來操作一次，出去操作一次，每個元素都是被操作兩次 所以時間複雜度是 2 × n 也就是 O(n)。 ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/minimum-size-subarray-sum/","section":"All my post","summary":"Minimum Size Subarray Sum","title":"Minimum Size Subarray Sum","type":"docs"},{"content":"Leetcode link : Spiral Matrix II 描述 # 給定一個正整數 n，產生一個包含 1 到 n^2 所有元素，且元素以順時針順序螺旋排列的正方形矩陣。 思路 # 程式碼裡處理的原則統一的左閉右開 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop --) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j; j \u0026lt; n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i; i \u0026lt; n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j \u0026gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i \u0026gt; startx; i--) { res[i][j] = count++; } // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) { res[mid][mid] = count; } return res; } }; // - 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 // - 空间复杂度 O(1) ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/spiral-matrix-ii/","section":"All my post","summary":"Spiral Matrix II","title":"Spiral Matrix II","type":"docs"},{"content":"Leetcode link : Squares of a Sorted Array 描述 # 給一個按 非遞減順序 排序的整數數組 nums，返回 每個數字的平方 組成的新數組，要求也按 非遞減順序 排序。 思路 # 暴力解法：O(n + nlogn) 每個數平方之後，排個序 雙指標法：O(n) 數組其實是有序的， 只不過負數平方之後可能變成最大數了。 那麼陣列平方的最大值就在陣列的兩端，不是最左邊就是最右邊，不可能是中間。 i 指向起始位置，j 指向終止位置。 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0; i \u0026lt; A.size(); i++) { A[i] *= A[i]; } sort(A.begin(), A.end()); // 快速排序 return A; } }; // 时间复杂度：O(n + nlogn) // 空间复杂度：O(1) class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { int k = A.size() - 1; vector\u0026lt;int\u0026gt; result(A.size(), 0); for (int i = 0, j = A.size() - 1; i \u0026lt;= j;) { // 注意这里要i \u0026lt;= j，因为最后要处理两个元素 if (A[i] * A[i] \u0026lt; A[j] * A[j]) { result[k--] = A[j] * A[j]; j--; } else { result[k--] = A[i] * A[i]; i++; } } return result; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-05-04","externalUrl":null,"permalink":"/docs/squares-of-a-sorted-array/","section":"All my post","summary":"Squares of a Sorted Array","title":"Squares of a Sorted Array","type":"docs"},{"content":"Leetcode link : Binary Search 描述 # 二分法的前提條件 # 數組為有序數組 數組中無重複元素，一旦有重複元素，使用二分查找法傳回的元素下標可能不是唯一的 思路 # 左閉右閉即[left, right] 左閉右開即[left, right) 解法 # // 左閉右閉 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 左閉右閉，[left, right] int right = nums.size(); // 左閉右開，即：[left, right) while (left \u0026lt;= right) { // 左閉右閉，当left==right，区间[left, right]依然有效，所以用 \u0026lt;= while (left \u0026lt; right) { // 左閉右開，因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; // 左閉右閉 right = middle; // 左閉右開 } else if (nums[middle] \u0026lt; target) { left = middle + 1; } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 注意 # int middle = left + ((right - left) / 2); 防止溢出 等同于(left + right)/2 採用左閉右閉即 [left, right] 即可，左右剛好符合 Array 的編號 ","date":"2025-05-03","externalUrl":null,"permalink":"/docs/binary-search/","section":"All my post","summary":"Binary Search","title":"Binary Search","type":"docs"},{"content":"Leetcode link : Remove Element 描述 # 移除所有數值等於 val 的元素，並傳回移除後陣列的新長度 In-place : 必須僅使用 O(1) 額外空間並原地修改輸入數組 不需要考慮數組中超出新長度後面的元素 需考慮輸入的 Array 是否為 0 思路 # 暴力解法： O(n^2) 兩層 for 迴圈，一個 for 迴圈遍歷數組元素，第二個 for 迴圈更新數組 雙指針： O(n) 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-01-02","externalUrl":null,"permalink":"/docs/remove-element/","section":"All my post","summary":"Remove Element","title":"Remove Element","type":"docs"},{"content":" My Work experience # TSMC 2024/10 - present Software Engineer Implemented WebFlux to restructure API gateway into non-blocking architecture, significantly increasing request throughput and reducing response latency by 4x in p95. Optimized log filtering methods in middleware using Spring Boot, enhancing the efficiency of log analysis for system maintenance. Refactored SQL query methods in APIs, resulting in 3x improvement in API execution efficiency. Learned front-end development from zero in a month, and focused on developing and optimizing Lot Tracking System front-end features using Next.js and TypeScript. Rewrote R\u0026D system KPIs into Prometheus metrics, used Grafana for real-time monitoring and alerts, and optimized dashboard for managerial overview. KK company 2022/6 - 2023/7 Management Associate Executed AWS Lambda function via Python Boto3 to calculate internal AWS S3 \u0026 CDN usage, and used Python Logging and Pytest for unit testing. Implemented project integration in Gitlab repo, established reusable packages and used Gitlab CI/CD and Terraform for pipeline deployment planning. Applied TF-IDF algorithm to optimize information retrieval in the internal streaming platform recommendation system. NCCU 2021/9 - 2023/7 Master Degree Used the transformer-based model to generate and fine-tune embedding vectors for HTTP session classification, achieving 89.23% prediction accuracy in attack tactics. Applied session embedding algorithm based on DBSCAN to identify attack patterns and monitor attack progress for early-stage defense. Developed a data analysis dashboard using Django and Docker for real-time data analysis and visualization, reducing time and cost for information security personnel analyzing malicious attack logs and packets. My Skill stack # ","date":"2025-01-01","externalUrl":null,"permalink":"/self-introduction/","section":"","summary":"self-introduction","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]