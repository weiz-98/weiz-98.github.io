
[{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"Leetcode link : 3Sum 描述 # 給你一個包含 n 個整數的陣列 nums，判斷 nums 中是否存在三個元素 a，b，c ，使得 a + b + c = 0 ？請你找出所有符合條件且不重複的三元組。\n注意： 答案中不可以包含重複的三元組。\n範例：給定數組 nums = [-1, 0, 1, 2, -1, -4]，滿足要求的三元組集合為： [ [-1, 0, 1], [-1, -1, 2] ]\n思路 # Hashing：O(n^2)\n兩層 for 迴圈就可以確定 兩個數值 第三個數 0-(a+b) 或 0 - (a + c) 是否在 數組裡出現過 題目中說的不可以包含重複的三元組。 -\u0026gt; 把符合條件的三元組放進 vector 中，然後再去重，這樣是非常費時的，很容易超時， 實這題目使用 Hashing 並不十分合適，因為在去重的操作中有很多細節需要注意，在面試中很難直接寫出沒有 bug 的代碼。 Two pointer：O(n^2)\n先將數組排序，然後有一層 for 循環\ni 從下標 0 的地方開始 定一個下標 left 定義在 i+1 的位置上 定義下標 right 在數組結尾的位置上。 還是在陣列中找到 abc 使得 a + b +c =0\n相當於 a = nums[i]，b = nums[left]，c = nums[right]。 如何移動 left 和 right 呢\n如果 nums[i] + nums[left] + nums[right] \u0026gt; 0 說明 此時三數總和大了，因為數組是排序後了 所以 right 下標就應該向左移動，這樣才能讓三數之和小一些。 如果 nums[i] + nums[left] + nums[right] \u0026lt; 0 說明 此時 三數之和小了，left 就向右移動，才能讓三數總和大一些 直到 left 與 right 相遇為止。\n解法 # class Solution { public: // 在一个数组中找到3个数形成的三元组，它们的和为0，不能重复使用（三数下标互不相同），且三元组不能重复。 // b（存储）== 0-(a+c)（检索） vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i++) { // 如果a是正数，a\u0026lt;b\u0026lt;c，不可能形成和为0的三元组 if (nums[i] \u0026gt; 0) break; // [a, a, ...] 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; // 这个set的作用是存储b unordered_set\u0026lt;int\u0026gt; set; for (int k = i + 1; k \u0026lt; nums.size(); k++) { // 去重b=c时的b和c if (k \u0026gt; i + 2 \u0026amp;\u0026amp; nums[k] == nums[k - 1] \u0026amp;\u0026amp; nums[k - 1] == nums[k - 2]) continue; // a+b+c=0 \u0026lt;=\u0026gt; b=0-(a+c) int target = 0 - (nums[i] + nums[k]); if (set.find(target) != set.end()) { result.push_back({nums[i], target, nums[k]}); // nums[k]成为c set.erase(target); } else { set.insert(nums[k]); // nums[k]成为b } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n)，额外的 set 开销 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i \u0026lt; nums.size(); i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] \u0026gt; 0) { return result; } // 错误去重a方法，将会漏掉-1,-1,2 这种情况 /* if (nums[i] == nums[i + 1]) { continue; } */ // 正确去重a方法 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right\u0026lt;=left 了，从而漏掉了 0,0,0 这种三元组 /* while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; */ if (nums[i] + nums[left] + nums[right] \u0026gt; 0) right--; else if (nums[i] + nums[left] + nums[right] \u0026lt; 0) left++; else { result.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[left], nums[right]}); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 // 因為 nums[left] 和 nums[right] 這對數字已經被用過並且記錄成答案，我們必須把視窗向內縮，才能繼續尋找下一組可能的配對，同時避免死迴圈或重複答案。 right--; left++; } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) 注意 # 兩數和要求回傳的是索引下標，而雙指標法一定要排序，一旦排序之後原數組的索引就被改變了。 兩數和要求回傳的是數值的話，就可以使用雙指標法了。 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/3sum/","section":"All my post","summary":"3Sum","title":"3Sum","type":"docs"},{"content":"Leetcode link : 4Sum 描述 # 題意：給定一個包含 n 個整數的陣列 nums 和一個目標值 target 判斷 nums 中是否存在四個元素 a，b，c 和 d ，使得 a + b + c + d 的值與 target 相等- 找出所有滿足條件且不重複的四元組。 注意：答案中不可以包含重複的四元組。 例： 給定數組 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 滿足要求的四元組集合為： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 思路 # 基本解法就是在 三數和 的基礎上再套一層 for 循環 但有一些細節要注意，例如： 不要判斷 nums[k] \u0026gt; target 就回傳了，三數之和 可以透過 nums[i] \u0026gt; 0 就回傳了，因為 0 已經是確定的數了，四數之和這道題目 target 是任意值。 例如：陣列是[-4, -3, -2, -1]，target 是 -10，不能因為 -4 \u0026gt; -10 而跳過。但是我們依舊可以去做剪枝 邏輯變成 nums[k] \u0026gt; target \u0026amp;\u0026amp; (nums[k] \u0026gt;=0 || target \u0026gt;= 0)就可以了。 雙指針解法： 兩層 for 循環 nums[k] + nums[i]為確定值 依然是循環內有 left 和 right 下標作為雙指針 找出 nums[k] + nums[i] + nums[left] + nums[right] == target 的情況 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k \u0026lt; nums.size(); k++) { // 剪枝处理 if (nums[k] \u0026gt; target \u0026amp;\u0026amp; nums[k] \u0026gt;= 0) { break; // 这里使用break，统一通过最后的return返回 } // 对nums[k]去重 if (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } for (int i = k + 1; i \u0026lt; nums.size(); i++) { // 2级剪枝处理 if (nums[k] + nums[i] \u0026gt; target \u0026amp;\u0026amp; nums[k] + nums[i] \u0026gt;= 0) { // 因为只要 nums[k] + nums[i] \u0026gt; target，那么 nums[i] 后面的数都是正数的话，就一定 不符合条件了。 break; } // 对nums[i]去重 if (i \u0026gt; k + 1 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target 会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target) { right--; // nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target 会溢出 } else if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target) { left++; } else { result.push_back(vector\u0026lt;int\u0026gt;{nums[k], nums[i], nums[left], nums[right]}); // 对nums[left]和nums[right]去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; } } } } return result; } }; // 时间复杂度： O(n^3) // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum/","section":"All my post","summary":"4Sum","title":"4Sum","type":"docs"},{"content":"Leetcode link : 4Sum II 描述 # 給定四個包含整數的陣列列表 A , B , C , D ,計算有多少個元組 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n為了使問題簡單化，所有的 A, B, C, D 具有相同的長度 N，且 0 ≤ N ≤ 500 。所有整數的範圍在 -2^28 到 2^28 - 1 之間，最終結果不會超過 2^31 - 1 。\n輸入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 輸出: 2\n解釋: 兩個元組如下: (0, 0, 0, 1) -\u0026gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -\u0026gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n思路 # 暴力法：\n時間複雜度是 O(n^4) Hashing：\n先定義 一個 unordered_map，key 放 a 和 b 兩數和，value 放 a 和 b 兩數之和出現的次數。 遍歷大 A 和大 B 數組，統計兩個數組元素總和，和出現的次數，放到 map。 定義 int 變數 count，用來統計 a+b+c+d = 0 出現的次數。 再遍歷大 C 和大 D 數組，找出如果 0-(c+d) 在 map 中出現過的話，就用 count 把 map 中 key 對應的 value 也就是出現次數統計出來。 最後回傳統計值 count 就可以了 解法 # class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B, vector\u0026lt;int\u0026gt;\u0026amp; C, vector\u0026lt;int\u0026gt;\u0026amp; D) { unordered_map\u0026lt;int, int\u0026gt; umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 for (int a : A) { for (int b : B) { umap[a + b]++; } } int count = 0; // 统计a+b+c+d = 0 出现的次数 // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) { for (int d : D) { if (umap.find(0 - (c + d)) != umap.end()) { count += umap[0 - (c + d)]; } } } return count; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n^2) 最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum-ii/","section":"All my post","summary":"4Sum II","title":"4Sum II","type":"docs"},{"content":" 一些工作雜記.. ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/","section":"All my post","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  一些工作雜記..\n\u003c/div\u003e\n\n\u003chr\u003e","title":"All my post","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"Leetcode link : Find Common Characters 描述 # 給你一個字串陣列 words ，請你找出所有在 words 的每個字串中都出現的共用字元（ 包括重複字元），並以陣列形式傳回。你可以按 任意順序 返回答案。\n範例 1：輸入：words = [\u0026ldquo;bella\u0026rdquo;,\u0026ldquo;label\u0026rdquo;,\u0026ldquo;roller\u0026rdquo;] 輸出：[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;]\n範例 2：輸入：words = [\u0026ldquo;cool\u0026rdquo;,\u0026ldquo;lock\u0026rdquo;,\u0026ldquo;cook\u0026rdquo;] 輸出：[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\n提示：1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] 由小寫英文字母組成\n思路 # 暴力法：\n時間複雜度是 O(n^m) 一個字串一個字串去搜，n 是字串長度，m 是有幾個字串。 碼實現也不容易，因為要統計 重複的字符，還要適當的替換或去重 Hashing：\n統計出搜尋字串裡 26 個字元的出現的頻率 取每個字元頻率最小值，最後轉成輸出格式就可以了 解法 # class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; A) { vector\u0026lt;string\u0026gt; result; if (A.size() == 0) return result; int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率 for (int i = 0; i \u0026lt; A[0].size(); i++) { // 用第一个字符串给hash初始化 hash[A[0][i] - \u0026#39;a\u0026#39;]++; } int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率 for (int i = 1; i \u0026lt; A.size(); i++) { memset(hashOtherStr, 0, 26 * sizeof(int)); for (int j = 0; j \u0026lt; A[i].size(); j++) { hashOtherStr[A[i][j] - \u0026#39;a\u0026#39;]++; } // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数 for (int k = 0; k \u0026lt; 26; k++) { hash[k] = min(hash[k], hashOtherStr[k]); } } // 将hash统计的字符次数，转成输出形式 for (int i = 0; i \u0026lt; 26; i++) { while (hash[i] != 0) { // 注意这里是while，多个重复的字符 string s(1, i + \u0026#39;a\u0026#39;); // char -\u0026gt; string result.push_back(s); hash[i]--; } } return result; } }; // 时间复杂度：O(n) 所有字元的總數 // 空间复杂度：O(1) 每條字串長度都是固定常數 或 可視為相同平均長度 L 時候字元總數 N = n * L 於是時間複雜度為 n\n如果字串長度差異很大、或隨著輸入放大而成長，就必須把長度考慮進去，寫成 O(nL) or O(N)\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-common-characters/","section":"All my post","summary":"Find Common Characters","title":"Find Common Characters","type":"docs"},{"content":"Leetcode link : Find the Index of the First Occurrence in a String 描述 # 給定一個 haystack 字串和一個 needle 字串，在 haystack 字串中找出 needle 字串出現的第一個位置 (從 0 開始)。如果不存在，則傳回 -1。\n範例 1: 輸入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 輸出: 2\n範例 2: 輸入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 輸出: -1\n當 needle 是空字串時，我們該回傳什麼值呢？這是一個在面試中很好的問題。\n對本題而言，當 needle 是空字串時我們應當傳回 0 。這與 Java 的 indexOf() 定義相符。\n思路 # 使用 KMP j 指向「待比較的 pattern 位置」（亦代表當前已匹配長度）。 失配時 j = next[j-1] 讓我們「盡量利用已知最長前後綴」，避免從頭比。 整個迴圈 每個 i 與 j 只會單調遞增或回退一次 → O(m) 解法 # class Solution { public: void getNext(int* next, const string\u0026amp; s) { int j = 0; // 已匹配的字元長度 next[0] = 0; // s[0] 的 LPS 為 0 for (int i = 1; i \u0026lt; s.size(); ++i) { // 若失配：沿用「已知最長前後綴」繼續回溯 while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1]; // 若匹配：匹配長度 +1 if (s[i] == s[j]) ++j; next[i] = j; // 紀錄位置 i 的 LPS } } int strStr(string haystack, string needle) { if (needle.empty()) return 0; vector\u0026lt;int\u0026gt; next(needle.size()); getNext(next.data(), needle); // 建 LPS int j = 0; // pattern 指針 for (int i = 0; i \u0026lt; haystack.size(); ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]) j = next[j - 1]; // 失配 → 回跳 if (haystack[i] == needle[j]) ++j; // 匹配 → 雙指標前進 if (j == needle.size()) // 全部匹配完成 return i - j + 1; // 回傳起始索引 } return -1; // 未找到 } }; // 时间复杂度: O(n + m) m：建表 (getNext) , n：匹配 (strStr) // 空间复杂度: O(m) m：建表 (getNext) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-the-index-of-the-first-occurrence-in-a-string/","section":"All my post","summary":"Find the Index of the First Occurrence in a String","title":"Find the Index of the First Occurrence in a String","type":"docs"},{"content":"Leetcode link : Happy Number 描述 # 「快樂數」定義為：對於一個正整數，每一次將該數替換為它每個位置上的數字的平方和，然後重複這個過程直到這個數變為 1，也可能是 無限循環 但始終變不到 1。如果 可以變成 1，那麼這個數就是快樂數。\n如果 n 是快樂數就回傳 True ；不是，則回傳 False 。\n輸入：19 輸出：true\n解釋： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1\n思路 # 我們遇到了要快速判斷一個元素是否出現集合裡的時候，就要考慮 Hashing\n判斷這個 sum 是否重複出現，如果重複了就是 return false， 否則一直找到 sum 為 1。\n判斷 sum 是否重複出現就可以使用 unordered_set。\n解法 # class Solution { public: // 取数值各个位上的单数之和 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while(1) { int sum = getSum(n); if (sum == 1) { return true; } // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false if (set.find(sum) != set.end()) { return false; } else { set.insert(sum); } n = sum; } } }; // 时间复杂度： O(logn) // 空间复杂度： O(logn) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/happy-number/","section":"All my post","summary":"Happy Number","title":"Happy Number","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/hashing/","section":"Tags","summary":"","title":"Hashing","type":"tags"},{"content":"Leetcode link : Intersection of Two Arrays 描述 # 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n題目刻意說明：輸出結果中的每個元素一定是唯一的，也就是說輸出的結果的去重的， 同時可以不考慮輸出結果的順序 -\u0026gt; unordered_set\n而這題目沒有限制數值的大小 -\u0026gt; 無法使用陣列來做哈希表\n哈希值比較少、特別分散、跨度非常大，使用數組就會造成空間的極大浪費 -\u0026gt; 使用另一種結構體 set set 有三種資料結構 std::set -\u0026gt; 底層為紅黑樹 std::multiset -\u0026gt; 底層為紅黑樹 std::unordered_set -\u0026gt; 底層為 hash table -\u0026gt; 使用 unordered_set 讀寫效率最高，不需對資料進行排序，也不要讓資料重複 解法 # class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set; // 存放结果，之所以用set是为了给结果集去重 unordered_set\u0026lt;int\u0026gt; nums_set(nums1.begin(), nums1.end()); for (int num : nums2) { // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(), result_set.end()); } }; // 时间复杂度： O(n + m) nums1 = n, nums2 = m // k 是最后要把 set 转成 vector 但因為長度必定小於 m or n 因此最終為 O(n + m) // 空间复杂度： O(n + k) nums_set = n, result_set = k 注意 # 遇到哈希問題我直接都用 set 不就得了，用什麼數組啊？ 直接使用 set 不僅佔空間比陣列大，而且速度要比陣列慢 set 把數值映射到 key 上都要做 hash 計算的。 不要小瞧 這個耗時，在數據量大的情況，差距是很明顯的。 當題目有限制較小的數值範圍時，例如：1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 就可以把 array 作為 hash，若範圍過大則採用 unordered_set ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/intersection-of-two-arrays/","section":"All my post","summary":"Intersection of Two Arrays","title":"Intersection of Two Arrays","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Leetcode link : Ransom Note 描述 # 給定一個贖金信 (ransom) 字串和一個雜誌 (magazine) 字串，判斷第一個字串 ransom 能不能由第二個字串 magazines 裡面的字構成。如果可以構成，則傳回 true ；否則傳回 false。\n(題目說明：為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思。雜誌字串中的每個字元只能在贖金信字串中使用一次。)\n注意：你可以假設兩個字串均只含有小寫字母。 canConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n思路 # 「為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思」 這裡說明雜誌裡面的字母不可重複使用。 「你可以假設兩個字串都只含有小寫字母。」 說明只有小寫字母 解法 # class Solution { public: bool canConstruct(string ransomNote, string magazine) { for (int i = 0; i \u0026lt; magazine.length(); i++) { for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 在ransomNote中找到和magazine相同的字符 if (magazine[i] == ransomNote[j]) { ransomNote.erase(ransomNote.begin() + j); // ransomNote删除这个字符 break; } } } // 如果ransomNote为空，则说明magazine的字符可以组成ransomNote if (ransomNote.length() == 0) { return true; } return false; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) class Solution { public: bool canConstruct(string ransomNote, string magazine) { int record[26] = {0}; //add if (ransomNote.size() \u0026gt; magazine.size()) { return false; } for (int i = 0; i \u0026lt; magazine.length(); i++) { // 通过record数据记录 magazine里各个字符出现次数 record[magazine[i]-\u0026#39;a\u0026#39;] ++; } for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 遍历ransomNote，在record里对应的字符个数做--操作 record[ransomNote[j]-\u0026#39;a\u0026#39;]--; // 如果小于零说明ransomNote里出现的字符，magazine没有 if(record[ransomNote[j]-\u0026#39;a\u0026#39;] \u0026lt; 0) { return false; } } return true; } }; // 时间复杂度： O(m+n)，其中m表示ransomNote的长度，n表示magazine的长度 // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/ransom-note/","section":"All my post","summary":"Ransom Note","title":"Ransom Note","type":"docs"},{"content":"Leetcode link : Repeated Substring Pattern 描述 # 給定一個非空的字串，判斷它是否可以由它的一個子字串重複多次構成。\n給定的字串只含有小寫英文字母，且長度不超過10000\n輸入: \u0026ldquo;abcabcabcabc\u0026rdquo; 輸出: True\n解釋: 可由子字串 \u0026ldquo;abc\u0026rdquo; 重複四次構成。 (或子字串 \u0026ldquo;abcabc\u0026rdquo; 重複兩次構成。)\n思路 # 暴力法：O(n^2) 一個 for 迴圈取得 子字串的終止位置， 然後判斷子字串是否能重複構成字串，又嵌套一個 for 循環 其實我們只要判斷，以第一個字母為開始的子字串就可以 所以一個 for 迴圈取得子字串的終止位置就行了。 遍歷的時候 都不用遍歷結束，只需要遍歷到中間位置 因為子字串結束位置大於中間位置的話，一定不能重複組成字串 把 s 拼成 s+s 後再掐頭去尾，檢查 s 是否仍能出現在中間：O(n+m) find 為標準函式庫 -\u0026gt; 保證最壞 O(n+m) 使用 KMP getNext 計算 最長公共前後綴長度 解法 # bool repeatedSubstringPattern_bruteforce(const string\u0026amp; s) { int n = s.size(); if (n \u0026lt; 2) return false; // 長度 0 或 1 不可能 for (int len = 1; len \u0026lt;= n / 2; ++len) { if (n % len != 0) continue; // len 不是 n 的因數，直接跳過 bool ok = true; // 檢查第 len..n-1 位置的字元，是否與對應的 s[i-len] 相同 for (int i = len; i \u0026lt; n \u0026amp;\u0026amp; ok; ++i) { if (s[i] != s[i - len]) ok = false; } if (ok) return true; // 找到一組合法的 len } return false; } // 时间复杂度：O(n^2) // 空间复杂度：O(1) class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾 if (t.find(s) != std::string::npos) return true; // r return false; } }; // 時間複雜度為 O(n)（find 掃字串） // 空間複雜度 O(n)（存 t）。 class Solution { public: void getNext (int* next, const string\u0026amp; s){ next[0] = 0; // 第 0 個字元的 LPS 永遠是 0 int j = 0; // j = 目前可延續的最長匹配長度 for(int i = 1;i \u0026lt; s.size(); i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) { j = next[j - 1]; // 失配：退回上一個可用的 LPS } if(s[i] == s[j]) { j++; // 成功配對，匹配長度 +1 } next[i] = j; // 記錄 i 位置對應的 LPS } } bool repeatedSubstringPattern (string s) { if (s.size() == 0) { return false; } int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 \u0026amp;\u0026amp; len % (len - (next[len - 1] )) == 0) { return true; } return false; } }; // 時間複雜度為 O(n) // 空間複雜度 O(n) 注意 # 若字串由子字串 p 重複組成\n設 |p| = k，重複 m 次 (len = k·m)。\n整條字串的最長公共前後綴就是 p 重複 m-1 次 → 長度 len - k。\n因此 lps = len - k，且 k = len - lps。\n此時 len % k == 0 成立。\n若條件成立，必有重複子字串\nlps \u0026gt; 0 ⇒ 至少有一段前綴同時也是後綴。\nk = len - lps 為可能的週期長度。\n若 len % k == 0，把長度 k 的子字串複製 m = len/k 次即可拼回原字串。\n反例不可能通過測試\n若字串並非週期字串，lps 只能小於真正週期長度或為 0。\n即使 lps \u0026gt; 0，len % (len-lps) 也必定不等於 0。\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/repeated-substring-pattern/","section":"All my post","summary":"Repeated Substring Pattern","title":"Repeated Substring Pattern","type":"docs"},{"content":"Leetcode link : Reverse String 描述 # 寫一個函數，其作用是將輸入的字串反轉過來。輸入字串以字元數組 char[] 的形式給出。\n不要給另外的陣列分配額外的空間，你必須原地修改輸入陣列、使用 O(1) 的額外空間解決這個問題。\n你可以假設數組中的所有字元都是 ASCII 碼表中的可列印字元。\n思路 # swap 可以有兩種實現 常見的交換數值 過位元運算 // 1 int tmp = s[i]; s[i] = s[j]; s[j] = tmp; // 2 s[i] ^= s[j]; s[j] ^= s[i]; s[i] ^= s[j]; 解法 # class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for (int i = 0, j = s.size() - 1; i \u0026lt; s.size()/2; i++, j--) { swap(s[i],s[j]); } } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string/","section":"All my post","summary":"Reverse String","title":"Reverse String","type":"docs"},{"content":"Leetcode link : Reverse String II 描述 # 給定一個字串 s 和一個整數 k，從字串開頭算起, 每計數至 2k 個字符，就反轉這 2k 個字符中的前 k 個字符。\n如果剩餘字元少於 k 個，則將剩餘字元全部反轉。\n如果剩餘字符小於 2k 但大於或等於 k 個，則反轉前 k 個字符，其餘字符保持原樣。\n範例:輸入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 輸出: \u0026ldquo;bacdfeg\u0026rdquo;\n思路 # 在遍歷字串的過程中，只要讓 i += (2 * k) i 每次移動 2 \\* k 就可以了，然後判斷是否需要有反轉的區間。 因為要找的也就是每 2 * k 區間的起點 當需要固定規律一段一段去處理字串的時候，要想想在 for 迴圈的表達式上做做文章。 解法 # class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += (2 * k)) { // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k \u0026lt;= s.size()) { reverse(s.begin() + i, s.begin() + i + k ); } else { // 3. 剩余字符少于 k 个，则将剩余字符全部反转。 reverse(s.begin() + i, s.end()); } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string-ii/","section":"All my post","summary":"Reverse String II","title":"Reverse String II","type":"docs"},{"content":"Leetcode link : Reverse Words in a String 描述 # 輸入: \u0026quot; hello world! \u0026quot; 輸出: \u0026ldquo;world! hello\u0026rdquo;\n解釋: 輸入字串可以在前面或後麵包含多餘的空格，但是反轉後的字元不能包括。\n輸入: \u0026ldquo;a good example\u0026rdquo; 輸出: \u0026ldquo;example good a\u0026rdquo;\n解釋: 如果兩個字間有多餘的空格，將反轉後字間的空格減少到只含一個。\n不要使用輔助空間，空間複雜度要求為 O(1)\n思路 # 移除多餘空格 將整個字串反轉 將每個單字反轉 解法 # void removeExtraSpaces(string\u0026amp; s) { for (int i = s.size() - 1; i \u0026gt; 0; i--) { if (s[i] == s[i - 1] \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) { s.erase(s.begin() + i); } } // 删除字符串最后面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[s.size() - 1] == \u0026#39; \u0026#39;) { s.erase(s.begin() + s.size() - 1); } // 删除字符串最前面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[0] == \u0026#39; \u0026#39;) { s.erase(s.begin()); } } // 时间复杂度：O(n^2) // 一个 erase 本来就是O(n)的操作 而 erase 操作上面还套了一个 for 循环 // 空间复杂度：O(1) 使用雙指標法來去移除空格，最後 resize（重新設定）一下字串的大小，就可以做到 O(n)的時間複雜度。\n//版本一 void removeExtraSpaces(string\u0026amp; s) { int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针 // 去掉字符串前面的空格 while (s.size() \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; s.size() \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { fastIndex++; } for (; fastIndex \u0026lt; s.size(); fastIndex++) { // 去掉字符串中间部分的冗余空格 if (fastIndex - 1 \u0026gt; 0 // 只有當 fastIndex 至少為 1 時，才去讀 s[fastIndex-1]」，避免在 fastIndex==0 時往左越界 \u0026amp;\u0026amp; s[fastIndex - 1] == s[fastIndex] \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { continue; } else { s[slowIndex++] = s[fastIndex]; } } if (slowIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[slowIndex - 1] == \u0026#39; \u0026#39;) { // 去掉字符串末尾的空格 s.resize(slowIndex - 1); } else { s.resize(slowIndex); // 重新设置字符串大小 } } 精簡後的完整如下\nclass Solution { public: void reverse(string\u0026amp; s, int start, int end) { // 翻转，区间写法：左闭右闭 [] for (int i = start, j = end; i \u0026lt; j; i++, j--) { swap(s[i], s[j]); } } void removeExtraSpaces(string\u0026amp; s) { // 去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0, fast = 0, n = s.size(); // 跳過前導空格 while (fast \u0026lt; n \u0026amp;\u0026amp; s[fast] == \u0026#39; \u0026#39;) ++fast; for (; fast \u0026lt; n; ++fast) { // 如果當前字元是空格，而且前一個已經是空格，略過 if (s[fast] == \u0026#39; \u0026#39; \u0026amp;\u0026amp; (slow == 0 || s[slow - 1] == \u0026#39; \u0026#39;)) continue; s[slow++] = s[fast]; } // 移除尾端空格（可能剛好停在一格空白） if (slow \u0026gt; 0 \u0026amp;\u0026amp; s[slow - 1] == \u0026#39; \u0026#39;) --slow; s.resize(slow); // 調整字串實際長度 } string reverseWords(string s) { removeExtraSpaces( s); // 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; // removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i \u0026lt;= s.size(); ++i) { if (i == s.size() || s[i] == \u0026#39; \u0026#39;) { // 到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); // 翻转，注意是左闭右闭 []的翻转。 start = i + 1; // 更新下一个单词的开始下标start } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) 或 O(n)，取决于语言中字符串是否可变 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-words-in-a-string/","section":"All my post","summary":"Reverse Words in a String","title":"Reverse Words in a String","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/string/","section":"Tags","summary":"","title":"String","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Leetcode link : Two Sum 描述 # 給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那兩個整數，並返回他們的數組下標。\n你可以假設每個輸入只會對應一個答案。但是，數組中同一個元素不能使用兩次。\n範例:\n已知 nums = [2, 7, 11, 15], target = 9 為 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n判斷元素是否出現，這個元素就要當 key，所以數組中的元素作為 key，有 key 對應的就是 value，value 用來存下標。 map 中的儲存結構為 {key：資料元素，value：陣列元素對應的下標}。 解法 # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i = 0; i \u0026lt; nums.size(); i++) { // 遍历当前元素，并在map中寻找是否有匹配的key auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter-\u0026gt;second, i}; // first ➜ 這筆資料的 Key（這裡是數值 nums[i]） // second ➜ 這筆資料的 Value（這裡是索引 i） } // 如果没找到匹配对，就把访问过的元素和下标加入到map中 map.insert(pair\u0026lt;int, int\u0026gt;(nums[i], i)); } return {}; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/two-sum/","section":"All my post","summary":"Two Sum","title":"Two Sum","type":"docs"},{"content":"Leetcode link : Valid Anagram 描述 # 給定兩個字串 s 和 t ，寫一個函數來判斷 t 是否是 s 的字母異位詞。\n範例 1: 輸入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 輸出: true\n範例 2: 輸入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 輸出: false\n說明: 你可以假設字串只包含小寫字母。\n思路 # 暴力法：\n兩層 for 循環，同時還要記錄字符是否重複出現 時間複雜度是 O(n^2) Hashing：\n定一個陣列叫做 record，大小為 26 就可以了，初始化為 0，用來上記錄字串 s 裡字元出現的次數 解法 # class Solution { public: bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i \u0026lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.size(); i++) { record[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; 26; i++) { if (record[i] != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/valid-anagram/","section":"All my post","summary":"Valid Anagram","title":"Valid Anagram","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/authors/wz-chen/","section":"Authors","summary":"","title":"WZ Chen","type":"authors"},{"content":"Leetcode link : Design Linked List 描述 # get(index)：取得鍊錶中第 index 個節點的值。如果索引無效，則傳回-1。 addAtHead(val)：在鍊錶的第一個元素之前新增一個值為 val 的節點。插入後，新節點將成為鍊錶的第一個節點。 addAtTail(val)：將值為 val 的節點追加到鍊錶的最後一個元素。 addAtIndex(index,val)：在鍊錶中的第 index 個節點之前加入值為 val 的節點。如果 index 等於鍊錶的長度，則該節點將附加到鍊錶的末尾。如果 index 大於鍊錶長度，則不會插入節點。如果 index 小於 0，則在頭部插入節點。 deleteAtIndex(index)：如果索引 index 有效，則刪除鍊錶中的第 index 個節點。 解法 # // 时间复杂度：涉及 `index` 的相关操作为 O(index), 其余为 O(1) // 空间复杂度：O(n) class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-\u0026gt;next != nullptr){ cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入节点 void addAtIndex(int index, int val) { if(index \u0026gt; _size) return; if(index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; //delete命令指示释放了tmp指针原本所指的那部分内存， //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后， //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针 //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间 tmp=nullptr; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/design-linked-list/","section":"All my post","summary":"Design Linked List","title":"Design Linked List","type":"docs"},{"content":"Leetcode link : Linked List Cycle II 描述 # 給定一個鍊錶，返回鍊錶開始入環的第一個節點。 如果鍊錶無環，則傳回 null。 為了表示給定鍊錶中的環，使用整數 pos 來表示鍊錶尾連接到鍊錶中的位置（索引從 0 開始）。 如果 pos 是 -1，則在該鍊錶中沒有環。 思路 # fast 走兩個節點，slow 走一個節點 fast 指標走過的節點數 = slow 指標走過的節點數 * 2 (x + y) * 2 = x + y + n (y + z) -\u0026gt; x = (n - 1) (y + z) + z 若 n 為 1 則 x = z 意味著 fast 指針在環形裡轉了一圈之後，就遇到了 slow 指針了 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇 if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-\u0026gt;next; index2 = index2-\u0026gt;next; // 兩個一起往前直到相遇 一個從頭 一個從相遇點 } return index2; // 返回环的入口 } } return NULL; } }; // 时间复杂度：O(n) 快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/linked-list-cycle-ii/","section":"All my post","summary":"Linked List Cycle II","title":"Linked List Cycle II","type":"docs"},{"content":"","date":"2025-07-31","externalUrl":null,"permalink":"/tags/linkedlist/","section":"Tags","summary":"","title":"LinkedList","type":"tags"},{"content":"Leetcode link : Remove Linked List Elements 描述 # 刪除鍊錶中等於給定值 val 的所有節點。 範例 1： 輸入：head = [1,2,6,3,4,5,6], val = 6 輸出：[1,2,3,4,5] 思路 # 在單鍊錶中 移除頭結點 和 移除其他節點 的操作方式是不一樣，需要單獨寫一段邏輯來處理移除頭結點的情況。 其實可以設定一個 虛擬頭結點，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了。 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL \u0026amp;\u0026amp; head-\u0026gt;val == val) { // 注意这里不是if ListNode* tmp = head; head = head-\u0026gt;next; delete tmp; } // 删除非头结点 ListNode* cur = head; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next!= NULL) { if (cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } return head; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 所有的 linked list 的題目都可以設定一個 dummyHead，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了 ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-linked-list-elements/","section":"All my post","summary":"Remove Linked List Elements","title":"Remove Linked List Elements","type":"docs"},{"content":"Leetcode link : Remove Nth Node From End of List 描述 # 給一個鍊錶，刪除鍊錶的倒數第 n 個結點，並且回到鍊錶的頭結點。\n進階：你能嘗試使用一趟掃描實現嗎？\n輸入：head = [1,2,3,4,5], n = 2 輸出：[1,2,3,5]\n範例 2：輸入：head = [1], n = 1 輸出：[]\n範例 3：輸入：head = [1,2], n = 1 輸出：[1]\n思路 # 使用快慢指針 fast 先走 n + 1 步 ，為什麼是 n+1 呢，因為只有這樣同時移動的時候 slow 才能指向刪除節點的上一個節點 解法 # class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete tmp; return dummyHead-\u0026gt;next; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-nth-node-from-end-of-list/","section":"All my post","summary":"Remove Nth Node From End of List","title":"Remove Nth Node From End of List","type":"docs"},{"content":"Leetcode link : Reverse Linked List 描述 # 反轉一個單鍊錶。 輸入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 輸出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 思路 # 只需要 改變鍊錶的next指標的指向，直接將鍊錶反轉，不用重新定義一個新的鍊錶 流程 # 定義一個 cur 指針，指向頭 結點 再定義一個 pre 指針，初始化為 null 把 cur-\u0026gt;next 節點用 tmp 指針保存一下 改變 cur-\u0026gt;next 的指向了，將 cur-\u0026gt;next 指向 pre 繼續移動 pre 和 cur 指針 cur 指標已經指向了 null，循環結束，return pre 指針 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; // 时间复杂度：O(n) 要递归处理链表的每个节点 // 空间复杂度：O(n) 递归调用了 n 层栈空间 // 可以看到双指针法中初始化 cur = head，pre = NULL class Solution { public: ListNode* reverse(ListNode* pre,ListNode* cur){ if(cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); } ListNode* reverseList(ListNode* head) { // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/reverse-linked-list/","section":"All my post","summary":"Reverse Linked List","title":"Reverse Linked List","type":"docs"},{"content":"Leetcode link : Swap Nodes in Pairs 描述 # 給定一個鍊錶，兩兩交換其中相鄰的節點，並傳回交換後的鍊錶。\n不能只是單純的改變節點內部的值，而是需要實際的進行節點交換。\n思路 # 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 頭接給 2 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 2 接給 1 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 此時 cur 已經改接了 2, 1 因此需要把它接到 3 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } ListNode* result = dummyHead-\u0026gt;next; delete dummyHead; return result; } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/swap-nodes-in-pairs/","section":"All my post","summary":"Swap Nodes in Pairs","title":"Swap Nodes in Pairs","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/array/","section":"Tags","summary":"","title":"Array","type":"tags"},{"content":"Leetcode link : Minimum Size Subarray Sum 描述 # 給定一個含有 n 個正整數的數組和一個正整數 s 找出該數組中滿足其和 ≥ s 的長度最小的 連續 子數組 並返回其長度。 如果不存在符合條件的子數組，則傳回 0。 思路 # 暴力解法：兩個 for 循環，不斷的尋找符合條件的子序列 時間複雜度：O(n^2) 空間複雜度：O(1) Sliding window： 時間複雜度：O(n) 空間複雜度：O(1) 每次需詢問三個問題： 窗口內是什麼？ 如何移動視窗的起始位置？ 如何移動視窗的結束位置？ 此題為例： 窗口 -\u0026gt; 滿足其和 ≥ s 的長度最小的 連續 子數組。 視窗的起始位置如何移動 -\u0026gt; 如果目前視窗的值大於等於 s 了，視窗就要向前移動了（也就是該縮小了）。 視窗的結束位置如何移動 -\u0026gt; 視窗的結束位置就是遍歷數組的指針，也就是 for 迴圈裡的索引。 解法 # class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n) // - 空间复杂度：O(1) class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i \u0026lt; nums.size(); i++) { // 设置子序列起点为i sum = 0; for (int j = i; j \u0026lt; nums.size(); j++) { // 设置子序列终止位置为j sum += nums[j]; if (sum \u0026gt;= s) { // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break } } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n^2) // - 空间复杂度：O(1) 注意 # 不要以為 for 裡放一個 while 就以為是 O(n^2) 主要是看每一個元素被操作的次數 每個元素在滑動窗後進來操作一次，出去操作一次，每個元素都是被操作兩次 所以時間複雜度是 2 × n 也就是 O(n)。 ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/minimum-size-subarray-sum/","section":"All my post","summary":"Minimum Size Subarray Sum","title":"Minimum Size Subarray Sum","type":"docs"},{"content":"Leetcode link : Spiral Matrix II 描述 # 給定一個正整數 n，產生一個包含 1 到 n^2 所有元素，且元素以順時針順序螺旋排列的正方形矩陣。 思路 # 程式碼裡處理的原則統一的左閉右開 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop --) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j; j \u0026lt; n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i; i \u0026lt; n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j \u0026gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i \u0026gt; startx; i--) { res[i][j] = count++; } // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) { res[mid][mid] = count; } return res; } }; // - 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 // - 空间复杂度 O(1) ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/spiral-matrix-ii/","section":"All my post","summary":"Spiral Matrix II","title":"Spiral Matrix II","type":"docs"},{"content":"Leetcode link : Squares of a Sorted Array 描述 # 給一個按 非遞減順序 排序的整數數組 nums，返回 每個數字的平方 組成的新數組，要求也按 非遞減順序 排序。 思路 # 暴力解法：O(n + nlogn) 每個數平方之後，排個序 雙指標法：O(n) 數組其實是有序的， 只不過負數平方之後可能變成最大數了。 那麼陣列平方的最大值就在陣列的兩端，不是最左邊就是最右邊，不可能是中間。 i 指向起始位置，j 指向終止位置。 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0; i \u0026lt; A.size(); i++) { A[i] *= A[i]; } sort(A.begin(), A.end()); // 快速排序 return A; } }; // 时间复杂度：O(n + nlogn) // 空间复杂度：O(1) class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { int k = A.size() - 1; vector\u0026lt;int\u0026gt; result(A.size(), 0); for (int i = 0, j = A.size() - 1; i \u0026lt;= j;) { // 注意这里要i \u0026lt;= j，因为最后要处理两个元素 if (A[i] * A[i] \u0026lt; A[j] * A[j]) { result[k--] = A[j] * A[j]; j--; } else { result[k--] = A[i] * A[i]; i++; } } return result; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-05-04","externalUrl":null,"permalink":"/docs/squares-of-a-sorted-array/","section":"All my post","summary":"Squares of a Sorted Array","title":"Squares of a Sorted Array","type":"docs"},{"content":"Leetcode link : Binary Search 描述 # 二分法的前提條件 # 數組為有序數組 數組中無重複元素，一旦有重複元素，使用二分查找法傳回的元素下標可能不是唯一的 思路 # 左閉右閉即[left, right] 左閉右開即[left, right) 解法 # // 左閉右閉 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 左閉右閉，[left, right] int right = nums.size(); // 左閉右開，即：[left, right) while (left \u0026lt;= right) { // 左閉右閉，当left==right，区间[left, right]依然有效，所以用 \u0026lt;= while (left \u0026lt; right) { // 左閉右開，因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; // 左閉右閉 right = middle; // 左閉右開 } else if (nums[middle] \u0026lt; target) { left = middle + 1; } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 注意 # int middle = left + ((right - left) / 2); 防止溢出 等同于(left + right)/2 採用左閉右閉即 [left, right] 即可，左右剛好符合 Array 的編號 ","date":"2025-05-03","externalUrl":null,"permalink":"/docs/binary-search/","section":"All my post","summary":"Binary Search","title":"Binary Search","type":"docs"},{"content":"Leetcode link : Remove Element 描述 # 移除所有數值等於 val 的元素，並傳回移除後陣列的新長度 In-place : 必須僅使用 O(1) 額外空間並原地修改輸入數組 不需要考慮數組中超出新長度後面的元素 需考慮輸入的 Array 是否為 0 思路 # 暴力解法： O(n^2) 兩層 for 迴圈，一個 for 迴圈遍歷數組元素，第二個 for 迴圈更新數組 雙指針： O(n) 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-01-02","externalUrl":null,"permalink":"/docs/remove-element/","section":"All my post","summary":"Remove Element","title":"Remove Element","type":"docs"},{"content":" My Work experience # TSMC 2024/10 - present Software Engineer Implemented WebFlux to restructure API gateway into non-blocking architecture, significantly increasing request throughput and reducing response latency by 4x in p95. Optimized log filtering methods in middleware using Spring Boot, enhancing the efficiency of log analysis for system maintenance. Refactored SQL query methods in APIs, resulting in 3x improvement in API execution efficiency. Learned front-end development from zero in a month, and focused on developing and optimizing Lot Tracking System front-end features using Next.js and TypeScript. Rewrote R\u0026D system KPIs into Prometheus metrics, used Grafana for real-time monitoring and alerts, and optimized dashboard for managerial overview. KK company 2022/6 - 2023/7 Management Associate Executed AWS Lambda function via Python Boto3 to calculate internal AWS S3 \u0026 CDN usage, and used Python Logging and Pytest for unit testing. Implemented project integration in Gitlab repo, established reusable packages and used Gitlab CI/CD and Terraform for pipeline deployment planning. Applied TF-IDF algorithm to optimize information retrieval in the internal streaming platform recommendation system. NCCU 2021/9 - 2023/7 Master Degree Used the transformer-based model to generate and fine-tune embedding vectors for HTTP session classification, achieving 89.23% prediction accuracy in attack tactics. Applied session embedding algorithm based on DBSCAN to identify attack patterns and monitor attack progress for early-stage defense. Developed a data analysis dashboard using Django and Docker for real-time data analysis and visualization, reducing time and cost for information security personnel analyzing malicious attack logs and packets. My Skill stack # ","date":"2025-01-01","externalUrl":null,"permalink":"/self-introduction/","section":"","summary":"self-introduction","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]