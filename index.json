
[{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" 一些工作雜記.. ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/","section":"All my post","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  一些工作雜記..\n\u003c/div\u003e\n\n\u003chr\u003e","title":"All my post","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"Leetcode link : Balanced Binary Tree 思路 # 判斷對稱二元樹要比較的是哪兩個節點，要比較的不是左右節點！\n對於二元樹是否對稱，要比較的是根節點的左子樹與右子樹是不是相互翻轉的\n在遞歸遍歷的過程中，也是要同時遍兩棵樹\n只能是 後序遍歷，因為我們要透過遞歸函數的返回值來判斷兩個子樹的內側節點和外側節點是否相等\n要比較內側和外側節點 -\u0026gt; 遍歷順序是左右中\n遞迴法\n確定遞歸函數的參數和返回值 要比較的是根節點的兩個子樹是否是互相翻轉的 -\u0026gt; 所以要比較的是兩個樹 -\u0026gt; 參數自然也是左子樹節點和右子樹節點。 傳回值自然是 bool 型別。 確定終止條件 要把兩個節點為空的情況弄清楚！否則後面比較數值的時候就會操作空指標了\n節點為空的情況有：\n左節點為空，右節點不為空，不對稱，return false 左不為空，右為空，不對稱 return false 左右都為空，對稱，回傳 true 確定單層遞歸的邏輯 處理 左右節點都不為空，且數值相同的情況。 比較二元樹外側是否對稱：傳入的是左節點的左孩子，右節點的右孩子。 比較內側是否對稱 -\u0026gt; 傳入左節點的右孩子，右節點的左孩子。 如果左右都對稱就回傳 true ，有一側不對稱就回傳 false 。 迭代法\n不是前中後序的迭代寫法，因為本題的本質是判斷兩個樹是否是相互翻轉的，其實已經不是所謂二元樹遍歷的前中後序的關係了。\n比較兩個樹（根節點的左右子樹）是否要互相翻轉，（注意這不是層序遍歷）\n使用 queue 使用 stack 其實是把左右兩個子樹要比較的元素順序放進一個容器，然後成對成對的取出來進行比較，那麼其實使用 stack 也是可以的。 只要把 queue 原封不動的改成 stack 就可以了 解法 # post order recursive # class Solution { public: bool compare(TreeNode* left, TreeNode* right) { // 首先排除空节点的情况 if (left == NULL \u0026amp;\u0026amp; right != NULL) return false; else if (left != NULL \u0026amp;\u0026amp; right == NULL) return false; else if (left == NULL \u0026amp;\u0026amp; right == NULL) return true; // 排除了空节点，再排除数值不相同的情况 else if (left-\u0026gt;val != right-\u0026gt;val) return false; // 此时就是：左右节点都不为空，且数值相同的情况 // 此时才做递归，做下一层的判断 bool outside = compare(left-\u0026gt;left, right-\u0026gt;right); // 左子树：左、 右子树：右 bool inside = compare(left-\u0026gt;right, right-\u0026gt;left); // 左子树：右、 右子树：左 bool isSame = outside \u0026amp;\u0026amp; inside; // 左子树：中、 右子树：中 （逻辑处理） return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root-\u0026gt;left, root-\u0026gt;right); } }; // 时间复杂度： O(n) 樹共有 n 個節點 // 空间复杂度： O(logn) 為樹高 h post order iterative with queue # class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root-\u0026gt;left); // 将左子树头结点加入队列 que.push(root-\u0026gt;right); // 将右子树头结点加入队列 while (!que.empty()) { // 接下来就要判断这两个树是否相互翻转 TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode \u0026amp;\u0026amp; !rightNode) { // 左节点为空、右节点为空，此时说明是对称的 continue; } // 左右一个节点不为空，或者都不为空但数值不相同，返回false if ((!leftNode || !rightNode || (leftNode-\u0026gt;val != rightNode-\u0026gt;val))) { return false; } que.push(leftNode-\u0026gt;left); // 加入左节点左孩子 que.push(rightNode-\u0026gt;right); // 加入右节点右孩子 que.push(leftNode-\u0026gt;right); // 加入左节点右孩子 que.push(rightNode-\u0026gt;left); // 加入右节点左孩子 } return true; } }; // 时间复杂度： O(n) // 空间复杂度： O(w) ： w 為最大寬度 介於 O(1) 與 O(n) (完全二元最底層約有 n/2 個節點)之間 post order iterative with stack # class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack\u0026lt;TreeNode*\u0026gt; st; // 这里改成了栈 st.push(root-\u0026gt;left); st.push(root-\u0026gt;right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode \u0026amp;\u0026amp; !rightNode) { continue; } if ((!leftNode || !rightNode || (leftNode-\u0026gt;val != rightNode-\u0026gt;val))) { return false; } st.push(leftNode-\u0026gt;left); st.push(rightNode-\u0026gt;right); st.push(leftNode-\u0026gt;right); st.push(rightNode-\u0026gt;left); } return true; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：最佳／平均（平衡樹: O(logn) 最壞（嚴重偏斜樹）:O(n) ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/balanced-binary-tree/","section":"All my post","summary":"Balanced Binary Tree","title":"Balanced Binary Tree","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"Leetcode link : Invert Binary Tree 描述 # 思路 # 這題目使用前序遍歷和後序遍歷都可以 唯獨中序遍歷不方便，因為中序遍歷會把某些節點的左右孩子翻轉了兩次 層序遍歷依然可以，只要把每個節點的左右孩子翻轉一下的遍歷方式都是可以的 解法 # pre order recursive # class Solution { public: TreeNode* invertTree(TreeNode* root) { // 1. 確定遞歸函數的參數和返回值 // 參數就是要傳入節點的指針，不需要其他參數了，通常此時定下來主要參數，如果在寫遞歸的邏輯中發現還需要其他參數的時候，隨時補充。 // 傳回值的話其實也不需要，但是題目中給的要回傳root節點的指針，可以直接用題目定義好的函數，所以就函數的回傳類型為TreeNode*。 if (root == NULL) return root; // 2. 確定終止條件 當前節點為空的時候，就返回 // 3. 確定單層遞歸的邏輯 前序遍歷，所以先進行交換左右孩子節點，然後反轉左子樹，反轉右子樹。 swap(root-\u0026gt;left, root-\u0026gt;right); // 中 invertTree(root-\u0026gt;left); // 左 invertTree(root-\u0026gt;right); // 右 return root; } }; // 时间复杂度： O(n) 樹共有 n 個節點 // 空间复杂度： O(logn) 為樹高 h pre order iterative # class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; stack\u0026lt;TreeNode*\u0026gt; st; st.push(root); while(!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); if(node-\u0026gt;right) st.push(node-\u0026gt;right); // 右 if(node-\u0026gt;left) st.push(node-\u0026gt;left); // 左 } return root; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：最佳／平均（平衡樹: O(logn) 最壞（嚴重偏斜樹）:O(n) level order iterative # class Solution { public: TreeNode* invertTree(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); // 节点处理 if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return root; } }; // 时间复杂度： O(n) // 空间复杂度： O(w) ： w 為最大寬度 介於 O(1) 與 O(n) (完全二元最底層約有 n/2 個節點)之間 ","date":"2025-08-04","externalUrl":null,"permalink":"/docs/invert-binary-tree/","section":"All my post","summary":"Invert Binary Tree","title":"Invert Binary Tree","type":"docs"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/tags/tree/","section":"Tags","summary":"","title":"Tree","type":"tags"},{"content":"","date":"2025-08-04","externalUrl":null,"permalink":"/authors/wz-chen/","section":"Authors","summary":"","title":"WZ Chen","type":"authors"},{"content":"Leetcode link : Binary Tree Inorder Traversal 解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-\u0026gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-\u0026gt;val); // 中 cur = cur-\u0026gt;right; // 右 } } return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-inorder-traversal/","section":"All my post","summary":"Binary Tree Inorder Traversal","title":"Binary Tree Inorder Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Level Order Traversal 描述 # 思路 # 佇列來實現，佇列先進先出，符合一層一層遍歷的邏輯 而用棧先進後出適合模擬深度優先遍歷也就是遞歸的邏輯。 層序遍歷方式就是圖論中的廣度優先遍歷，只不過我們應用在二元樹上。 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-\u0026gt;val); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } result.push_back(vec); } return result; } }; // 时间复杂度： O(n) 節點僅 入隊一次、出隊一次 // 空间复杂度： O(n) 佇列最壞 O(n) 平均取決於樹的最大寬度 class Solution { public: void order(TreeNode* cur, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, int depth) { if (cur == nullptr) return; if (result.size() == depth) result.push_back(vector\u0026lt;int\u0026gt;()); result[depth].push_back(cur-\u0026gt;val); order(cur-\u0026gt;left, result, depth + 1); order(cur-\u0026gt;right, result, depth + 1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int depth = 0; order(root, result, depth); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) ：介於 O(logn) 與 O(n) 之間 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-level-order-traversal/","section":"All my post","summary":"Binary Tree Level Order Traversal","title":"Binary Tree Level Order Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Postorder Traversal 解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 vec.push_back(cur-\u0026gt;val); // 中 } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 // 前序是中左右 因此在後序調換處理順序 // 解釋：程式邏輯是中 左右，但左右是進去 stack 因此出來就會變成先處理右再處理左， // 因此就會是中 右左 // 最終再做反轉從 中右左 -\u0026gt; 左右中 得到後續 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-postorder-traversal/","section":"All my post","summary":"Binary Tree Postorder Traversal","title":"Binary Tree Postorder Traversal","type":"docs"},{"content":"Leetcode link : Binary Tree Preorder Traversal 思路 # 遞歸演算法的三個要素 決定遞迴函數的參數和回傳值： 決定哪些參數是遞迴的過程中需要處理的，那麼就在遞迴函數裡加上這個參數， 也要明確每次遞迴的傳回值是什麼進而決定遞迴函數的回傳類型。\n確定終止條件： 寫完了遞歸演算法, 運行的時候，常常會遇到棧溢出的錯誤，就是沒寫終止條件或者終止條件寫的不對，操作系統也是用一個棧的結構來保存每一層遞歸的信息，如果遞歸沒有終止，操作系統的內存棧必然就會溢出。\n確定單層遞歸的邏輯： 確定每一層遞歸需要處理的資訊。這裡也就會重複呼叫自己來實現遞歸的過程。\n解法 # struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 呼叫深度 = 樹高 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 右（空节点不入栈） if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 左（空节点不入栈） } // 解釋：程式邏輯是中 右左，但右左是進去 stack 因此出來就會變成先處理左再處理右， // 因此最終就會是中 左右 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(logn) 堆疊深度 = 樹高 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/binary-tree-preorder-traversal/","section":"All my post","summary":"Binary Tree Preorder Traversal","title":"Binary Tree Preorder Traversal","type":"docs"},{"content":"Leetcode link : Evaluate Reverse Polish Notation 描述 # 輸入: [\u0026ldquo;2\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;3\u0026rdquo;, \u0026quot; * \u0026ldquo;] 輸出: 9 解釋: 此算式轉換為常見的中綴算術表達式為：((2 + 1) * 3) = 9 思路 # 一種後綴表達式，所謂後綴就是指運算子寫在後面。\n平常使用的算式則是一種中綴式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n此算式的逆波蘭表達式寫法為 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n逆波蘭表達式主要有以下兩個優點：\n去掉括號後表達式無歧義，上式即便寫成 1 2 + 3 4 + * 也可以依序計算出正確結果。 適合用堆疊操作運算：遇到數字則入棧；遇到運算子則取出棧頂兩個數字進行計算，並將結果壓入堆疊中。 解法 # class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { // 力扣修改了后台测试数据，需要用longlong stack\u0026lt;long long\u0026gt; st; for (int i = 0; i \u0026lt; tokens.size(); i++) { if (tokens[i] == \u0026#34;+\u0026#34; || tokens[i] == \u0026#34;-\u0026#34; || tokens[i] == \u0026#34;*\u0026#34; || tokens[i] == \u0026#34;/\u0026#34;) { long long num1 = st.top(); st.pop(); long long num2 = st.top(); st.pop(); if (tokens[i] == \u0026#34;+\u0026#34;) st.push(num2 + num1); if (tokens[i] == \u0026#34;-\u0026#34;) st.push(num2 - num1); if (tokens[i] == \u0026#34;*\u0026#34;) st.push(num2 * num1); if (tokens[i] == \u0026#34;/\u0026#34;) st.push(num2 / num1); } else { st.push(stoll(tokens[i])); } } long long result = st.top(); st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事） return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/evaluate-reverse-polish-notation/","section":"All my post","summary":"Evaluate Reverse Polish Notation","title":"Evaluate Reverse Polish Notation","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/heap/","section":"Tags","summary":"","title":"Heap","type":"tags"},{"content":"Leetcode link : Implement Queue using Stacks 描述 # push(x) \u0026ndash; 將一個元素放入佇列的尾端。 pop() \u0026ndash; 從隊列首部移除元素。 peek() \u0026ndash; 傳回佇列首部的元素。 empty() \u0026ndash; 傳回佇列是否為空。 思路 # 在 push 資料的時候，只要資料放進輸入棧就好 在 pop 的時候 輸出棧如果為空，就把進棧資料全部導入進來（注意是全部導入），再從出棧彈出數據 輸出棧不為空，則直接從出棧彈出資料就可以了。 最後如何判斷隊列為空呢？如果進棧和出棧都為空的話，表示模擬的佇列為空了。\n解法 # class MyQueue { public: stack\u0026lt;int\u0026gt; stIn; stack\u0026lt;int\u0026gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-\u0026gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() \u0026amp;\u0026amp; stOut.empty(); } }; // 时间复杂度： 都为O(1)。pop和peek看起来像O(n)，实际上一个循环n会被使用n次，最后还是O(1) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/implement-queue-using-stacks/","section":"All my post","summary":"Implement Queue using Stacks","title":"Implement Queue using Stacks","type":"docs"},{"content":"Leetcode link : Implement Stack using Queues 描述 # push(x) \u0026ndash; 元素 x 入棧 pop() \u0026ndash; 移除棧頂元素 top() \u0026ndash; 取得棧頂元素 empty() \u0026ndash; 返回堆疊是否為空 解法 # class MyStack { public: queue\u0026lt;int\u0026gt; que1; queue\u0026lt;int\u0026gt; que2; // 辅助队列，用来备份 /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { que1.push(x); } /** Removes the element on top of the stack and returns that element. */ int pop() { int size = que1.size(); size--; while (size--) { // 将que1 导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); // 留下的最后一个元素就是要返回的值 que1.pop(); que1 = que2; // 再将que2赋值给que1 while (!que2.empty()) { // 清空que2 que2.pop(); } return result; } /** Get the top element. ** Can not use back() direactly. */ int top(){ int size = que1.size(); size--; while (size--){ // 将que1 导入que2，但要留下最后一个元素 que2.push(que1.front()); que1.pop(); } int result = que1.front(); // 留下的最后一个元素就是要回返的值 que2.push(que1.front()); // 获取值后将最后一个元素也加入que2中，保持原本的结构不变 que1.pop(); que1 = que2; // 再将que2赋值给que1 while (!que2.empty()){ // 清空que2 que2.pop(); } return result; } /** Returns whether the stack is empty. */ bool empty() { return que1.empty(); } }; // 时间复杂度: pop为O(n)，top为O(n)，其他为O(1) // 空间复杂度： O(n) 優化 # 其實這題目就是用一個隊列就夠了\nclass MyStack { public: queue\u0026lt;int\u0026gt; que; MyStack() { } void push(int x) { que.push(x); } int pop() { int size = que.size(); size--; while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部 que.push(que.front()); que.pop(); } int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了 que.pop(); return result; } int top(){ int size = que.size(); size--; while (size--){ // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部 que.push(que.front()); que.pop(); } int result = que.front(); // 此时获得的元素就是栈顶的元素了 que.push(que.front()); // 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化 que.pop(); return result; } bool empty() { return que.empty(); } }; ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/implement-stack-using-queues/","section":"All my post","summary":"Implement Stack using Queues","title":"Implement Stack using Queues","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Leetcode link : Remove All Adjacent Duplicates In String 描述 # S 僅由小寫英文字母組成，1 \u0026lt;= S.length \u0026lt;= 20000\n重複項刪除操作會選擇兩個相鄰且相同的字母，並刪除它們。\n在 S 上重複執行重複項刪除操作，直到無法繼續刪除。\n在完成所有重複項刪除操作後傳回最終的字串。\n輸入：\u0026ldquo;abbaca\u0026rdquo; 輸出：\u0026ldquo;ca\u0026rdquo;\n在 \u0026ldquo;abbaca\u0026rdquo; 中，我們可以刪除 \u0026ldquo;bb\u0026rdquo; 由於兩個字母相鄰且相同，這是此時唯一可以執行刪除操作的重複項 之後我們得到字串 \u0026ldquo;aaca\u0026rdquo;，其中又只有 \u0026ldquo;aa\u0026rdquo; 可以執行重複項刪除操作 所以最後的字串為 \u0026ldquo;ca\u0026rdquo;。 思路 # 用棧來存放前面遍歷過的元素呢，去棧裡看一下我們是不是遍歷過相同數值的相鄰元素。 從堆疊中彈出剩餘元素，此時是字串 ac 從堆疊中彈出的元素是倒序的，所以再對字串進行反轉一下，就得到了最終的結果。 解法 # class Solution { public: string removeDuplicates(string S) { stack\u0026lt;char\u0026gt; st; for (char s : S) { if (st.empty() || s != st.top()) { st.push(s); } else { st.pop(); // s 与 st.top()相等的情况 } } string result = \u0026#34;\u0026#34;; while (!st.empty()) { // 将栈中元素放到result字符串汇总 result += st.top(); st.pop(); } reverse (result.begin(), result.end()); // 此时字符串需要反转一下 return result; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) 優化 # 可以拿字串直接當棧，這樣省去了棧還要轉為字串的操作\nclass Solution { public: string removeDuplicates(string S) { string result; for(char s : S) { if(result.empty() || result.back() != s) { result.push_back(s); } else { result.pop_back(); } } return result; } }; ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/remove-all-adjacent-duplicates-in-string/","section":"All my post","summary":"Remove All Adjacent Duplicates In String","title":"Remove All Adjacent Duplicates In String","type":"docs"},{"content":"Leetcode link : Sliding Window Maximum 描述 # 思路 # 暴力法：O(n × k)\n遍歷一遍的過程中每次從視窗中再找到最大的數值\n去掉括號後表達式無歧義，上式即便寫成 1 2 + 3 4 + * 也可以依序計算出正確結果。\n適合用堆疊操作運算：遇到數字則入棧；遇到運算子則取出棧頂兩個數字進行計算，並將結果壓入堆疊中。\nQueue\nQueue 沒有必要維護視窗裡的所有元素，只需要維護有可能成為視窗裡最大值的元素就可以了，同時確保 Queue 裡的元素數值是由大到小的。\n對於視窗裡的元素{2, 3, 5, 1 ,4}，單調隊列裡只維護 {5, 4} 就夠了，保持單調隊列裡單調遞減，此時隊列出口元素就是窗口裡最大元素。\npop(value)：如果視窗移除的元素 value 等於單調佇列的出口元素，那麼佇列彈出元素，否則不用任何操作\npush(value)：如果 push 的元素 value 大於入口元素的數值，那麼就將佇列入口的元素彈出，直到 push 元素的數值小於等於佇列入口元素的數值為止\n保持如上規則，每次視窗移動的時候，只要問 que.front()就可以回到目前視窗的最大值。\n解法 # class Solution { private: class MyQueue { //单调队列（从大到小） public: deque\u0026lt;int\u0026gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) { if (!que.empty() \u0026amp;\u0026amp; value == que.front()) { que.pop_front(); } } // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) { while (!que.empty() \u0026amp;\u0026amp; value \u0026gt; que.back()) { que.pop_back(); } que.push_back(value); } // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() { return que.front(); } }; public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { MyQueue que; vector\u0026lt;int\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { // 先将前k的元素放进队列 que.push(nums[i]); } result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i \u0026lt; nums.size(); i++) { que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 } return result; } }; // 时间复杂度： O(n) // nums 中的每個元素最多也就被 push_back 和 pop_back 各一次，沒有任何多餘操作，所以整體的複雜度還是 O(n)。 // 空间复杂度： O(k) 一個輔助隊列 ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/sliding-window-maximum/","section":"All my post","summary":"Sliding Window Maximum","title":"Sliding Window Maximum","type":"docs"},{"content":"","date":"2025-08-03","externalUrl":null,"permalink":"/tags/stackqueue/","section":"Tags","summary":"","title":"Stack\u0026Queue","type":"tags"},{"content":"Leetcode link : Top K Frequent Elements 描述 # 給定一個非空的整數數組，傳回其中出現頻率前 k 高的元素。\n輸入: nums = [1,1,1,2,2,3], k = 2 輸出: [1,2]\n你可以假設給定的 k 總是合理的，且 1 ≤ k ≤ 陣列中不相同的元素的個數。 時間複雜度必須優於 O(nlogn), n 是數組的大小。 陣列中前 k 個高頻元素的集合是唯一的。 你可以按任意順序返回答案。 思路 # 解法 # class Solution { public: // 小顶堆 class mycomparison { public: bool operator()(const pair\u0026lt;int, int\u0026gt;\u0026amp; lhs, const pair\u0026lt;int, int\u0026gt;\u0026amp; rhs) { return lhs.second \u0026gt; rhs.second; } }; vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 要统计元素出现频率 unordered_map\u0026lt;int, int\u0026gt; map; // map\u0026lt;nums[i],对应出现的次数\u0026gt; for (int i = 0; i \u0026lt; nums.size(); i++) { map[nums[i]]++; } // 对频率排序 // 定义一个小顶堆，大小为k priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, mycomparison\u0026gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map\u0026lt;int, int\u0026gt;::iterator it = map.begin(); it != map.end(); it++) { pri_que.push(*it); if (pri_que.size() \u0026gt; k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); } } // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector\u0026lt;int\u0026gt; result(k); for (int i = k - 1; i \u0026gt;= 0; i--) { result[i] = pri_que.top().first; pri_que.pop(); } return result; } }; // 时间复杂度： O(nlogk) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/top-k-frequent-elements/","section":"All my post","summary":"Top K Frequent Elements","title":"Top K Frequent Elements","type":"docs"},{"content":"Leetcode link : Valid Parentheses 描述 # 給定一個只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字串，判斷字串是否有效。 有效字串需滿足： 左括號必須用相同類型的右括號閉合。 左括號必須以正確的順序閉合。 注意空字串可被認為是有效字串。 输入: \u0026ldquo;([)]\u0026rdquo; 输出: false 思路 # 已經遍歷完了字串，但是棧不為空，表示有相應的左括號沒有右括號來匹配，所以 return false 遍歷字串符合的過程中，發現棧裡沒有要符合的字元。所以 return false 遍歷字串匹配的過程中，棧已經為空了，沒有匹配的字元了，表示右括號沒有找到對應的左括號 return false 字串遍歷完之後，棧是空的，就表示全都匹配了 匹配左括號的時候，右括號先入棧，就只需要比較當前元素和棧頂相不相等就可以了，\n解法 # class Solution { public: bool isValid(string s) { if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求 stack\u0026lt;char\u0026gt; st; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) st.push(\u0026#39;)\u0026#39;); else if (s[i] == \u0026#39;{\u0026#39;) st.push(\u0026#39;}\u0026#39;); else if (s[i] == \u0026#39;[\u0026#39;) st.push(\u0026#39;]\u0026#39;); // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false else if (st.empty() || st.top() != s[i]) return false; else st.pop(); // st.top() 与 s[i]相等，栈弹出元素 } // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true return st.empty(); } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-03","externalUrl":null,"permalink":"/docs/valid-parentheses/","section":"All my post","summary":"Valid Parentheses","title":"Valid Parentheses","type":"docs"},{"content":"Leetcode link : 3Sum 描述 # 給你一個包含 n 個整數的陣列 nums，判斷 nums 中是否存在三個元素 a，b，c ，使得 a + b + c = 0 ？請你找出所有符合條件且不重複的三元組。\n注意： 答案中不可以包含重複的三元組。\n範例：給定數組 nums = [-1, 0, 1, 2, -1, -4]，滿足要求的三元組集合為： [ [-1, 0, 1], [-1, -1, 2] ]\n思路 # Hashing：O(n^2)\n兩層 for 迴圈就可以確定 兩個數值 第三個數 0-(a+b) 或 0 - (a + c) 是否在 數組裡出現過 題目中說的不可以包含重複的三元組。 -\u0026gt; 把符合條件的三元組放進 vector 中，然後再去重，這樣是非常費時的，很容易超時， 實這題目使用 Hashing 並不十分合適，因為在去重的操作中有很多細節需要注意，在面試中很難直接寫出沒有 bug 的代碼。 Two pointer：O(n^2)\n先將數組排序，然後有一層 for 循環\ni 從下標 0 的地方開始 定一個下標 left 定義在 i+1 的位置上 定義下標 right 在數組結尾的位置上。 還是在陣列中找到 abc 使得 a + b +c =0\n相當於 a = nums[i]，b = nums[left]，c = nums[right]。 如何移動 left 和 right 呢\n如果 nums[i] + nums[left] + nums[right] \u0026gt; 0 說明 此時三數總和大了，因為數組是排序後了 所以 right 下標就應該向左移動，這樣才能讓三數之和小一些。 如果 nums[i] + nums[left] + nums[right] \u0026lt; 0 說明 此時 三數之和小了，left 就向右移動，才能讓三數總和大一些 直到 left 與 right 相遇為止。\n解法 # class Solution { public: // 在一个数组中找到3个数形成的三元组，它们的和为0，不能重复使用（三数下标互不相同），且三元组不能重复。 // b（存储）== 0-(a+c)（检索） vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i++) { // 如果a是正数，a\u0026lt;b\u0026lt;c，不可能形成和为0的三元组 if (nums[i] \u0026gt; 0) break; // [a, a, ...] 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; // 这个set的作用是存储b unordered_set\u0026lt;int\u0026gt; set; for (int k = i + 1; k \u0026lt; nums.size(); k++) { // 去重b=c时的b和c if (k \u0026gt; i + 2 \u0026amp;\u0026amp; nums[k] == nums[k - 1] \u0026amp;\u0026amp; nums[k - 1] == nums[k - 2]) continue; // a+b+c=0 \u0026lt;=\u0026gt; b=0-(a+c) int target = 0 - (nums[i] + nums[k]); if (set.find(target) != set.end()) { result.push_back({nums[i], target, nums[k]}); // nums[k]成为c set.erase(target); } else { set.insert(nums[k]); // nums[k]成为b } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n)，额外的 set 开销 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i \u0026lt; nums.size(); i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] \u0026gt; 0) { return result; } // 错误去重a方法，将会漏掉-1,-1,2 这种情况 /* if (nums[i] == nums[i + 1]) { continue; } */ // 正确去重a方法 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right\u0026lt;=left 了，从而漏掉了 0,0,0 这种三元组 /* while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; */ if (nums[i] + nums[left] + nums[right] \u0026gt; 0) right--; else if (nums[i] + nums[left] + nums[right] \u0026lt; 0) left++; else { result.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[left], nums[right]}); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 // 因為 nums[left] 和 nums[right] 這對數字已經被用過並且記錄成答案，我們必須把視窗向內縮，才能繼續尋找下一組可能的配對，同時避免死迴圈或重複答案。 right--; left++; } } } return result; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) 注意 # 兩數和要求回傳的是索引下標，而雙指標法一定要排序，一旦排序之後原數組的索引就被改變了。 兩數和要求回傳的是數值的話，就可以使用雙指標法了。 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/3sum/","section":"All my post","summary":"3Sum","title":"3Sum","type":"docs"},{"content":"Leetcode link : 4Sum 描述 # 題意：給定一個包含 n 個整數的陣列 nums 和一個目標值 target 判斷 nums 中是否存在四個元素 a，b，c 和 d ，使得 a + b + c + d 的值與 target 相等- 找出所有滿足條件且不重複的四元組。 注意：答案中不可以包含重複的四元組。 例： 給定數組 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 滿足要求的四元組集合為： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 思路 # 基本解法就是在 三數和 的基礎上再套一層 for 循環 但有一些細節要注意，例如： 不要判斷 nums[k] \u0026gt; target 就回傳了，三數之和 可以透過 nums[i] \u0026gt; 0 就回傳了，因為 0 已經是確定的數了，四數之和這道題目 target 是任意值。 例如：陣列是[-4, -3, -2, -1]，target 是 -10，不能因為 -4 \u0026gt; -10 而跳過。但是我們依舊可以去做剪枝 邏輯變成 nums[k] \u0026gt; target \u0026amp;\u0026amp; (nums[k] \u0026gt;=0 || target \u0026gt;= 0)就可以了。 雙指針解法： 兩層 for 循環 nums[k] + nums[i]為確定值 依然是循環內有 left 和 right 下標作為雙指針 找出 nums[k] + nums[i] + nums[left] + nums[right] == target 的情況 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k \u0026lt; nums.size(); k++) { // 剪枝处理 if (nums[k] \u0026gt; target \u0026amp;\u0026amp; nums[k] \u0026gt;= 0) { break; // 这里使用break，统一通过最后的return返回 } // 对nums[k]去重 if (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { continue; } for (int i = k + 1; i \u0026lt; nums.size(); i++) { // 2级剪枝处理 if (nums[k] + nums[i] \u0026gt; target \u0026amp;\u0026amp; nums[k] + nums[i] \u0026gt;= 0) { // 因为只要 nums[k] + nums[i] \u0026gt; target，那么 nums[i] 后面的数都是正数的话，就一定 不符合条件了。 break; } // 对nums[i]去重 if (i \u0026gt; k + 1 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { // nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target 会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026gt; target) { right--; // nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target 会溢出 } else if ((long) nums[k] + nums[i] + nums[left] + nums[right] \u0026lt; target) { left++; } else { result.push_back(vector\u0026lt;int\u0026gt;{nums[k], nums[i], nums[left], nums[right]}); // 对nums[left]和nums[right]去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; } } } } return result; } }; // 时间复杂度： O(n^3) // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum/","section":"All my post","summary":"4Sum","title":"4Sum","type":"docs"},{"content":"Leetcode link : 4Sum II 描述 # 給定四個包含整數的陣列列表 A , B , C , D ,計算有多少個元組 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n為了使問題簡單化，所有的 A, B, C, D 具有相同的長度 N，且 0 ≤ N ≤ 500 。所有整數的範圍在 -2^28 到 2^28 - 1 之間，最終結果不會超過 2^31 - 1 。\n輸入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 輸出: 2\n解釋: 兩個元組如下: (0, 0, 0, 1) -\u0026gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -\u0026gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n思路 # 暴力法：\n時間複雜度是 O(n^4) Hashing：\n先定義 一個 unordered_map，key 放 a 和 b 兩數和，value 放 a 和 b 兩數之和出現的次數。 遍歷大 A 和大 B 數組，統計兩個數組元素總和，和出現的次數，放到 map。 定義 int 變數 count，用來統計 a+b+c+d = 0 出現的次數。 再遍歷大 C 和大 D 數組，找出如果 0-(c+d) 在 map 中出現過的話，就用 count 把 map 中 key 對應的 value 也就是出現次數統計出來。 最後回傳統計值 count 就可以了 解法 # class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B, vector\u0026lt;int\u0026gt;\u0026amp; C, vector\u0026lt;int\u0026gt;\u0026amp; D) { unordered_map\u0026lt;int, int\u0026gt; umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 for (int a : A) { for (int b : B) { umap[a + b]++; } } int count = 0; // 统计a+b+c+d = 0 出现的次数 // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) { for (int d : D) { if (umap.find(0 - (c + d)) != umap.end()) { count += umap[0 - (c + d)]; } } } return count; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(n^2) 最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/4sum-ii/","section":"All my post","summary":"4Sum II","title":"4Sum II","type":"docs"},{"content":"Leetcode link : Find Common Characters 描述 # 給你一個字串陣列 words ，請你找出所有在 words 的每個字串中都出現的共用字元（ 包括重複字元），並以陣列形式傳回。你可以按 任意順序 返回答案。\n範例 1：輸入：words = [\u0026ldquo;bella\u0026rdquo;,\u0026ldquo;label\u0026rdquo;,\u0026ldquo;roller\u0026rdquo;] 輸出：[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;]\n範例 2：輸入：words = [\u0026ldquo;cool\u0026rdquo;,\u0026ldquo;lock\u0026rdquo;,\u0026ldquo;cook\u0026rdquo;] 輸出：[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\n提示：1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] 由小寫英文字母組成\n思路 # 暴力法：\n時間複雜度是 O(n^m) 一個字串一個字串去搜，n 是字串長度，m 是有幾個字串。 碼實現也不容易，因為要統計 重複的字符，還要適當的替換或去重 Hashing：\n統計出搜尋字串裡 26 個字元的出現的頻率 取每個字元頻率最小值，最後轉成輸出格式就可以了 解法 # class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; A) { vector\u0026lt;string\u0026gt; result; if (A.size() == 0) return result; int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率 for (int i = 0; i \u0026lt; A[0].size(); i++) { // 用第一个字符串给hash初始化 hash[A[0][i] - \u0026#39;a\u0026#39;]++; } int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率 for (int i = 1; i \u0026lt; A.size(); i++) { memset(hashOtherStr, 0, 26 * sizeof(int)); for (int j = 0; j \u0026lt; A[i].size(); j++) { hashOtherStr[A[i][j] - \u0026#39;a\u0026#39;]++; } // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数 for (int k = 0; k \u0026lt; 26; k++) { hash[k] = min(hash[k], hashOtherStr[k]); } } // 将hash统计的字符次数，转成输出形式 for (int i = 0; i \u0026lt; 26; i++) { while (hash[i] != 0) { // 注意这里是while，多个重复的字符 string s(1, i + \u0026#39;a\u0026#39;); // char -\u0026gt; string result.push_back(s); hash[i]--; } } return result; } }; // 时间复杂度：O(n) 所有字元的總數 // 空间复杂度：O(1) 每條字串長度都是固定常數 或 可視為相同平均長度 L 時候字元總數 N = n * L 於是時間複雜度為 n\n如果字串長度差異很大、或隨著輸入放大而成長，就必須把長度考慮進去，寫成 O(nL) or O(N)\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-common-characters/","section":"All my post","summary":"Find Common Characters","title":"Find Common Characters","type":"docs"},{"content":"Leetcode link : Find the Index of the First Occurrence in a String 描述 # 給定一個 haystack 字串和一個 needle 字串，在 haystack 字串中找出 needle 字串出現的第一個位置 (從 0 開始)。如果不存在，則傳回 -1。\n範例 1: 輸入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 輸出: 2\n範例 2: 輸入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 輸出: -1\n當 needle 是空字串時，我們該回傳什麼值呢？這是一個在面試中很好的問題。\n對本題而言，當 needle 是空字串時我們應當傳回 0 。這與 Java 的 indexOf() 定義相符。\n思路 # 使用 KMP j 指向「待比較的 pattern 位置」（亦代表當前已匹配長度）。 失配時 j = next[j-1] 讓我們「盡量利用已知最長前後綴」，避免從頭比。 整個迴圈 每個 i 與 j 只會單調遞增或回退一次 → O(m) 解法 # class Solution { public: void getNext(int* next, const string\u0026amp; s) { int j = 0; // 已匹配的字元長度 next[0] = 0; // s[0] 的 LPS 為 0 for (int i = 1; i \u0026lt; s.size(); ++i) { // 若失配：沿用「已知最長前後綴」繼續回溯 while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1]; // 若匹配：匹配長度 +1 if (s[i] == s[j]) ++j; next[i] = j; // 紀錄位置 i 的 LPS } } int strStr(string haystack, string needle) { if (needle.empty()) return 0; vector\u0026lt;int\u0026gt; next(needle.size()); getNext(next.data(), needle); // 建 LPS int j = 0; // pattern 指針 for (int i = 0; i \u0026lt; haystack.size(); ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]) j = next[j - 1]; // 失配 → 回跳 if (haystack[i] == needle[j]) ++j; // 匹配 → 雙指標前進 if (j == needle.size()) // 全部匹配完成 return i - j + 1; // 回傳起始索引 } return -1; // 未找到 } }; // 时间复杂度: O(n + m) m：建表 (getNext) , n：匹配 (strStr) // 空间复杂度: O(m) m：建表 (getNext) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-the-index-of-the-first-occurrence-in-a-string/","section":"All my post","summary":"Find the Index of the First Occurrence in a String","title":"Find the Index of the First Occurrence in a String","type":"docs"},{"content":"Leetcode link : Happy Number 描述 # 「快樂數」定義為：對於一個正整數，每一次將該數替換為它每個位置上的數字的平方和，然後重複這個過程直到這個數變為 1，也可能是 無限循環 但始終變不到 1。如果 可以變成 1，那麼這個數就是快樂數。\n如果 n 是快樂數就回傳 True ；不是，則回傳 False 。\n輸入：19 輸出：true\n解釋： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1\n思路 # 我們遇到了要快速判斷一個元素是否出現集合裡的時候，就要考慮 Hashing\n判斷這個 sum 是否重複出現，如果重複了就是 return false， 否則一直找到 sum 為 1。\n判斷 sum 是否重複出現就可以使用 unordered_set。\n解法 # class Solution { public: // 取数值各个位上的单数之和 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while(1) { int sum = getSum(n); if (sum == 1) { return true; } // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false if (set.find(sum) != set.end()) { return false; } else { set.insert(sum); } n = sum; } } }; // 时间复杂度： O(logn) // 空间复杂度： O(logn) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/happy-number/","section":"All my post","summary":"Happy Number","title":"Happy Number","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/hashing/","section":"Tags","summary":"","title":"Hashing","type":"tags"},{"content":"Leetcode link : Intersection of Two Arrays 描述 # 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n題目刻意說明：輸出結果中的每個元素一定是唯一的，也就是說輸出的結果的去重的， 同時可以不考慮輸出結果的順序 -\u0026gt; unordered_set\n而這題目沒有限制數值的大小 -\u0026gt; 無法使用陣列來做哈希表\n哈希值比較少、特別分散、跨度非常大，使用數組就會造成空間的極大浪費 -\u0026gt; 使用另一種結構體 set set 有三種資料結構 std::set -\u0026gt; 底層為紅黑樹 std::multiset -\u0026gt; 底層為紅黑樹 std::unordered_set -\u0026gt; 底層為 hash table -\u0026gt; 使用 unordered_set 讀寫效率最高，不需對資料進行排序，也不要讓資料重複 解法 # class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set; // 存放结果，之所以用set是为了给结果集去重 unordered_set\u0026lt;int\u0026gt; nums_set(nums1.begin(), nums1.end()); for (int num : nums2) { // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(), result_set.end()); } }; // 时间复杂度： O(n + m) nums1 = n, nums2 = m // k 是最后要把 set 转成 vector 但因為長度必定小於 m or n 因此最終為 O(n + m) // 空间复杂度： O(n + k) nums_set = n, result_set = k 注意 # 遇到哈希問題我直接都用 set 不就得了，用什麼數組啊？ 直接使用 set 不僅佔空間比陣列大，而且速度要比陣列慢 set 把數值映射到 key 上都要做 hash 計算的。 不要小瞧 這個耗時，在數據量大的情況，差距是很明顯的。 當題目有限制較小的數值範圍時，例如：1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 就可以把 array 作為 hash，若範圍過大則採用 unordered_set ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/intersection-of-two-arrays/","section":"All my post","summary":"Intersection of Two Arrays","title":"Intersection of Two Arrays","type":"docs"},{"content":"Leetcode link : Ransom Note 描述 # 給定一個贖金信 (ransom) 字串和一個雜誌 (magazine) 字串，判斷第一個字串 ransom 能不能由第二個字串 magazines 裡面的字構成。如果可以構成，則傳回 true ；否則傳回 false。\n(題目說明：為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思。雜誌字串中的每個字元只能在贖金信字串中使用一次。)\n注意：你可以假設兩個字串均只含有小寫字母。 canConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n思路 # 「為了不暴露贖金信字跡，要從雜誌上搜尋各個需要的字母，組成單字來表達意思」 這裡說明雜誌裡面的字母不可重複使用。 「你可以假設兩個字串都只含有小寫字母。」 說明只有小寫字母 解法 # class Solution { public: bool canConstruct(string ransomNote, string magazine) { for (int i = 0; i \u0026lt; magazine.length(); i++) { for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 在ransomNote中找到和magazine相同的字符 if (magazine[i] == ransomNote[j]) { ransomNote.erase(ransomNote.begin() + j); // ransomNote删除这个字符 break; } } } // 如果ransomNote为空，则说明magazine的字符可以组成ransomNote if (ransomNote.length() == 0) { return true; } return false; } }; // 时间复杂度： O(n^2) // 空间复杂度： O(1) class Solution { public: bool canConstruct(string ransomNote, string magazine) { int record[26] = {0}; //add if (ransomNote.size() \u0026gt; magazine.size()) { return false; } for (int i = 0; i \u0026lt; magazine.length(); i++) { // 通过record数据记录 magazine里各个字符出现次数 record[magazine[i]-\u0026#39;a\u0026#39;] ++; } for (int j = 0; j \u0026lt; ransomNote.length(); j++) { // 遍历ransomNote，在record里对应的字符个数做--操作 record[ransomNote[j]-\u0026#39;a\u0026#39;]--; // 如果小于零说明ransomNote里出现的字符，magazine没有 if(record[ransomNote[j]-\u0026#39;a\u0026#39;] \u0026lt; 0) { return false; } } return true; } }; // 时间复杂度： O(m+n)，其中m表示ransomNote的长度，n表示magazine的长度 // 空间复杂度： O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/ransom-note/","section":"All my post","summary":"Ransom Note","title":"Ransom Note","type":"docs"},{"content":"Leetcode link : Repeated Substring Pattern 描述 # 給定一個非空的字串，判斷它是否可以由它的一個子字串重複多次構成。\n給定的字串只含有小寫英文字母，且長度不超過10000\n輸入: \u0026ldquo;abcabcabcabc\u0026rdquo; 輸出: True\n解釋: 可由子字串 \u0026ldquo;abc\u0026rdquo; 重複四次構成。 (或子字串 \u0026ldquo;abcabc\u0026rdquo; 重複兩次構成。)\n思路 # 暴力法：O(n^2) 一個 for 迴圈取得 子字串的終止位置， 然後判斷子字串是否能重複構成字串，又嵌套一個 for 循環 其實我們只要判斷，以第一個字母為開始的子字串就可以 所以一個 for 迴圈取得子字串的終止位置就行了。 遍歷的時候 都不用遍歷結束，只需要遍歷到中間位置 因為子字串結束位置大於中間位置的話，一定不能重複組成字串 把 s 拼成 s+s 後再掐頭去尾，檢查 s 是否仍能出現在中間：O(n+m) find 為標準函式庫 -\u0026gt; 保證最壞 O(n+m) 使用 KMP getNext 計算 最長公共前後綴長度 解法 # bool repeatedSubstringPattern_bruteforce(const string\u0026amp; s) { int n = s.size(); if (n \u0026lt; 2) return false; // 長度 0 或 1 不可能 for (int len = 1; len \u0026lt;= n / 2; ++len) { if (n % len != 0) continue; // len 不是 n 的因數，直接跳過 bool ok = true; // 檢查第 len..n-1 位置的字元，是否與對應的 s[i-len] 相同 for (int i = len; i \u0026lt; n \u0026amp;\u0026amp; ok; ++i) { if (s[i] != s[i - len]) ok = false; } if (ok) return true; // 找到一組合法的 len } return false; } // 时间复杂度：O(n^2) // 空间复杂度：O(1) class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾 if (t.find(s) != std::string::npos) return true; // r return false; } }; // 時間複雜度為 O(n)（find 掃字串） // 空間複雜度 O(n)（存 t）。 class Solution { public: void getNext (int* next, const string\u0026amp; s){ next[0] = 0; // 第 0 個字元的 LPS 永遠是 0 int j = 0; // j = 目前可延續的最長匹配長度 for(int i = 1;i \u0026lt; s.size(); i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) { j = next[j - 1]; // 失配：退回上一個可用的 LPS } if(s[i] == s[j]) { j++; // 成功配對，匹配長度 +1 } next[i] = j; // 記錄 i 位置對應的 LPS } } bool repeatedSubstringPattern (string s) { if (s.size() == 0) { return false; } int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 \u0026amp;\u0026amp; len % (len - (next[len - 1] )) == 0) { return true; } return false; } }; // 時間複雜度為 O(n) // 空間複雜度 O(n) 注意 # 若字串由子字串 p 重複組成\n設 |p| = k，重複 m 次 (len = k·m)。\n整條字串的最長公共前後綴就是 p 重複 m-1 次 → 長度 len - k。\n因此 lps = len - k，且 k = len - lps。\n此時 len % k == 0 成立。\n若條件成立，必有重複子字串\nlps \u0026gt; 0 ⇒ 至少有一段前綴同時也是後綴。\nk = len - lps 為可能的週期長度。\n若 len % k == 0，把長度 k 的子字串複製 m = len/k 次即可拼回原字串。\n反例不可能通過測試\n若字串並非週期字串，lps 只能小於真正週期長度或為 0。\n即使 lps \u0026gt; 0，len % (len-lps) 也必定不等於 0。\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/repeated-substring-pattern/","section":"All my post","summary":"Repeated Substring Pattern","title":"Repeated Substring Pattern","type":"docs"},{"content":"Leetcode link : Reverse String 描述 # 寫一個函數，其作用是將輸入的字串反轉過來。輸入字串以字元數組 char[] 的形式給出。\n不要給另外的陣列分配額外的空間，你必須原地修改輸入陣列、使用 O(1) 的額外空間解決這個問題。\n你可以假設數組中的所有字元都是 ASCII 碼表中的可列印字元。\n思路 # swap 可以有兩種實現 常見的交換數值 過位元運算 // 1 int tmp = s[i]; s[i] = s[j]; s[j] = tmp; // 2 s[i] ^= s[j]; s[j] ^= s[i]; s[i] ^= s[j]; 解法 # class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for (int i = 0, j = s.size() - 1; i \u0026lt; s.size()/2; i++, j--) { swap(s[i],s[j]); } } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string/","section":"All my post","summary":"Reverse String","title":"Reverse String","type":"docs"},{"content":"Leetcode link : Reverse String II 描述 # 給定一個字串 s 和一個整數 k，從字串開頭算起, 每計數至 2k 個字符，就反轉這 2k 個字符中的前 k 個字符。\n如果剩餘字元少於 k 個，則將剩餘字元全部反轉。\n如果剩餘字符小於 2k 但大於或等於 k 個，則反轉前 k 個字符，其餘字符保持原樣。\n範例:輸入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 輸出: \u0026ldquo;bacdfeg\u0026rdquo;\n思路 # 在遍歷字串的過程中，只要讓 i += (2 * k) i 每次移動 2 \\* k 就可以了，然後判斷是否需要有反轉的區間。 因為要找的也就是每 2 * k 區間的起點 當需要固定規律一段一段去處理字串的時候，要想想在 for 迴圈的表達式上做做文章。 解法 # class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += (2 * k)) { // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k \u0026lt;= s.size()) { reverse(s.begin() + i, s.begin() + i + k ); } else { // 3. 剩余字符少于 k 个，则将剩余字符全部反转。 reverse(s.begin() + i, s.end()); } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-string-ii/","section":"All my post","summary":"Reverse String II","title":"Reverse String II","type":"docs"},{"content":"Leetcode link : Reverse Words in a String 描述 # 輸入: \u0026quot; hello world! \u0026quot; 輸出: \u0026ldquo;world! hello\u0026rdquo;\n解釋: 輸入字串可以在前面或後麵包含多餘的空格，但是反轉後的字元不能包括。\n輸入: \u0026ldquo;a good example\u0026rdquo; 輸出: \u0026ldquo;example good a\u0026rdquo;\n解釋: 如果兩個字間有多餘的空格，將反轉後字間的空格減少到只含一個。\n不要使用輔助空間，空間複雜度要求為 O(1)\n思路 # 移除多餘空格 將整個字串反轉 將每個單字反轉 解法 # void removeExtraSpaces(string\u0026amp; s) { for (int i = s.size() - 1; i \u0026gt; 0; i--) { if (s[i] == s[i - 1] \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) { s.erase(s.begin() + i); } } // 删除字符串最后面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[s.size() - 1] == \u0026#39; \u0026#39;) { s.erase(s.begin() + s.size() - 1); } // 删除字符串最前面的空格 if (s.size() \u0026gt; 0 \u0026amp;\u0026amp; s[0] == \u0026#39; \u0026#39;) { s.erase(s.begin()); } } // 时间复杂度：O(n^2) // 一个 erase 本来就是O(n)的操作 而 erase 操作上面还套了一个 for 循环 // 空间复杂度：O(1) 使用雙指標法來去移除空格，最後 resize（重新設定）一下字串的大小，就可以做到 O(n)的時間複雜度。\n//版本一 void removeExtraSpaces(string\u0026amp; s) { int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针 // 去掉字符串前面的空格 while (s.size() \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; s.size() \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { fastIndex++; } for (; fastIndex \u0026lt; s.size(); fastIndex++) { // 去掉字符串中间部分的冗余空格 if (fastIndex - 1 \u0026gt; 0 // 只有當 fastIndex 至少為 1 時，才去讀 s[fastIndex-1]」，避免在 fastIndex==0 時往左越界 \u0026amp;\u0026amp; s[fastIndex - 1] == s[fastIndex] \u0026amp;\u0026amp; s[fastIndex] == \u0026#39; \u0026#39;) { continue; } else { s[slowIndex++] = s[fastIndex]; } } if (slowIndex - 1 \u0026gt; 0 \u0026amp;\u0026amp; s[slowIndex - 1] == \u0026#39; \u0026#39;) { // 去掉字符串末尾的空格 s.resize(slowIndex - 1); } else { s.resize(slowIndex); // 重新设置字符串大小 } } 精簡後的完整如下\nclass Solution { public: void reverse(string\u0026amp; s, int start, int end) { // 翻转，区间写法：左闭右闭 [] for (int i = start, j = end; i \u0026lt; j; i++, j--) { swap(s[i], s[j]); } } void removeExtraSpaces(string\u0026amp; s) { // 去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0, fast = 0, n = s.size(); // 跳過前導空格 while (fast \u0026lt; n \u0026amp;\u0026amp; s[fast] == \u0026#39; \u0026#39;) ++fast; for (; fast \u0026lt; n; ++fast) { // 如果當前字元是空格，而且前一個已經是空格，略過 if (s[fast] == \u0026#39; \u0026#39; \u0026amp;\u0026amp; (slow == 0 || s[slow - 1] == \u0026#39; \u0026#39;)) continue; s[slow++] = s[fast]; } // 移除尾端空格（可能剛好停在一格空白） if (slow \u0026gt; 0 \u0026amp;\u0026amp; s[slow - 1] == \u0026#39; \u0026#39;) --slow; s.resize(slow); // 調整字串實際長度 } string reverseWords(string s) { removeExtraSpaces( s); // 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; // removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i \u0026lt;= s.size(); ++i) { if (i == s.size() || s[i] == \u0026#39; \u0026#39;) { // 到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); // 翻转，注意是左闭右闭 []的翻转。 start = i + 1; // 更新下一个单词的开始下标start } } return s; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) 或 O(n)，取决于语言中字符串是否可变 ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/reverse-words-in-a-string/","section":"All my post","summary":"Reverse Words in a String","title":"Reverse Words in a String","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/string/","section":"Tags","summary":"","title":"String","type":"tags"},{"content":"Leetcode link : Two Sum 描述 # 給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那兩個整數，並返回他們的數組下標。\n你可以假設每個輸入只會對應一個答案。但是，數組中同一個元素不能使用兩次。\n範例:\n已知 nums = [2, 7, 11, 15], target = 9 為 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路 # 暴力法：\n時間複雜度是 O(n^2) Hashing：\n判斷元素是否出現，這個元素就要當 key，所以數組中的元素作為 key，有 key 對應的就是 value，value 用來存下標。 map 中的儲存結構為 {key：資料元素，value：陣列元素對應的下標}。 解法 # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i = 0; i \u0026lt; nums.size(); i++) { // 遍历当前元素，并在map中寻找是否有匹配的key auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter-\u0026gt;second, i}; // first ➜ 這筆資料的 Key（這裡是數值 nums[i]） // second ➜ 這筆資料的 Value（這裡是索引 i） } // 如果没找到匹配对，就把访问过的元素和下标加入到map中 map.insert(pair\u0026lt;int, int\u0026gt;(nums[i], i)); } return {}; } }; // 时间复杂度： O(n) // 空间复杂度： O(n) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/two-sum/","section":"All my post","summary":"Two Sum","title":"Two Sum","type":"docs"},{"content":"Leetcode link : Valid Anagram 描述 # 給定兩個字串 s 和 t ，寫一個函數來判斷 t 是否是 s 的字母異位詞。\n範例 1: 輸入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 輸出: true\n範例 2: 輸入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 輸出: false\n說明: 你可以假設字串只包含小寫字母。\n思路 # 暴力法：\n兩層 for 循環，同時還要記錄字符是否重複出現 時間複雜度是 O(n^2) Hashing：\n定一個陣列叫做 record，大小為 26 就可以了，初始化為 0，用來上記錄字串 s 裡字元出現的次數 解法 # class Solution { public: bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i \u0026lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.size(); i++) { record[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; 26; i++) { if (record[i] != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/valid-anagram/","section":"All my post","summary":"Valid Anagram","title":"Valid Anagram","type":"docs"},{"content":"Leetcode link : Design Linked List 描述 # get(index)：取得鍊錶中第 index 個節點的值。如果索引無效，則傳回-1。 addAtHead(val)：在鍊錶的第一個元素之前新增一個值為 val 的節點。插入後，新節點將成為鍊錶的第一個節點。 addAtTail(val)：將值為 val 的節點追加到鍊錶的最後一個元素。 addAtIndex(index,val)：在鍊錶中的第 index 個節點之前加入值為 val 的節點。如果 index 等於鍊錶的長度，則該節點將附加到鍊錶的末尾。如果 index 大於鍊錶長度，則不會插入節點。如果 index 小於 0，則在頭部插入節點。 deleteAtIndex(index)：如果索引 index 有效，則刪除鍊錶中的第 index 個節點。 解法 # // 时间复杂度：涉及 `index` 的相关操作为 O(index), 其余为 O(1) // 空间复杂度：O(n) class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-\u0026gt;next != nullptr){ cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入节点 void addAtIndex(int index, int val) { if(index \u0026gt; _size) return; if(index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; //delete命令指示释放了tmp指针原本所指的那部分内存， //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后， //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针 //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间 tmp=nullptr; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/design-linked-list/","section":"All my post","summary":"Design Linked List","title":"Design Linked List","type":"docs"},{"content":"Leetcode link : Linked List Cycle II 描述 # 給定一個鍊錶，返回鍊錶開始入環的第一個節點。 如果鍊錶無環，則傳回 null。 為了表示給定鍊錶中的環，使用整數 pos 來表示鍊錶尾連接到鍊錶中的位置（索引從 0 開始）。 如果 pos 是 -1，則在該鍊錶中沒有環。 思路 # fast 走兩個節點，slow 走一個節點 fast 指標走過的節點數 = slow 指標走過的節點數 * 2 (x + y) * 2 = x + y + n (y + z) -\u0026gt; x = (n - 1) (y + z) + z 若 n 為 1 則 x = z 意味著 fast 指針在環形裡轉了一圈之後，就遇到了 slow 指針了 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇 if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-\u0026gt;next; index2 = index2-\u0026gt;next; // 兩個一起往前直到相遇 一個從頭 一個從相遇點 } return index2; // 返回环的入口 } } return NULL; } }; // 时间复杂度：O(n) 快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/linked-list-cycle-ii/","section":"All my post","summary":"Linked List Cycle II","title":"Linked List Cycle II","type":"docs"},{"content":"","date":"2025-07-31","externalUrl":null,"permalink":"/tags/linkedlist/","section":"Tags","summary":"","title":"LinkedList","type":"tags"},{"content":"Leetcode link : Remove Linked List Elements 描述 # 刪除鍊錶中等於給定值 val 的所有節點。 範例 1： 輸入：head = [1,2,6,3,4,5,6], val = 6 輸出：[1,2,3,4,5] 思路 # 在單鍊錶中 移除頭結點 和 移除其他節點 的操作方式是不一樣，需要單獨寫一段邏輯來處理移除頭結點的情況。 其實可以設定一個 虛擬頭結點，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了。 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL \u0026amp;\u0026amp; head-\u0026gt;val == val) { // 注意这里不是if ListNode* tmp = head; head = head-\u0026gt;next; delete tmp; } // 删除非头结点 ListNode* cur = head; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next!= NULL) { if (cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } return head; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 所有的 linked list 的題目都可以設定一個 dummyHead，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了 ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-linked-list-elements/","section":"All my post","summary":"Remove Linked List Elements","title":"Remove Linked List Elements","type":"docs"},{"content":"Leetcode link : Remove Nth Node From End of List 描述 # 給一個鍊錶，刪除鍊錶的倒數第 n 個結點，並且回到鍊錶的頭結點。\n進階：你能嘗試使用一趟掃描實現嗎？\n輸入：head = [1,2,3,4,5], n = 2 輸出：[1,2,3,5]\n範例 2：輸入：head = [1], n = 1 輸出：[]\n範例 3：輸入：head = [1,2], n = 1 輸出：[1]\n思路 # 使用快慢指針 fast 先走 n + 1 步 ，為什麼是 n+1 呢，因為只有這樣同時移動的時候 slow 才能指向刪除節點的上一個節點 解法 # class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete tmp; return dummyHead-\u0026gt;next; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-nth-node-from-end-of-list/","section":"All my post","summary":"Remove Nth Node From End of List","title":"Remove Nth Node From End of List","type":"docs"},{"content":"Leetcode link : Reverse Linked List 描述 # 反轉一個單鍊錶。 輸入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 輸出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 思路 # 只需要 改變鍊錶的next指標的指向，直接將鍊錶反轉，不用重新定義一個新的鍊錶 流程 # 定義一個 cur 指針，指向頭 結點 再定義一個 pre 指針，初始化為 null 把 cur-\u0026gt;next 節點用 tmp 指針保存一下 改變 cur-\u0026gt;next 的指向了，將 cur-\u0026gt;next 指向 pre 繼續移動 pre 和 cur 指針 cur 指標已經指向了 null，循環結束，return pre 指針 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; // 时间复杂度：O(n) 要递归处理链表的每个节点 // 空间复杂度：O(n) 递归调用了 n 层栈空间 // 可以看到双指针法中初始化 cur = head，pre = NULL class Solution { public: ListNode* reverse(ListNode* pre,ListNode* cur){ if(cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); } ListNode* reverseList(ListNode* head) { // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/reverse-linked-list/","section":"All my post","summary":"Reverse Linked List","title":"Reverse Linked List","type":"docs"},{"content":"Leetcode link : Swap Nodes in Pairs 描述 # 給定一個鍊錶，兩兩交換其中相鄰的節點，並傳回交換後的鍊錶。\n不能只是單純的改變節點內部的值，而是需要實際的進行節點交換。\n思路 # 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 頭接給 2 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 2 接給 1 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 此時 cur 已經改接了 2, 1 因此需要把它接到 3 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } ListNode* result = dummyHead-\u0026gt;next; delete dummyHead; return result; } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/swap-nodes-in-pairs/","section":"All my post","summary":"Swap Nodes in Pairs","title":"Swap Nodes in Pairs","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/array/","section":"Tags","summary":"","title":"Array","type":"tags"},{"content":"Leetcode link : Minimum Size Subarray Sum 描述 # 給定一個含有 n 個正整數的數組和一個正整數 s 找出該數組中滿足其和 ≥ s 的長度最小的 連續 子數組 並返回其長度。 如果不存在符合條件的子數組，則傳回 0。 思路 # 暴力解法：兩個 for 循環，不斷的尋找符合條件的子序列 時間複雜度：O(n^2) 空間複雜度：O(1) Sliding window： 時間複雜度：O(n) 空間複雜度：O(1) 每次需詢問三個問題： 窗口內是什麼？ 如何移動視窗的起始位置？ 如何移動視窗的結束位置？ 此題為例： 窗口 -\u0026gt; 滿足其和 ≥ s 的長度最小的 連續 子數組。 視窗的起始位置如何移動 -\u0026gt; 如果目前視窗的值大於等於 s 了，視窗就要向前移動了（也就是該縮小了）。 視窗的結束位置如何移動 -\u0026gt; 視窗的結束位置就是遍歷數組的指針，也就是 for 迴圈裡的索引。 解法 # class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n) // - 空间复杂度：O(1) class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i \u0026lt; nums.size(); i++) { // 设置子序列起点为i sum = 0; for (int j = i; j \u0026lt; nums.size(); j++) { // 设置子序列终止位置为j sum += nums[j]; if (sum \u0026gt;= s) { // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break } } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n^2) // - 空间复杂度：O(1) 注意 # 不要以為 for 裡放一個 while 就以為是 O(n^2) 主要是看每一個元素被操作的次數 每個元素在滑動窗後進來操作一次，出去操作一次，每個元素都是被操作兩次 所以時間複雜度是 2 × n 也就是 O(n)。 ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/minimum-size-subarray-sum/","section":"All my post","summary":"Minimum Size Subarray Sum","title":"Minimum Size Subarray Sum","type":"docs"},{"content":"Leetcode link : Spiral Matrix II 描述 # 給定一個正整數 n，產生一個包含 1 到 n^2 所有元素，且元素以順時針順序螺旋排列的正方形矩陣。 思路 # 程式碼裡處理的原則統一的左閉右開 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop --) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j; j \u0026lt; n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i; i \u0026lt; n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j \u0026gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i \u0026gt; startx; i--) { res[i][j] = count++; } // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) { res[mid][mid] = count; } return res; } }; // - 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 // - 空间复杂度 O(1) ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/spiral-matrix-ii/","section":"All my post","summary":"Spiral Matrix II","title":"Spiral Matrix II","type":"docs"},{"content":"Leetcode link : Squares of a Sorted Array 描述 # 給一個按 非遞減順序 排序的整數數組 nums，返回 每個數字的平方 組成的新數組，要求也按 非遞減順序 排序。 思路 # 暴力解法：O(n + nlogn) 每個數平方之後，排個序 雙指標法：O(n) 數組其實是有序的， 只不過負數平方之後可能變成最大數了。 那麼陣列平方的最大值就在陣列的兩端，不是最左邊就是最右邊，不可能是中間。 i 指向起始位置，j 指向終止位置。 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0; i \u0026lt; A.size(); i++) { A[i] *= A[i]; } sort(A.begin(), A.end()); // 快速排序 return A; } }; // 时间复杂度：O(n + nlogn) // 空间复杂度：O(1) class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { int k = A.size() - 1; vector\u0026lt;int\u0026gt; result(A.size(), 0); for (int i = 0, j = A.size() - 1; i \u0026lt;= j;) { // 注意这里要i \u0026lt;= j，因为最后要处理两个元素 if (A[i] * A[i] \u0026lt; A[j] * A[j]) { result[k--] = A[j] * A[j]; j--; } else { result[k--] = A[i] * A[i]; i++; } } return result; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-05-04","externalUrl":null,"permalink":"/docs/squares-of-a-sorted-array/","section":"All my post","summary":"Squares of a Sorted Array","title":"Squares of a Sorted Array","type":"docs"},{"content":"Leetcode link : Binary Search 描述 # 二分法的前提條件 # 數組為有序數組 數組中無重複元素，一旦有重複元素，使用二分查找法傳回的元素下標可能不是唯一的 思路 # 左閉右閉即[left, right] 左閉右開即[left, right) 解法 # // 左閉右閉 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 左閉右閉，[left, right] int right = nums.size(); // 左閉右開，即：[left, right) while (left \u0026lt;= right) { // 左閉右閉，当left==right，区间[left, right]依然有效，所以用 \u0026lt;= while (left \u0026lt; right) { // 左閉右開，因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; // 左閉右閉 right = middle; // 左閉右開 } else if (nums[middle] \u0026lt; target) { left = middle + 1; } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 注意 # int middle = left + ((right - left) / 2); 防止溢出 等同于(left + right)/2 採用左閉右閉即 [left, right] 即可，左右剛好符合 Array 的編號 ","date":"2025-05-03","externalUrl":null,"permalink":"/docs/binary-search/","section":"All my post","summary":"Binary Search","title":"Binary Search","type":"docs"},{"content":"Leetcode link : Remove Element 描述 # 移除所有數值等於 val 的元素，並傳回移除後陣列的新長度 In-place : 必須僅使用 O(1) 額外空間並原地修改輸入數組 不需要考慮數組中超出新長度後面的元素 需考慮輸入的 Array 是否為 0 思路 # 暴力解法： O(n^2) 兩層 for 迴圈，一個 for 迴圈遍歷數組元素，第二個 for 迴圈更新數組 雙指針： O(n) 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-01-02","externalUrl":null,"permalink":"/docs/remove-element/","section":"All my post","summary":"Remove Element","title":"Remove Element","type":"docs"},{"content":" My Work experience # TSMC 2024/10 - present Software Engineer Implemented WebFlux to restructure API gateway into non-blocking architecture, significantly increasing request throughput and reducing response latency by 4x in p95. Optimized log filtering methods in middleware using Spring Boot, enhancing the efficiency of log analysis for system maintenance. Refactored SQL query methods in APIs, resulting in 3x improvement in API execution efficiency. Learned front-end development from zero in a month, and focused on developing and optimizing Lot Tracking System front-end features using Next.js and TypeScript. Rewrote R\u0026D system KPIs into Prometheus metrics, used Grafana for real-time monitoring and alerts, and optimized dashboard for managerial overview. KK company 2022/6 - 2023/7 Management Associate Executed AWS Lambda function via Python Boto3 to calculate internal AWS S3 \u0026 CDN usage, and used Python Logging and Pytest for unit testing. Implemented project integration in Gitlab repo, established reusable packages and used Gitlab CI/CD and Terraform for pipeline deployment planning. Applied TF-IDF algorithm to optimize information retrieval in the internal streaming platform recommendation system. NCCU 2021/9 - 2023/7 Master Degree Used the transformer-based model to generate and fine-tune embedding vectors for HTTP session classification, achieving 89.23% prediction accuracy in attack tactics. Applied session embedding algorithm based on DBSCAN to identify attack patterns and monitor attack progress for early-stage defense. Developed a data analysis dashboard using Django and Docker for real-time data analysis and visualization, reducing time and cost for information security personnel analyzing malicious attack logs and packets. My Skill stack # ","date":"2025-01-01","externalUrl":null,"permalink":"/self-introduction/","section":"","summary":"self-introduction","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]