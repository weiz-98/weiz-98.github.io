
[{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" 一些工作雜記.. ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/","section":"All my post","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  一些工作雜記..\n\u003c/div\u003e\n\n\u003chr\u003e","title":"All my post","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"Leetcode link : Find Common Characters 描述 # 給你一個字串陣列 words ，請你找出所有在 words 的每個字串中都出現的共用字元（ 包括重複字元），並以陣列形式傳回。你可以按 任意順序 返回答案。\n範例 1：輸入：words = [\u0026ldquo;bella\u0026rdquo;,\u0026ldquo;label\u0026rdquo;,\u0026ldquo;roller\u0026rdquo;] 輸出：[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;]\n範例 2：輸入：words = [\u0026ldquo;cool\u0026rdquo;,\u0026ldquo;lock\u0026rdquo;,\u0026ldquo;cook\u0026rdquo;] 輸出：[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;o\u0026rdquo;]\n提示：1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] 由小寫英文字母組成\n思路 # 暴力法：\n時間複雜度是 O(n^m) 一個字串一個字串去搜，n 是字串長度，m 是有幾個字串。 碼實現也不容易，因為要統計 重複的字符，還要適當的替換或去重 Hashing：\n統計出搜尋字串裡 26 個字元的出現的頻率 取每個字元頻率最小值，最後轉成輸出格式就可以了 解法 # class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; A) { vector\u0026lt;string\u0026gt; result; if (A.size() == 0) return result; int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率 for (int i = 0; i \u0026lt; A[0].size(); i++) { // 用第一个字符串给hash初始化 hash[A[0][i] - \u0026#39;a\u0026#39;]++; } int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率 for (int i = 1; i \u0026lt; A.size(); i++) { memset(hashOtherStr, 0, 26 * sizeof(int)); for (int j = 0; j \u0026lt; A[i].size(); j++) { hashOtherStr[A[i][j] - \u0026#39;a\u0026#39;]++; } // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数 for (int k = 0; k \u0026lt; 26; k++) { hash[k] = min(hash[k], hashOtherStr[k]); } } // 将hash统计的字符次数，转成输出形式 for (int i = 0; i \u0026lt; 26; i++) { while (hash[i] != 0) { // 注意这里是while，多个重复的字符 string s(1, i + \u0026#39;a\u0026#39;); // char -\u0026gt; string result.push_back(s); hash[i]--; } } return result; } }; // 时间复杂度：O(n) 所有字元的總數 // 空间复杂度：O(1) 每條字串長度都是固定常數 或 可視為相同平均長度 L 時候字元總數 N = n * L 於是時間複雜度為 n\n如果字串長度差異很大、或隨著輸入放大而成長，就必須把長度考慮進去，寫成 O(nL) or O(N)\n","date":"2025-08-02","externalUrl":null,"permalink":"/docs/find-common-characters/","section":"All my post","summary":"Find Common Characters","title":"Find Common Characters","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/hashing/","section":"Tags","summary":"","title":"Hashing","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Leetcode link : Valid Anagram 描述 # 給定兩個字串 s 和 t ，寫一個函數來判斷 t 是否是 s 的字母異位詞。\n範例 1: 輸入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 輸出: true\n範例 2: 輸入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 輸出: false\n說明: 你可以假設字串只包含小寫字母。\n思路 # 暴力法：\n兩層 for 循環，同時還要記錄字符是否重複出現 時間複雜度是 O(n^2) Hashing：\n定一個陣列叫做 record，大小為 26 就可以了，初始化為 0，用來上記錄字串 s 裡字元出現的次數 解法 # class Solution { public: bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i \u0026lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.size(); i++) { record[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; 26; i++) { if (record[i] != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-08-02","externalUrl":null,"permalink":"/docs/valid-anagram/","section":"All my post","summary":"Valid Anagram","title":"Valid Anagram","type":"docs"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/authors/wz-chen/","section":"Authors","summary":"","title":"WZ Chen","type":"authors"},{"content":"Leetcode link : Design Linked List 描述 # get(index)：取得鍊錶中第 index 個節點的值。如果索引無效，則傳回-1。 addAtHead(val)：在鍊錶的第一個元素之前新增一個值為 val 的節點。插入後，新節點將成為鍊錶的第一個節點。 addAtTail(val)：將值為 val 的節點追加到鍊錶的最後一個元素。 addAtIndex(index,val)：在鍊錶中的第 index 個節點之前加入值為 val 的節點。如果 index 等於鍊錶的長度，則該節點將附加到鍊錶的末尾。如果 index 大於鍊錶長度，則不會插入節點。如果 index 小於 0，則在頭部插入節點。 deleteAtIndex(index)：如果索引 index 有效，則刪除鍊錶中的第 index 個節點。 解法 # // 时间复杂度：涉及 `index` 的相关操作为 O(index), 其余为 O(1) // 空间复杂度：O(n) class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-\u0026gt;next != nullptr){ cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入节点 void addAtIndex(int index, int val) { if(index \u0026gt; _size) return; if(index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; //delete命令指示释放了tmp指针原本所指的那部分内存， //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后， //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针 //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间 tmp=nullptr; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/design-linked-list/","section":"All my post","summary":"Design Linked List","title":"Design Linked List","type":"docs"},{"content":"Leetcode link : Linked List Cycle II 描述 # 給定一個鍊錶，返回鍊錶開始入環的第一個節點。 如果鍊錶無環，則傳回 null。 為了表示給定鍊錶中的環，使用整數 pos 來表示鍊錶尾連接到鍊錶中的位置（索引從 0 開始）。 如果 pos 是 -1，則在該鍊錶中沒有環。 思路 # fast 走兩個節點，slow 走一個節點 fast 指標走過的節點數 = slow 指標走過的節點數 * 2 (x + y) * 2 = x + y + n (y + z) -\u0026gt; x = (n - 1) (y + z) + z 若 n 為 1 則 x = z 意味著 fast 指針在環形裡轉了一圈之後，就遇到了 slow 指針了 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇 if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-\u0026gt;next; index2 = index2-\u0026gt;next; // 兩個一起往前直到相遇 一個從頭 一個從相遇點 } return index2; // 返回环的入口 } } return NULL; } }; // 时间复杂度：O(n) 快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/linked-list-cycle-ii/","section":"All my post","summary":"Linked List Cycle II","title":"Linked List Cycle II","type":"docs"},{"content":"","date":"2025-07-31","externalUrl":null,"permalink":"/tags/linkedlist/","section":"Tags","summary":"","title":"LinkedList","type":"tags"},{"content":"","date":"2025-07-31","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Leetcode link : Remove Linked List Elements 描述 # 刪除鍊錶中等於給定值 val 的所有節點。 範例 1： 輸入：head = [1,2,6,3,4,5,6], val = 6 輸出：[1,2,3,4,5] 思路 # 在單鍊錶中 移除頭結點 和 移除其他節點 的操作方式是不一樣，需要單獨寫一段邏輯來處理移除頭結點的情況。 其實可以設定一個 虛擬頭結點，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了。 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL \u0026amp;\u0026amp; head-\u0026gt;val == val) { // 注意这里不是if ListNode* tmp = head; head = head-\u0026gt;next; delete tmp; } // 删除非头结点 ListNode* cur = head; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next!= NULL) { if (cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } return head; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 所有的 linked list 的題目都可以設定一個 dummyHead，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了 ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-linked-list-elements/","section":"All my post","summary":"Remove Linked List Elements","title":"Remove Linked List Elements","type":"docs"},{"content":"Leetcode link : Remove Nth Node From End of List 描述 # 給一個鍊錶，刪除鍊錶的倒數第 n 個結點，並且回到鍊錶的頭結點。\n進階：你能嘗試使用一趟掃描實現嗎？\n輸入：head = [1,2,3,4,5], n = 2 輸出：[1,2,3,5]\n範例 2：輸入：head = [1], n = 1 輸出：[]\n範例 3：輸入：head = [1,2], n = 1 輸出：[1]\n思路 # 使用快慢指針 fast 先走 n + 1 步 ，為什麼是 n+1 呢，因為只有這樣同時移動的時候 slow 才能指向刪除節點的上一個節點 解法 # class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete tmp; return dummyHead-\u0026gt;next; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/remove-nth-node-from-end-of-list/","section":"All my post","summary":"Remove Nth Node From End of List","title":"Remove Nth Node From End of List","type":"docs"},{"content":"Leetcode link : Reverse Linked List 描述 # 反轉一個單鍊錶。 輸入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 輸出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL 思路 # 只需要 改變鍊錶的next指標的指向，直接將鍊錶反轉，不用重新定義一個新的鍊錶 流程 # 定義一個 cur 指針，指向頭 結點 再定義一個 pre 指針，初始化為 null 把 cur-\u0026gt;next 節點用 tmp 指針保存一下 改變 cur-\u0026gt;next 的指向了，將 cur-\u0026gt;next 指向 pre 繼續移動 pre 和 cur 指針 cur 指標已經指向了 null，循環結束，return pre 指針 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; // 时间复杂度：O(n) 要递归处理链表的每个节点 // 空间复杂度：O(n) 递归调用了 n 层栈空间 // 可以看到双指针法中初始化 cur = head，pre = NULL class Solution { public: ListNode* reverse(ListNode* pre,ListNode* cur){ if(cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); } ListNode* reverseList(ListNode* head) { // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/reverse-linked-list/","section":"All my post","summary":"Reverse Linked List","title":"Reverse Linked List","type":"docs"},{"content":"Leetcode link : Swap Nodes in Pairs 描述 # 給定一個鍊錶，兩兩交換其中相鄰的節點，並傳回交換後的鍊錶。\n不能只是單純的改變節點內部的值，而是需要實際的進行節點交換。\n思路 # 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 頭接給 2 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 2 接給 1 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 此時 cur 已經改接了 2, 1 因此需要把它接到 3 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } ListNode* result = dummyHead-\u0026gt;next; delete dummyHead; return result; } }; ","date":"2025-07-31","externalUrl":null,"permalink":"/docs/swap-nodes-in-pairs/","section":"All my post","summary":"Swap Nodes in Pairs","title":"Swap Nodes in Pairs","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/array/","section":"Tags","summary":"","title":"Array","type":"tags"},{"content":"Leetcode link : Minimum Size Subarray Sum 描述 # 給定一個含有 n 個正整數的數組和一個正整數 s 找出該數組中滿足其和 ≥ s 的長度最小的 連續 子數組 並返回其長度。 如果不存在符合條件的子數組，則傳回 0。 思路 # 暴力解法：兩個 for 循環，不斷的尋找符合條件的子序列 時間複雜度：O(n^2) 空間複雜度：O(1) Sliding window： 時間複雜度：O(n) 空間複雜度：O(1) 每次需詢問三個問題： 窗口內是什麼？ 如何移動視窗的起始位置？ 如何移動視窗的結束位置？ 此題為例： 窗口 -\u0026gt; 滿足其和 ≥ s 的長度最小的 連續 子數組。 視窗的起始位置如何移動 -\u0026gt; 如果目前視窗的值大於等於 s 了，視窗就要向前移動了（也就是該縮小了）。 視窗的結束位置如何移動 -\u0026gt; 視窗的結束位置就是遍歷數組的指針，也就是 for 迴圈裡的索引。 解法 # class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n) // - 空间复杂度：O(1) class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i \u0026lt; nums.size(); i++) { // 设置子序列起点为i sum = 0; for (int j = i; j \u0026lt; nums.size(); j++) { // 设置子序列终止位置为j sum += nums[j]; if (sum \u0026gt;= s) { // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break } } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n^2) // - 空间复杂度：O(1) 注意 # 不要以為 for 裡放一個 while 就以為是 O(n^2) 主要是看每一個元素被操作的次數 每個元素在滑動窗後進來操作一次，出去操作一次，每個元素都是被操作兩次 所以時間複雜度是 2 × n 也就是 O(n)。 ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/minimum-size-subarray-sum/","section":"All my post","summary":"Minimum Size Subarray Sum","title":"Minimum Size Subarray Sum","type":"docs"},{"content":"Leetcode link : Spiral Matrix II 描述 # 給定一個正整數 n，產生一個包含 1 到 n^2 所有元素，且元素以順時針順序螺旋排列的正方形矩陣。 思路 # 程式碼裡處理的原則統一的左閉右開 解法 # class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); // 使用vector定义一个二维数组 int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop --) { i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j; j \u0026lt; n - offset; j++) { res[i][j] = count++; } // 模拟填充右列从上到下(左闭右开) for (i; i \u0026lt; n - offset; i++) { res[i][j] = count++; } // 模拟填充下行从右到左(左闭右开) for (; j \u0026gt; starty; j--) { res[i][j] = count++; } // 模拟填充左列从下到上(左闭右开) for (; i \u0026gt; startx; i--) { res[i][j] = count++; } // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) { res[mid][mid] = count; } return res; } }; // - 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 // - 空间复杂度 O(1) ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/spiral-matrix-ii/","section":"All my post","summary":"Spiral Matrix II","title":"Spiral Matrix II","type":"docs"},{"content":"Leetcode link : Squares of a Sorted Array 描述 # 給一個按 非遞減順序 排序的整數數組 nums，返回 每個數字的平方 組成的新數組，要求也按 非遞減順序 排序。 思路 # 暴力解法：O(n + nlogn) 每個數平方之後，排個序 雙指標法：O(n) 數組其實是有序的， 只不過負數平方之後可能變成最大數了。 那麼陣列平方的最大值就在陣列的兩端，不是最左邊就是最右邊，不可能是中間。 i 指向起始位置，j 指向終止位置。 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0; i \u0026lt; A.size(); i++) { A[i] *= A[i]; } sort(A.begin(), A.end()); // 快速排序 return A; } }; // 时间复杂度：O(n + nlogn) // 空间复杂度：O(1) class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { int k = A.size() - 1; vector\u0026lt;int\u0026gt; result(A.size(), 0); for (int i = 0, j = A.size() - 1; i \u0026lt;= j;) { // 注意这里要i \u0026lt;= j，因为最后要处理两个元素 if (A[i] * A[i] \u0026lt; A[j] * A[j]) { result[k--] = A[j] * A[j]; j--; } else { result[k--] = A[i] * A[i]; i++; } } return result; } }; // 时间复杂度：O(n) // 空间复杂度：O(1) ","date":"2025-05-04","externalUrl":null,"permalink":"/docs/squares-of-a-sorted-array/","section":"All my post","summary":"Squares of a Sorted Array","title":"Squares of a Sorted Array","type":"docs"},{"content":"Leetcode link : Binary Search 描述 # 二分法的前提條件 # 數組為有序數組 數組中無重複元素，一旦有重複元素，使用二分查找法傳回的元素下標可能不是唯一的 思路 # 左閉右閉即[left, right] 左閉右開即[left, right) 解法 # // 左閉右閉 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 左閉右閉，[left, right] int right = nums.size(); // 左閉右開，即：[left, right) while (left \u0026lt;= right) { // 左閉右閉，当left==right，区间[left, right]依然有效，所以用 \u0026lt;= while (left \u0026lt; right) { // 左閉右開，因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; // 左閉右閉 right = middle; // 左閉右開 } else if (nums[middle] \u0026lt; target) { left = middle + 1; } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 注意 # int middle = left + ((right - left) / 2); 防止溢出 等同于(left + right)/2 採用左閉右閉即 [left, right] 即可，左右剛好符合 Array 的編號 ","date":"2025-05-03","externalUrl":null,"permalink":"/docs/binary-search/","section":"All my post","summary":"Binary Search","title":"Binary Search","type":"docs"},{"content":"Leetcode link : Remove Element 描述 # 移除所有數值等於 val 的元素，並傳回移除後陣列的新長度 In-place : 必須僅使用 O(1) 額外空間並原地修改輸入數組 不需要考慮數組中超出新長度後面的元素 需考慮輸入的 Array 是否為 0 思路 # 暴力解法： O(n^2) 兩層 for 迴圈，一個 for 迴圈遍歷數組元素，第二個 for 迴圈更新數組 雙指針： O(n) 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-01-02","externalUrl":null,"permalink":"/docs/remove-element/","section":"All my post","summary":"Remove Element","title":"Remove Element","type":"docs"},{"content":" My Work experience # TSMC 2024/10 - present Software Engineer Implemented WebFlux to restructure API gateway into non-blocking architecture, significantly increasing request throughput and reducing response latency by 4x in p95. Optimized log filtering methods in middleware using Spring Boot, enhancing the efficiency of log analysis for system maintenance. Refactored SQL query methods in APIs, resulting in 3x improvement in API execution efficiency. Learned front-end development from zero in a month, and focused on developing and optimizing Lot Tracking System front-end features using Next.js and TypeScript. Rewrote R\u0026D system KPIs into Prometheus metrics, used Grafana for real-time monitoring and alerts, and optimized dashboard for managerial overview. KK company 2022/6 - 2023/7 Management Associate Executed AWS Lambda function via Python Boto3 to calculate internal AWS S3 \u0026 CDN usage, and used Python Logging and Pytest for unit testing. Implemented project integration in Gitlab repo, established reusable packages and used Gitlab CI/CD and Terraform for pipeline deployment planning. Applied TF-IDF algorithm to optimize information retrieval in the internal streaming platform recommendation system. NCCU 2021/9 - 2023/7 Master Degree Used the transformer-based model to generate and fine-tune embedding vectors for HTTP session classification, achieving 89.23% prediction accuracy in attack tactics. Applied session embedding algorithm based on DBSCAN to identify attack patterns and monitor attack progress for early-stage defense. Developed a data analysis dashboard using Django and Docker for real-time data analysis and visualization, reducing time and cost for information security personnel analyzing malicious attack logs and packets. My Skill stack # ","date":"2025-01-01","externalUrl":null,"permalink":"/self-introduction/","section":"","summary":"self-introduction","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]