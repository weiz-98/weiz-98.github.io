
[{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" 一些工作雜記.. ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/","section":"All my post","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  一些工作雜記..\n\u003c/div\u003e\n\n\u003chr\u003e","title":"All my post","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Leetcode link : Minimum Size Subarray Sum 描述 # 給定一個含有 n 個正整數的數組和一個正整數 s 找出該數組中滿足其和 ≥ s 的長度最小的 連續 子數組 並返回其長度。 如果不存在符合條件的子數組，則傳回 0。 思路 # 暴力解法：兩個 for 循環，不斷的尋找符合條件的子序列 時間複雜度：O(n^2) 空間複雜度：O(1) Sliding window： 時間複雜度：O(n) 空間複雜度：O(1) 每次需詢問三個問題： 窗口內是什麼？ 如何移動視窗的起始位置？ 如何移動視窗的結束位置？ 此題為例： 窗口 -\u0026gt; 滿足其和 ≥ s 的長度最小的 連續 子數組。 視窗的起始位置如何移動 -\u0026gt; 如果目前視窗的值大於等於 s 了，視窗就要向前移動了（也就是該縮小了）。 視窗的結束位置如何移動 -\u0026gt; 視窗的結束位置就是遍歷數組的指針，也就是 for 迴圈裡的索引。 解法 # class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n) // - 空间复杂度：O(1) class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i \u0026lt; nums.size(); i++) { // 设置子序列起点为i sum = 0; for (int j = i; j \u0026lt; nums.size(); j++) { // 设置子序列终止位置为j sum += nums[j]; if (sum \u0026gt;= s) { // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break } } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; // - 时间复杂度：O(n^2) // - 空间复杂度：O(1) 注意 # 不要以為 for 裡放一個 while 就以為是 O(n^2) 主要是看每一個元素被操作的次數 每個元素在滑動窗後進來操作一次，出去操作一次，每個元素都是被操作兩次 所以時間複雜度是 2 × n 也就是 O(n)。 ","date":"2025-07-29","externalUrl":null,"permalink":"/docs/minimum-size-subarray-sum/","section":"All my post","summary":"Minimum Size Subarray Sum","title":"Minimum Size Subarray Sum","type":"docs"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-07-29","externalUrl":null,"permalink":"/authors/wz-chen/","section":"Authors","summary":"","title":"WZ Chen","type":"authors"},{"content":"","date":"2025-05-04","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"Leetcode link : Squares of a Sorted Array 描述 # 給一個按 非遞減順序 排序的整數數組 nums，返回 每個數字的平方 組成的新數組，要求也按 非遞減順序 排序。 思路 # 暴力解法 O(n^2)：兩層 for 迴圈，一個 for 迴圈遍歷數組元素 ，第二個 for 迴圈更新數組 雙指針 O(n)： 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0 時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-05-04","externalUrl":null,"permalink":"/docs/squares-of-a-sorted-array/","section":"All my post","summary":"Squares of a Sorted Array","title":"Squares of a Sorted Array","type":"docs"},{"content":"Leetcode link : 704. Binary Search 描述 # 二分法的前提條件 # 數組為有序數組 數組中無重複元素，一旦有重複元素，使用二分查找法傳回的元素下標可能不是唯一的 思路 # 左閉右閉即[left, right] 左閉右開即[left, right) 解法 # // 左閉右閉 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 左閉右閉，[left, right] int right = nums.size(); // 左閉右開，即：[left, right) while (left \u0026lt;= right) { // 左閉右閉，当left==right，区间[left, right]依然有效，所以用 \u0026lt;= while (left \u0026lt; right) { // 左閉右開，因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; // 左閉右閉 right = middle; // 左閉右開 } else if (nums[middle] \u0026lt; target) { left = middle + 1; } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 注意 # int middle = left + ((right - left) / 2); 防止溢出 等同于(left + right)/2 採用左閉右閉即 [left, right] 即可，左右剛好符合 Array 的編號 ","date":"2025-05-03","externalUrl":null,"permalink":"/docs/binary-search/","section":"All my post","summary":"Binary Search","title":"Binary Search","type":"docs"},{"content":"Leetcode link : Remove Element 描述 # 移除所有數值等於 val 的元素，並傳回移除後陣列的新長度 In-place : 必須僅使用 O(1) 額外空間並原地修改輸入數組 不需要考慮數組中超出新長度後面的元素 需考慮輸入的 Array 是否為 0 思路 # 暴力解法 O(n^2)：兩層 for 迴圈，一個 for 迴圈遍歷數組元素 ，第二個 for 迴圈更新數組 雙指針 O(n)： 快指標：尋找新數組的元素 ，新數組就是不含目標元素的數組 慢指標：指向更新新數組下標的位置 以上兩個方法空間皆為 O(1) 解法 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 注意 # 這題就不能使用 fastIndex \u0026lt;= nums.size() - 1 了\n雖然是習慣的左閉右閉，但是當 nums.size() == 0時，就會有 error\n考慮到 nums.size() == 0 時，就採取 fastIndex \u0026lt; nums.size() ","date":"2025-01-02","externalUrl":null,"permalink":"/docs/remove-element/","section":"All my post","summary":"Remove Element","title":"Remove Element","type":"docs"},{"content":" My Work experience # TSMC 2024/10 - present Software Engineer Implemented WebFlux to restructure API gateway into non-blocking architecture, significantly increasing request throughput and reducing response latency by 4x in p95. Optimized log filtering methods in middleware using Spring Boot, enhancing the efficiency of log analysis for system maintenance. Refactored SQL query methods in APIs, resulting in 3x improvement in API execution efficiency. Learned front-end development from zero in a month, and focused on developing and optimizing Lot Tracking System front-end features using Next.js and TypeScript. Rewrote R\u0026D system KPIs into Prometheus metrics, used Grafana for real-time monitoring and alerts, and optimized dashboard for managerial overview. KK company 2022/6 - 2023/7 Management Associate Executed AWS Lambda function via Python Boto3 to calculate internal AWS S3 \u0026 CDN usage, and used Python Logging and Pytest for unit testing. Implemented project integration in Gitlab repo, established reusable packages and used Gitlab CI/CD and Terraform for pipeline deployment planning. Applied TF-IDF algorithm to optimize information retrieval in the internal streaming platform recommendation system. NCCU 2021/9 - 2023/7 Master Degree Used the transformer-based model to generate and fine-tune embedding vectors for HTTP session classification, achieving 89.23% prediction accuracy in attack tactics. Applied session embedding algorithm based on DBSCAN to identify attack patterns and monitor attack progress for early-stage defense. Developed a data analysis dashboard using Django and Docker for real-time data analysis and visualization, reducing time and cost for information security personnel analyzing malicious attack logs and packets. My Skill stack # ","date":"2025-01-01","externalUrl":null,"permalink":"/self-introduction/","section":"","summary":"self-introduction","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]